<?php

/*
 * This function determines the audience for an email and sets up data for
 * other functions to use
 */
function _cbf_civicrm_email_audience($params, $context) {
  $audienceData = &drupal_static(__FUNCTION__);
  if (empty($audienceData)) {
    $audienceData = [
      'audience' => '',
      'audiences' => [
        'general' => [
          'colour' => '#cf2e4f',
        ],
        'christian' => [
          'colour' => '#1c9cd6',
        ],
      ],
      'cache' => [],
    ];

    foreach (domain_list_by_machine_name() as $domain) {
      $domainAudience = $domain['machine_name'];
      if (isset($audienceData['audiences'][$domainAudience])) {
        $audienceData['audiences'][$domainAudience]['name'] = $domain['sitename'];
        $audienceData['audiences'][$domainAudience]['host'] = 'https://' . $domain['subdomain'];
        $audienceData['audiences'][$domainAudience]['email domain'] = $domain['subdomain'];

        $audienceData['audiences'][$domainAudience]['hostnames'] = [];
        $audienceData['audiences'][$domainAudience]['hostnames'][] = $domain['subdomain'];
        foreach ($domain['aliases'] as $alias) {
          $audienceData['audiences'][$domainAudience]['hostnames'][] = $alias['pattern'];
        }

        $h = '(' . implode('|', $audienceData['audiences'][$domainAudience]['hostnames']) . ')';
        $h = str_replace('.', '\.', $h);
        $audienceData['audiences'][$domainAudience]['patterns'] = [
          'colour' =>        '!' . '(color: |")' . $audienceData['audiences'][$domainAudience]['colour'] . '(;|")' . '!i',
          '20' =>            '!' . ' href=("|\')(http(s)?:)?//' . $h . '("|\'|/)' . '!i',
          '30' =>            '!' . '^' . $h . '$' . '!i',
          'email domain' =>  '!' . '(@)' . $h . '(>|$)' . '!i',
          'email name' =>    '!' . '(".*)(' . $audienceData['audiences'][$domainAudience]['name'] . ')(.*")' . '!i',
          'html' =>          '!' . ' (href|src)=("|\')(http(s)?:)?//' . $h . '("|\'|/)' . '!i',
          'text' =>          '!' . '(^| )(http(s)?:)?//' . $h . '( |/)?' . '!i',
        ];
      }
    }

    /*
     * We can determine the $audience for the email using one of the following
     * rules ...
     *  1   - Inspect the Audience of the Drupal CiviCRM Event
     *         a - For a Scheduled Reminder sent to a Participant
     *  2   - Inspect the Campaign associated with the email for an Audience
     *         a - For a Send Email action use Activity > Campaign > Audience
     *         b - For a CiviMail use MailingJob > Mailing > Campaign > Audience
     *         c - For a Scheduled Reminder use Event > Campaign > Audience
     *  20  - Inspect the email for HREF links that select an Audience
     *  30  - Inspect the current domain to see if that selects an Audience
     *  99 - If the previous rules fail to set an $audience, set it to 'general'
     */

    /*
     * The $context and $params guide which $audience rules are applicable
     */
    $audienceRule = [];
    $workflow = $params['workflow'] ?? $params['valueName'] ?? $params['groupName'] ?? '';
    if (empty($context)) {
      /*
       * This function can be called from cbf_civicrm_civicrm_alterMailContent
       * and cbf_civicrm_civicrm_alterMailParams which have differences between
       * their parameters. So we just need to reconcile them.
       */
      if (isset($params['mailingID'])) {
        $context = 'civimail';
      }
      else if ($workflow) {
        $context = 'singleEmail';
      }
      else if (!empty($params['messageTemplateID'])) {
        $context = 'messageTemplate';
      }
      else {
        $context = 'civimail';
      }
    }
    switch ($context) {
      case 'singleEmail':
        switch ($workflow) {
          // Scheduled Reminder
          case 'Scheduled Reminder Sender':
            $audienceRule['1.a'] = true;
            $audienceRule['2.c'] = true;
            $audienceRule['20'] = true;
            break;

          // Send Email action
          case 'Activity Email Sender':
            $audienceRule['2.a'] = true;
            $audienceRule['20'] = true;
            $audienceRule['30'] = true;
            break;

          // Non-batch actions
          case 'case_activity':
          case 'contribution_dupalert':
          case 'contribution_online_receipt':
          case 'contribution_recurring_edit':
          case 'event_online_receipt':
          case 'event_registration_receipt':
          case 'friend':
          case 'membership_online_receipt':
          case 'petition_confirmation_needed':
          case 'petition_sign':
          case 'pcp_notify':
          case 'pcp_owner_notify':
          case 'pcp_status_change':
          case 'pcp_supporter_notify':
          case 'pledge_acknowledge':
          case 'uf_notify':
            $audienceRule['30'] = true;
            break;

          // Batch actions where 'christian' can be assumed
          case 'contribution_recurring_billing':
          case 'contribution_recurring_cancelled':
          case 'contribution_recurring_notify':
          case 'membership_autorenew_billing':
          case 'membership_autorenew_cancelled':
          case 'pledge_reminder':
            $audienceRule['30'] = true;
            break;

          // Offline actions where 'christian' is not offensive if chosen
          case 'contribution_invoice_receipt':
          case 'contribution_offline_receipt':
          case 'event_offline_receipt':
          case 'membership_offline_receipt':
          case 'payment_or_refund_notification':
            $audienceRule['30'] = true;
            break;
        }
        break;

      case 'civimail':
        $audienceRule['2.b'] = true;
        $audienceRule['20'] = true;
        break;

      case 'messageTemplate':
        /*
         * It's too early to set an $audience, knowing that we'll return here
         * later with context 'singleEmail'.
         */
        $audienceData = null;
        return $audienceData;
    }

    $audience = '';

    /*
     * If applicable, try $audience rule 1.a:
     * Inspect the Audience of the Drupal CiviCRM Event
     * For a Scheduled Reminder sent to a Participant
     */
    if (empty($audience) && isset($audienceRule['1.a'])) {
      $entityType = $params['entity'] ?? '';
      $entityId = $params['entity_id'] ?? '';
      if ($entityType == 'action_schedule' && $entityId) {
        try {
          $actionSchedules = \Civi\Api4\ActionSchedule::get(FALSE)
          ->addSelect('entity_value')
          ->addWhere('id', '=', $entityId)
          ->addWhere('mapping_id', '=', 3) // Event
          ->setLimit(1)
          ->execute();
          foreach ($actionSchedules as $actionSchedule) {
            $events = entity_load('civicrm_event', $actionSchedule['entity_value']);
            foreach ($events as $event) {
              $audienceTerm = field_get_items('civicrm_event', $event, 'taxonomy_vocabulary_3');
              $tid = $audienceTerm[0]['tid'] ?? '';
              switch ($tid) {
                case '47':
                  $audience = 'christian';
                  break;
                case '48':
                  $audience = 'general';
                  break;
              }
              $audienceData['cache']['event'] = $event->id;
            }
          }
        } catch (\API_Exception $e) {
          ;
        }
      }
    }

    /*
     * If applicable, try $audience rule 2.a:
     * For a Send Email action use Activity > Campaign > Audience
     */
    if (empty($audience) && isset($audienceRule['2.a'])) {
      if (!empty($params['campaign_id'])) {
        $audienceRule['2'] = [
          'key' => 'campaign_type_id.name',
          'entity' => 'Campaign',
          'id' => $params['campaign_id'],
        ];
      }
      else if (!empty($params['activityId'])) {
        $audienceRule['2'] = [
          'key' => 'campaign_id.campaign_type_id.name',
          'entity' => 'Activity',
          'id' => $params['activityId'],
        ];
      }
    }

    /*
     * If applicable, try $audience rule 2.b:
     * For a CiviMail use MailingJob > Mailing > Campaign > Audience
     */
    if (empty($audience) && isset($audienceRule['2.b'])) {
      if (!empty($params['campaign_id'])) {
        $audienceRule['2'] = [
          'key' => 'campaign_type_id.name',
          'entity' => 'Campaign',
          'id' => $params['campaign_id'],
        ];
      }
      else if (!empty($params['mailingID'])) {
        $audienceRule['2'] = [
          'key' => 'campaign_id.campaign_type_id.name',
          'entity' => 'Mailing',
          'id' => $params['mailingID'],
        ];
      }
      else if (!empty($params['job_id'])) {
        $audienceRule['2'] = [
          'key' => 'mailing_id.campaign_id.campaign_type_id.name',
          'entity' => 'MailingJob',
          'id' => $params['job_id'],
        ];
      }
    }

    /*
     * If applicable, try $audience rule 2.c:
     * For a Scheduled Reminder use Event > Campaign > Audience
     */
    if (empty($audience) && isset($audienceRule['2.c'])) {
      if (!empty($audienceData['cache']['event'])) {
        $audienceRule['2'] = [
          'key' => 'campaign_id.campaign_type_id.name',
          'entity' => 'Event',
          'id' => $audienceData['cache']['event'],
        ];
      }
    }

    /*
     * If applicable, try $audience rule 2:
     * Inspect the Campaign associated with the email for an Audience
     */
    if (empty($audience) && isset($audienceRule['2'])) {
      try {
        $result = civicrm_api3($audienceRule['2']['entity'], 'get', [
          'sequential' => 1,
          'return' => [ $audienceRule['2']['key'] ],
          'id' => $audienceRule['2']['id'],
        ]);
        $campaignType = $result['values'][0][$audienceRule['2']['key']] ?? '';
        switch ($campaignType) {
          case 'Mobilising':
          case 'Equipping':
          case 'Fundraising':
            $audience = 'christian';
            break;
          case 'Engaging':
          case 'Forum or fellowship':
          case 'Relationship building':
            $audience = 'general';
            break;
        }
      } catch (CiviCRM_API3_Exception $e) {
        ;
      }
    }

    /*
     * If applicable, try $audience rule 20:
     * Inspect the email for HREF links that select an Audience
     */
    if (empty($audience) && isset($audienceRule['20'])) {
      $audienceMatches = [];
      foreach ($audienceData['audiences'] as $a => $data) {
        $audienceMatches[$a] = preg_match($data['patterns']['20'], $params['html']);
      }

      foreach ($audienceMatches as $a => $match) {
        if ($match == 1) {
          if (empty($audience)) {
            $audience = $a;
          }
          else {
            $audience = '';
            break; // Multiple audiences means this test is inconclusive
          }
        }
      }
    }

    /*
     * If applicable, try $audience rule 30:
     * Inspect the current domain to see if that selects an Audience
     */
    if (empty($audience) && isset($audienceRule['30'])) {
      $audienceMatches = [];
      foreach ($audienceData['audiences'] as $a => $data) {
        $audienceMatches[$a] = preg_match($data['patterns']['30'], $_SERVER['HTTP_HOST']);
      }

      foreach ($audienceMatches as $a => $match) {
        if ($match == 1) {
          if (empty($audience)) {
            $audience = $a;
          }
          else {
            $audience = '';
            break; // Multiple audiences means this test is inconclusive
          }
        }
      }
    }

    /*
     * If applicable, try $audience rule 99:
     * If $audience is not set, set it to 'general'
     */
    if (empty($audience)) {
      $audience = 'general';
    }

    $audienceData['audience'] = $audience;
  }

  return $audienceData;
}

/*
 * This function amends an email's text to suit the $audience
 */
function _cbf_civicrm_amend_email(&$html, &$text, $audienceData) {
  /*
   * If $html is empty then do nothing. This protects against the case that
   * we are processing an SMS.
   *  - We can't set the Campaign for a Bulk SMS so the Audience data is
   *    unreliable.
   *  - We have modified CRM_SMS_Provider::getMessage() to behave as if the
   *    HTML part is empty.
   */
  if (empty($html)) {
    return;
  }

  /*
   * Convert relative URLs to absolute
   * Convert old-style email PNG to $audience
   * Convert old-style white email PNG to $audience
   * Convert old-style social links to $audience (also apply to $text)
   * Convert other audience's links to $audience links (html and text)
   * Ensure $audience links are well-formed (html and text)
   * Convert other audience's colours to $audience colours
   * Remove empty paragraphs inserted by CKeditor
   * Remove non-breaking spaces inserted by CKeditor
   * Convert IMG class attribute-width-NNN to a width attribute
   *
   * attribute-width-NNN:
   * The CKeditor Image Dialog removes width attributes from HTML IMGs. This causes
   * an issue for responsive email templates when the email is viewed in Outlook.
   * This is resolved by adding a class 'attribute-width-NNN' to the IMG element in
   * the message template. The NNN is converted into a width="NNN" attribute that
   * is added to the IMG. The 'attribute-width-NNN' class is otherwise ignored.
   * There is a risk that the IMG ends up with 2 width attributes, but these should
   * have the same value.
   */
  $audience = $audienceData['audience'];
  $host = $audienceData['audiences'][$audience]['host'];
  $colour = $audienceData['audiences'][$audience]['colour'];
  $replacements = [
    [
      'comment' => 'Convert relative URLs to absolute',
      'from' => '! (href|src)="(/[^/])!i',
      'to' => ' $1="' . $host . '$2',
      'html' => true,
      'text' => false,
    ],
    [
      'comment' => "Convert old-style email PNG to $audience",
      'from' => '!/themes/cbf2019/logo-email.png!i',
      'to' => "/themes/cbf2019/images/$audience/brand/logo-email.png",
      'html' => true,
      'text' => false,
    ],
    [
      'comment' => "Convert old-style white email PNG to $audience",
      'from' => '!/themes/cbf2019/logo-white-email.png!i',
      'to' => "/themes/cbf2019/images/$audience/brand/logo-white-email.png",
      'html' => true,
      'text' => false,
    ],
    [
      'comment' => "Convert old-style Facebook links to $audience",
      'from' => '!https://www\.facebook\.com/CityBibleForum!i',
      'to' => "$host/domain/$audience/facebook",
      'html' => true,
      'text' => true,
    ],
    [
      'comment' => "Convert old-style LinkedIn links to $audience",
      'from' => '!https://www\.linkedin\.com/company/city-bible-forum!i',
      'to' => "$host/domain/$audience/linkedin",
      'html' => true,
      'text' => true,
    ],
    [
      'comment' => "Convert old-style Youtube links to $audience",
      'from' => '!https://www\.youtube\.com/channel/UCt1YTYKDW8f5s5q9McoHJ_Q!i',
      'to' => "$host/domain/$audience/youtube",
      'html' => true,
      'text' => true,
    ],
    [
      'comment' => 'Remove empty paragraphs inserted by CKeditor',
      'from' => '!<p>(\r\n\t)*&nbsp;</p>!i',
      'to' => '',
      'html' => true,
      'text' => false,
    ],
    [
      'comment' => 'Replace non-breaking spaces inserted by CKeditor with spaces',
      'from' => '!&nbsp;!i',
      'to' => ' ',
      'html' => true,
      'text' => false,
    ],
    [
      'comment' => 'Convert IMG class attribute-width-NNN to a width attribute',
      'from' => '!<img ([^>]+)attribute-width-([0-9]+)([^>]+)/>!i',
      'to' => '<img width="$2" $1attribute-width-processed$3/>',
      'html' => true,
      'text' => false,
    ],
  ];
  foreach ($audienceData['audiences'] as $a => $data) {
    /*
     * When $audience is 'christian' we want to preserve the 'general'
     * references. In all other cases we want to change the references.
     *
     * Note that when $a == $audience what we're doing is ensuring the
     * $audience links are well-formed (explicitly HTTPS).
     */
    if ($audience != 'christian' || $a != 'general') {
      $replacements[] = [
        'comment' => "Convert HTML $a references to $audience links",
        'from' => $data['patterns']['html'],
        'to' => ' $1=$2' . $host . '$6',
        'html' => true,
        'text' => false,
      ];
      $replacements[] = [
        'comment' => "Convert text $a references to $audience links",
        'from' => $data['patterns']['text'],
        'to' => '$1' . $host . '$5',
        'html' => false,
        'text' => true,
      ];
    }
    if ($a != $audience) {
      $replacements[] = [
        'comment' => "Convert $a colours to $audience colours",
        'from' => $data['patterns']['colour'],
        'to' => '$1' . $colour . '$2',
        'html' => true,
        'text' => false,
      ];
    }
  }
  foreach ($replacements as $r) {
    if ($r['html']) {
      $html = preg_replace($r['from'], $r['to'], $html) ?? $html;
    }
    if ($r['text']) {
      $text = preg_replace($r['from'], $r['to'], $text) ?? $text;
    }
  }
}

/*
 * This hook is called after getting the content of the mail and before tokenizing it.
 *
 * It is called once before sending an email, but can be called multiple times.
 */
function cbf_civicrm_civicrm_alterMailContent(&$content) {
  $audienceData = _cbf_civicrm_email_audience($content, null);
  if ($audienceData) {
    _cbf_civicrm_amend_email($content['html'], $content['text'], $audienceData);
  }
}

/*
 *  This hook is called when an email is about to be sent by CiviCRM.
 *  It ensures the email contains no relative links.
 *  It adds the closing tags for the BODY and HTML elements, as these are
 *  left off so CiviMail can add a tracking token to the email.
 */
function cbf_civicrm_civicrm_alterMailParams( &$params, $context = null ) {

  $workflow = $params['workflow'] ?? $params['valueName'] ?? $params['groupName'] ?? '';

  // Don't send event confirmations when a Pending attendee is marked as Attended after the event
  $now = date('Y-m-d G:i:s');
  if ($workflow == 'event_online_receipt'
      && isset($params['tplParams']['participant_status']) && $params['tplParams']['participant_status'] == 'Attended'
      && isset($params['tplParams']['event']['is_pay_later']) && $params['tplParams']['event']['is_pay_later'] == 1
      && isset($params['tplParams']['event']['end_date']) && $params['tplParams']['event']['end_date'] < $now) {
    $params['abortMailSend'] = 1;
    return;
  }

  /*
   * "Note that this hook is called twice when sending a message template,
   *  once early in the message generation (before tokens are applied, with
   *  the context 'messageTemplate') and then later from CRM_Utils_Mail::send()
   *  with the context 'singleEmail'"
   *
   *    - https://docs.civicrm.org/dev/en/latest/hooks/hook_civicrm_alterMailParams/
   */
  if ($context == 'messageTemplate') {
    return; // Wait until next invocation
  }

  $audienceData = _cbf_civicrm_email_audience($params, $context);
  $audience = $audienceData['audience'];

  /*
   * Update the From, Return-Path and Reply-To headers to match the audience.
   *
   * Do the From header before the others so we have a default value
   * The From and Reply-To headers have a name and an address part.
   * The Return-Path header only has the address part.
   * Skip protected address patterns
   *  - message@citybibleforum.org
   *     - can't use message@thirdspace.org.au as we have a conflict
   *        - if m@ts is alias of m@cbf how do we "send as" m@ts?
   *        - if m@ts is a seperate a/c how do we handle bounces as CiviCRM only
   *          expects a single IMAP folder (ie Mail Account)
   */
  $headerData = [
    'headers' => [
      'From' => [
        'parameter' => [
          'civimail' => 'From',
          'singleEmail' => 'from',
        ],
        'parts' => [
          'email name' => 'name',
          'email domain' => 'email domain',
        ],
        'default' => '',
      ],
      'Return-Path' => [
        'parameter' => [
          'civimail' => 'Return-Path',
          'singleEmail' => 'returnPath',
        ],
        'parts' => [
          'email domain' => 'email domain',
        ],
        'default' => '!^.*<(.*)>$!i',
      ],
      'Reply-To' => [
        'parameter' => [
          'civimail' => 'Reply-To',
          'singleEmail' => 'replyTo',
        ],
        'parts' => [
          'email name' => 'name',
          'email domain' => 'email domain',
        ],
        'default' => '!^(.*)$!i',
      ],
    ],
    'protected' => [
      'patterns' => [
        'CiviMail sending account' => '!message(\+[.a-z0-9]+)@citybibleforum\.org!i',
      ],
    ],
  ];

  foreach ($headerData['headers'] as $_ => $header) {
    $name = $header['parameter'][$context] ?? '';
    if ($name) {
      $address = $params[$name] ?? '';
      if ($address) {
        foreach ($headerData['protected']['patterns'] as $pattern) {
          if (preg_match($pattern, $address)) {
            continue 2; // This $address is protected: skip to the next $header
          }
        }
        foreach ($header['parts'] as $pattern => $replacement) {
          foreach ($audienceData['audiences'] as $a => $data) {
            if ($a != $audience) {
              $address = preg_replace(
                $data['patterns'][$pattern],
                '$1' . $audienceData['audiences'][$audience][$replacement] . '$3',
                $address) ?? $address;
            }
          }
        }
        $params[$name] = $address;
      }
      else if ($header['default']) { // Default to From if not supplied
        $params[$name] = preg_replace(
          $header['default'],
          '$1',
          $params[$headerData['headers']['From']['parameter'][$context]]);
      }
    }
  }

  /*
   * Update the To header to use the Staff email.
   *
   * An example of this is the Staff Contact form which sends a case_activity
   * singleEmail to the staff member addressed by the form.
   */
  if ($context == 'singleEmail' && $workflow == 'case_activity' && $params['contactId']) {
    $email = \Civi\Api4\Email::get()
      ->addWhere('contact_id', '=', $params['contactId'])
      ->addWhere('location_type_id:name', '=', 'Staff')
      ->setLimit(1)
      ->setCheckPermissions(FALSE)
      ->execute()
      ->first();
    if ($email) {
      $params['toEmail'] = $email['email'];
    }
  }

  _cbf_civicrm_amend_email($params['html'], $params['text'], $audienceData);

  $htmlMessage = $params['html'];
  if ( $htmlMessage ) {
    /*
     * Look for the closing tag for the BODY element, and add it if needed
     * Can't do this in _cbf_civicrm_amend_email() because the tracking
     * image is not added until after cbf_civicrm_civicrm_alterMailContent()
     * is called.
     */
    if (
      stripos($htmlMessage, '<body>') !== false &&
      stripos($htmlMessage, '</body>') === false
    ) {
      $htmlMessage .= '</body></html>';
    }

    /*
     * Ensure the email has a Title in its title-field, and that if on-line
     * receipts have a title of 'Contribution' give them something better
     */
    if (isset($params['subject'])) {
      if (isset($params['tplParams'])) {
        if (!isset($params['tplParams']['title'])) {
          $htmlMessage = preg_replace('!class="title-field">  </p>!i', 'class="title-field"> ' . $params['subject'] . ' </p>', $htmlMessage);
        } elseif ($params['tplParams']['title'] == 'Contribution' && $workflow == 'contribution_online_receipt') {
          $htmlMessage = preg_replace('!class="title-field"> Contribution </p>!i', 'class="title-field"> ' . $params['subject'] . ' </p>', $htmlMessage);
        }
      }
    }

    /*
     * Replace the '<tax-invoice/>' HTML element with the Tax Invoice text.
     * This is usually empty, except for event registrations and contributions
     * for Event Fees and Sales which have a non-zero value.
     */
    $taxInvoice = '<tr><td>This email serves as a Tax Invoice. Amounts quoted include GST.</td></tr>';
    $isTaxInvoice = false;
    switch ($workflow) {
      case 'contribution_offline_receipt':
      case 'contribution_online_receipt':
        if (isset($params['tplParams']['contributionTypeName'])) {
          $financialType = $params['tplParams']['contributionTypeName'];
          $nonZero = !empty($params['tplParams']['amount']);
        }
        else {
          try {
            $contribution = civicrm_api3('Contribution', 'get', array(
              'sequential' => 1,
              'id' => $params['contributionId'],
            ));
            $financialType = $contribution['values'][0]['financial_type'];
            $nonZero = !empty(floatval($contribution['values'][0]['total_amount']));
          } catch (CiviCRM_API3_Exception $e) {
            $financialType = '';
            $nonZero = false;
          }
        }
        switch ($financialType) {
          case 'Event Fee':
          case 'Sales':
            $isTaxInvoice = $nonZero;
            break;
        }
        break;

      case 'event_offline_receipt':
      case 'event_online_receipt':
        if (isset($params['tplParams']['amount'])) {
          $isTaxInvoice = !empty($params['tplParams']['amount']);
        }
        elseif (isset($params['tplParams']['fee'])) {
          $isTaxInvoice = !empty($params['tplParams']['fee']);
        }
        else {
          $isTaxInvoice = true;
        }
        break;
    }
    $htmlMessage = preg_replace('!<tax-invoice/>!i', $isTaxInvoice ? $taxInvoice : '', $htmlMessage);

    /*
     * There are occasions when CiviCRM uses an online contribution receipt for
     * offline purposes. For example, when a recurring contribution is made
     * offline the eWAY processor will use the online receipt template for all
     * contributions except the first.
     *
     * Since the contribution was not made through a contribution page, certain
     * items won't appear on the receipt. The HTML for these needs to be generated.
     */
    switch ($workflow) {
      case 'contribution_online_receipt':
        if (stripos($htmlMessage, '<no-contribution-page/>') !== false) {
          $noContributionPage = _cbf_civicrm_civicrm_no_contribution_page($params);
          $htmlMessage = preg_replace('!<no-contribution-page/>!i', $noContributionPage, $htmlMessage);
        }
        break;
    }

    /*
     * When sending a single email, remove the 'civimailBlock' from the HTML part.
     * This allows email templates to be used for CiviMails and for sending emails.
     */
    if ($context == 'singleEmail') {
      $htmlMessage = preg_replace('#<!-- civimailBlock -->.*<!-- /civimailBlock -->#is', '', $htmlMessage);
    }

    /*
     * When sending a Contribution confirmation for a Thinkific registration
     * replace 'THINKIFIC_EMAIL' with the email address. This will personalise
     * the user's Express Sign On link.
     */
    switch ($workflow) {
      case 'contribution_offline_receipt':
      case 'contribution_online_receipt':
        $htmlMessage = preg_replace('#THINKIFIC_EMAIL#', $params['toEmail'], $htmlMessage) ?? $htmlMessage;
        if (isset($params['text'])) {
          $params['text'] = preg_replace('#THINKIFIC_EMAIL#', $params['toEmail'], $params['text']) ?? $params['text'];
        }
        break;
    }

    /*
     * When sending a Scheduled Reminder to a Zoom registrant, replace
     * 'ZOOM_PARTICIPANT_JOIN_LINK' with the link provided by Zoom. Note that
     * the Event Id will have been cached in this case.
     */
    if ($workflow == 'Scheduled Reminder Sender') {
      $needle = 'ZOOM_PARTICIPANT_JOIN_LINK';
      $select = 'zoom_data_sync.Zoom_Participant_Join_Link';
      $contactId = $params['contactId'] ?? '';
      $eventId = $audienceData['cache']['event'] ?? '';
      if ($contactId && $eventId && strpos($htmlMessage, $needle) !== false) {
        try {
          $participants = \Civi\Api4\Participant::get(false)
          ->addSelect($select)
          ->addWhere('contact_id', '=', $contactId)
          ->addWhere('event_id', '=', $eventId)
          ->addOrderBy('id', 'DESC') // Assume more recent regos are better
          ->setLimit(25)
          ->execute();
          foreach ($participants as $participant) {
            if ($participant[$select]) {
              $htmlMessage = preg_replace("#$needle#", $participant[$select], $htmlMessage) ?? $htmlMessage;
              if (isset($params['text'])) {
                $params['text'] = preg_replace("#$needle#", $participant[$select], $params['text']) ?? $params['text'];
              }
            }
            else {
              $params['abortMailSend'] = 1;
            }
            break; // Ignore any other participant records
          }
        } catch (\API_Exception $e) {
          ;
        }
      }
      CRM_Core_Error::debug_var(
        'Scheduled Reminder Sender',
        [
          'contact' => $contactId,
          'event' => $eventId,
          'participant' => $participant['id'] ?? 'not set',
          'zoom link' => $participant[$select] ?? 'not set',
        ]
      );
    }

    $params['html'] = $htmlMessage;
  }
}

/*
 * Generate the HTML for receipts where the payment was created offline but
 * uses an online receipt template.
 *
 * The custom field logic is copied from CRM_Contribute_Form_AdditionalInfo::emailReceipt()
 * and the logic for the other items from the contribution_online_receipt
 * template.
 */
function _cbf_civicrm_civicrm_no_contribution_page($params) {
  $headerFormat = '"text-align: left; padding: 4px; border-bottom: 1px solid #999; background-color: #eee;"';
  $labelFormat = '"padding: 4px; border-bottom: 1px solid #999; background-color: #f7f7f7;"';
  $dataFormat = '"padding: 4px; border-bottom: 1px solid #999;"';
  $result = '';

  try {
    $contribution = civicrm_api3('Contribution', 'get', array(
      'sequential' => 1,
      'id' => $params['tplParams']['contributionID'],
    ));
    if ($contribution['is_error'] || $contribution['count'] != 1) {
      return $result;
    }
    $contributionInfo = array(
      'Financial Type' => $contribution['values'][0]['financial_type'],
      'Receipt Date' => $contribution['values'][0]['receipt_date'],
      'Paid By' => $contribution['values'][0]['payment_instrument'],
    );
    if (!empty($contributionInfo['Receipt Date'])) {
      $config = CRM_Core_Config::singleton();
      $contributionInfo['Receipt Date'] = CRM_Utils_Date::customFormat($contributionInfo['Receipt Date'], $config->dateformatFull);
    }
    foreach ($contributionInfo as $label => $data) {
      if (!empty($data)) {
        $result .= "<tr><td style=$labelFormat>$label</td><td style=$dataFormat>$data</td></tr>";
      }
    }

    $customGroups = array();
    $groupTree = CRM_Core_BAO_CustomGroup::getTree('Contribution', null);
    foreach ($groupTree as $groupID => $group) {
      if ($groupID == 'info' || empty($group['is_public'])) {
        continue;
      }
      $customGroups[$group['title']] = array();
      $nonEmpty = 0;
      foreach ($group['fields'] as $k => $field) {
        if (!empty($contribution['values'][0]["custom_{$k}"])) {
          if ($k == 26) {
            $ministry_centre = civicrm_api3('OptionValue', 'getvalue', array(
              'sequential' => 1,
              'option_group_id' => 329,
              'value' => $contribution['values'][0]["custom_{$k}"],
              'return' => 'label',
            ));
            $customGroups[$group['title']][$field['label']] = $ministry_centre;
          } else {
            $customGroups[$group['title']][$field['label']] = $contribution['values'][0]["custom_{$k}"];
          }
          $nonEmpty++;
        } else {
          $customGroups[$group['title']][$field['label']] = '';
        }
      }
      if ($nonEmpty == 0) {
        unset($customGroups[$group['title']]);
      }
    }
    foreach ($customGroups as $groupTitle => $group) {
      $result .= "<tr><th colspan=\"2\" style=$headerFormat>$groupTitle</th></tr>";
      foreach ($group as $label => $data) {
        $result .= "<tr><td style=$labelFormat>$label</td><td style=$dataFormat>$data</td></tr>";
      }
    }
  } catch (Exception $e) {
    ;
  }
  return $result;
}

/*
 * This hook is called when a form is being built by CiviCRM.
 * It adds the Credit Card Holder to credit card payment forms, and makes the holder
 * field available on confirmation and thank-you pages. This doesn't work for the
 * event forms since they protect their _param variables.
 * It makes the Billing Name and Address not-required, as these are not presented
 * on CBF payment forms.
 */
function cbf_civicrm_civicrm_buildForm( $formName, &$form ) {
  _cbf_civicrm_current_form($formName);

  /*
   * End users are getting confused when they enter email addresses with an additional space
   * To avoid this we trim submitted email addresses
   * Also trim other text fields: First Name, Last Name, and Phone fields
   */
  switch ($formName) {
    case 'CRM_Contribute_Form_Contribution': // Offline contribution
    case 'CRM_Contribute_Form_Contribution_Main': // Online contribution
    case 'CRM_Event_Form_Participant': // Offline event registration
    case 'CRM_Event_Form_Registration_Register': // Online event registration
    case 'CRM_Profile_Form_Edit': // Sign up to list etc
      $fieldPatterns = [
        'first_name',
        'last_name',
        'email-',
        'phone-',
      ];
      foreach ($form->getSubmitValues() as $field => $_) {
        if (
          $form->elementExists($field) &&
          $form->getElement($field) instanceof HTML_QuickForm_text
        ) {
          foreach ($fieldPatterns as $fieldPattern) {
            if (strpos($field, $fieldPattern) !== false) {
              $form->applyFilter($field, 'trim');
              break;
            }
          }
        }
      }
  }

  switch ($formName) {

    case 'CRM_Contribute_Form_Contribution': // Offline contribution
    case 'CRM_Contribute_Form_Contribution_Main': // Online contribution
    case 'CRM_Event_Form_Participant': // Offline event registration
    case 'CRM_Event_Form_Registration_Register': // Online event registration
    case 'CRM_Financial_Form_Payment': // Invoked when changing payment processors etc
      /*
       * Keep a count of anonymous users' credit card issues in their session
       */
      $cardIssueDetected = false;
      if (user_is_anonymous()) {
        $status_text = $_SESSION['CiviCRM']['status'][0]['text'] ?? '';
        if (!empty($status_text)) {
          CRM_Core_Error::debug_var(
            'CiviCRM status',
            [
              'CiviCRM status text' => $status_text,
              'ip' => ip_address(),
            ]
          );
          if (preg_match('#Error: \[((0[1-9])|([1-9][0-9]))\]#i', $status_text) == 1) {
            $cardIssueDetected = true;
            if (isset($_SESSION['City Bible Forum']['Card issues'])) {
              $_SESSION['City Bible Forum']['Card issues']++;
            } else {
              $_SESSION['City Bible Forum']['Card issues'] = 1;
            }
            CRM_Core_Error::debug_var(
              'Credit card issues',
              $_SESSION['City Bible Forum']['Card issues']);
          }
        }
      }

      /*
       * If a user has more than $CardIssuesWarning credit card issues in a
       * session, log it.
       *
       * If more than $CardIssuesError send them to a dead end, assuming
       * they're trying to crack a card.
       *
       * 2021-03-31 Set $CardIssuesWarning to zero as this solution failed when
       *            the attacker used a new session each time (value was 2)
       */
      $CardIssuesWarning = 0;
      $CardIssuesError = 6;
      if (isset($_SESSION['City Bible Forum']['Card issues'])) {
        if ($_SESSION['City Bible Forum']['Card issues'] > $CardIssuesWarning) {
          if ($cardIssueDetected) {
            CRM_Core_Error::debug_log_message('|CiviCRM guard|Credit card issue|anonymous|' . ip_address());
          }
          if ($_SESSION['City Bible Forum']['Card issues'] > $CardIssuesError) {
            CRM_Utils_System::redirect(CRM_Utils_System::url('full-stop.html'));
          }
        }
      }

      /*
       * If more than N Contributions have failed in the last period, then
       * add a reCAPTCHA to the form
       */
      $contributionFailureThreshold = 0;
      $contributionFailurePeriod = '1 hour ago';
      if (user_is_anonymous()) {
        try {
          $dateTime = new DateObject($contributionFailurePeriod);
          $contributionFailureTime = $dateTime->format('Y-m-d H:i:s', true);
          $result = civicrm_api3('Contribution', 'get', [
            'sequential' => 1,
            'receive_date' => ['>=' => $contributionFailureTime],
            'contribution_status_id' => 'Failed',
            'payment_instrument_id' => 'Credit Card',
          ]);
          $addCaptcha = ($result['count'] > $contributionFailureThreshold || $result['is_error']);
        } catch (CiviCRM_API3_Exception $e) {
          $addCaptcha = true;
        }

        if ($addCaptcha) {
          CRM_Utils_ReCAPTCHA::enableCaptchaOnForm($form);
        }

        CRM_Core_Error::debug_var(
          'Test for failed credit card payments',
          [
            'reCAPTCHA Threshold' => $contributionFailureThreshold,
            'reCAPTCHA Period' => $contributionFailurePeriod,
            'Time at start of reCAPTCHA period' => $contributionFailureTime,
            'reCAPTCHA failed credit card payments' => $result['count'] ?? 'unknown',
            'reCAPTCHA Error getting failed payments' => $result['is_error'] ?? 'yes',
            'Add reCAPTCHA' => $addCaptcha,
            'reCAPTCHA ip' => ip_address(),
          ]
        );
      }

      // Add a form element for the credit card holder
      // It is required if the credit card number is required
      if ($form->elementExists('credit_card_number') && !$form->elementExists('credit_card_holder')) {
        $form->add (
          'text',
          'credit_card_holder',
          ts('Card Holder'),
          array (
            'size' => 20,
            'maxlength' => 30,
            'autocomplete' => 'off' ),
          $form->isElementRequired('credit_card_number'),
          null);
      }

      // Assume the person's first and last name are being captured via a profile
      // Make the address optional so donors have less data to supply
      if (isset($form->_bltID)) {
        $bltID = $form->_bltID;
        $unnecessaryFields = array(
          "billing_first_name",
          "billing_last_name",
          "billing_street_address-{$bltID}",
          "billing_city-{$bltID}",
          "billing_postal_code-{$bltID}",
          "billing_state_province_id-{$bltID}",
          "billing_country_id-{$bltID}"
        );
        $form->_required = array_diff($form->_required, $unnecessaryFields);
        foreach ($unnecessaryFields as $field) {
          if ( isset($form->_paymentFields[$field]) ) {
            $form->_paymentFields[$field]['is_required'] = false;
          }
        }
      }

      if ($formName == 'CRM_Contribute_Form_Contribution_Main' && $form->elementExists('buttons') ) {
        $buttons = $form->getElement('buttons');
        $submit = $buttons->getElements();
        $submit[0]->setContent('<i class="crm-i fa-chevron-right" aria-hidden="true"></i> Next');
      }

      /*
       * Prevent the user from editing their name, email or phone during
       * online donations or registrations, in the case when the form has
       * defaults for these.
       */
      switch ($formName) {
        case 'CRM_Contribute_Form_Contribution_Main': // Online contribution
        case 'CRM_Event_Form_Registration_Register': // Online event registration
          $protect = array(
            'first_name',
            'last_name',
            'email-5',    // Billing email, donation form
            'email-6',    // Primary email, registration form
            'phone-6-2',  // Primary mobile, registration form
          );
          foreach ($protect as $i) {
            if ($form->elementExists($i) && !empty($form->_defaultValues[$i])) {
              $form->getElement($i)->freeze();
            }
          }
          break;
      }

      break;

    case 'CRM_Contribute_Form_Contribution_Confirm':
    case 'CRM_Contribute_Form_Contribution_ThankYou':
    case 'CRM_Event_Form_Registration_Confirm':
    case 'CRM_Event_Form_Registration_ThankYou':
      /*
       * Set the Credit Card Holder in the Smarty template
       * Clear the Address in the Smarty template
       */
      $tpl = $form->getTemplate();
      $tpl_credit_card_number = $tpl->get_template_vars('credit_card_number');
      if ( isset($tpl_credit_card_number) ) {
        if ( isset($form->_params['credit_card_holder']) ) {
          $form->assign( 'credit_card_holder', $form->_params['credit_card_holder'] );
        }
        else if (isset($form->_params[0]) && isset($form->_params[0]['credit_card_holder'])) {
          $form->assign( 'credit_card_holder', $form->_params[0]['credit_card_holder'] );
        }
      }
      $form->assign( 'address', '' );

      if ($formName == 'CRM_Contribute_Form_Contribution_Confirm' && $form->elementExists('buttons') && $form->_amount) {
        $makePaymentLabel = 'Make payment';

        $buttons = $form->getElement('buttons');
        $submit = $buttons->getElements();
        $submit[0]->setContent($makePaymentLabel);
      }

      /*
       * Add participants who elect for future communications to the
       * appropriate list
       */
      if ($formName == 'CRM_Event_Form_Registration_ThankYou') {
        if (isset($form->_params[0]['custom_28']) && $form->_params[0]['custom_28'] == 1) {
          _cbf_civicrm_civicrm_add_to_list_via_entity(
            $form->_values['participant']['contact_id'],
            'civicrm_event',
            $form->_values['participant']['event_id'],
            45); // 'Events like this' list
        }
        if (isset($form->_params[0]['custom_29']) && $form->_params[0]['custom_29'] == 1) {
          _cbf_civicrm_civicrm_add_to_list_via_entity(
            $form->_values['participant']['contact_id'],
            'civicrm_event',
            $form->_values['participant']['event_id'],
            46); // 'News and updates' list
        }
      }

      /*
       * If making a Contribution for a Thinkific course, then enrol the user in the course
       */
      if ($formName == 'CRM_Contribute_Form_Contribution_ThankYou') {
        $thinkificCourses = [
          10 => null, // Contribution page was used in testing
          15 => [     // Sharing Jesus at Work
            'free' => [
              'course' => 1150926,
              'expiry' => '1 month',
            ],
            'paid' => [
              'course' => 871216,
              'expiry' => '6 months',
            ],
          ],
          18 => [     // Sharing Jesus at Work - group license
            'course' => 871216,
            'expiry' => '6 months',
          ],
          20 => [     // I am what I do
            'free' => [
              'course' => 1383094,
              'expiry' => '1 month',
            ],
            'paid' => [
              'course' => 990121,
              'expiry' => '6 months',
            ],
          ],
          21 => [     // I am what I do - group license
            'course' => 990121,
            'expiry' => '6 months',
          ],
          22 => [     // Never more hostile, never more open
            'free' => [
              'course' => 1447564,
              'expiry' => '1 month',
            ],
            'paid' => [
              'course' => 857232,
              'expiry' => '6 months',
            ],
          ],
          23 => [     // Never more hostile, never more open - group license
            'course' => 857232,
            'expiry' => '6 months',
          ],
          24 => [     // The Post Covid Playbook
            'free' => [
              'course' => 1575723,
              'expiry' => '1 month',
            ],
            'paid' => [
              'course' => 1547489,
              'expiry' => '6 months',
            ],
          ],
          25 => [     // The Post Covid Playbook - group license
            'course' => 1547489,
            'expiry' => '6 months',
          ],
          26 => [     // Finding God in Film
            'course' => 27700079,
            'expiry' => '6 months',
          ],
          27 => [     // Finding God in Film - group license
            'course' => 27700079,
            'expiry' => '6 months',
          ],
        ];
        $thinkificCourse = $thinkificCourses[$form->_id] ?? null;
        if (isset($thinkificCourse)) {
          $bltID = $form->_bltID ?? 5;
          $enrolment = _cbf_civicrm_thinkific_enrolment(
            $form->_params['first_name'],
            $form->_params['last_name'],
            $form->_params["email-{$bltID}"],
            $_SESSION['CiviCRM']['transaction.userID'] ?? $form->_contactID,
            $thinkificCourse['course'] ?? (
              $form->_amount == 0
                ? $thinkificCourse['free']['course']
                : $thinkificCourse['paid']['course']),
            $thinkificCourse['expiry'] ?? (
              $form->_amount == 0
                ? $thinkificCourse['free']['expiry']
                : $thinkificCourse['paid']['expiry'])
          );
          foreach (['thankyou_text', 'thankyou_footer'] as $tplVar) {
            $form->assign(
              $tplVar,
              preg_replace(
                '#THINKIFIC_EMAIL#',
                $form->_params["email-{$bltID}"],
                $form->_values[$tplVar]
              )
            );
          }
          CRM_Core_Error::debug_var('Thinkific enrolment', implode('. ', $enrolment['progress']));
          watchdog(
            'CBF',
            'Thinkific enrolment: ' . implode('. ', $enrolment['progress']),
            null,
            $enrolment['status'] != 'Success' ? WATCHDOG_ERROR : WATCHDOG_INFO
          );
          if ($enrolment['status'] != 'Success') {
            drupal_set_message(
              'Unfortunately we will need to complete your enrolment manually. Please contact us to resolve this issue.',
              'error'
            );
          }
        }
      }
      break;

    case 'CRM_Mailing_Form_Upload':
      /*
       * For CiviMails, unset the From email address when the Subject is empty.
       * This is a roundabout way of unsetting the CiviMail default, to force
       * the user to enter an From address.
       */
      if ( $form->getElementValue('subject') == null ) {
        $fromAddress = $form->getElement('from_email_address');
        $fromAddress->setSelected(0);
      }
      break;
  }
}

/*
 * This function is called when a form is being validated by CiviCRM.
 * In cases where the Credit Card Holder field is not-required, it is mandatory if the
 * Credit Card Number has been entered.
 */
function cbf_civicrm_civicrm_validateForm( $formName, &$fields, &$files, &$form, &$errors ) {
  switch ($formName) {

    case 'CRM_Contribute_Form_Contribution':
    case 'CRM_Contribute_Form_Contribution_Main':
    case 'CRM_Event_Form_Participant':
    case 'CRM_Event_Form_Registration_Register':
      /*
       * The credit card holder is required for credit card transactions.
       * It should only contain alphanumeric characters, hyphens and spaces.
       * The 'required' test is only required if the Card Holder field
       * exists and is not marked as a required field.
       */
      if ($form->elementExists('credit_card_holder')) {
        $credit_card_holder = CRM_Utils_Array::value('credit_card_holder', $fields);
        if ($credit_card_holder) {
          if (preg_match('/[^a-z0-9-\s]/i', $credit_card_holder)) {
            $errors['credit_card_holder'] = ts('Card Holder must only be letters and spaces');
          }
        }
        else if (!$form->isElementRequired('credit_card_holder')) {
          $credit_card_number = CRM_Utils_Array::value('credit_card_number', $fields);
          if ($credit_card_number) {
            $errors['credit_card_holder'] = ts('Card Holder is required if Card Number is supplied');
          }
        }
      }

      /*
       * Online event registrations:
       *
       * Prevent visitors mistakenly entering the cost of a Price Set field,
       * rather than the number of participants. We do this by putting a
       * limit on the number that can be selected.
       * 
       * Also, prevent visitors trying to register without selecting any
       * options from a Price Set.
       */
      if ($formName == 'CRM_Event_Form_Registration_Register') {
        if (!empty($form->_priceSetId)) {
          $registrationLimit = 20;
          $optionSelected = false;
          $publicField = false;
          foreach ($form->_priceSet['fields'] as $priceSetFieldId => $priceSetField) {
            $submit = "price_$priceSetFieldId";
            if (!empty($form->_submitValues[$submit])) {
              $optionSelected = true;
              $participantCount = current($priceSetField['options'])['count'];
              if (
                !empty($priceSetField['is_display_amounts']) &&
                !empty($priceSetField['is_enter_qty']) &&
                !empty($participantCount) &&
                $form->_submitValues[$submit] > $registrationLimit
              ) {
                $errors[$submit] = ts('To protect our visitors, registrations are limited to ') . $registrationLimit . ts('. To register more, either make a separate registration or contact our office.');
              }
            }
            if ($publicField === false && $priceSetField['visibility'] == 'public') {
              $publicField = $submit;
            }
          }
          if ($optionSelected === false) {
            $errors[($publicField === false) ? $submit : $publicField] = ts('No registration options appear to have been selected');
          }
        }
      }
      break;

    case 'CRM_Contact_Import_Form_DataSource':
      // The dedupe rule is needed, except when 'No Duplicate Checking' is selected
      $onDuplicate = CRM_Utils_Array::value( 'onDuplicate', $fields );
      foreach ($form->getElement('onDuplicate')->getElements() as $duplicateOption ) {
        if ($duplicateOption->getValue() == $onDuplicate) {
          break; // We've found the option that's been selected
        }
      }
      if ($duplicateOption->getText() <> 'No Duplicate Checking') {
        if (CRM_Utils_Array::value( 'dedupe', $fields ) == '') {
          $errors['dedupe'] = ts('Dedupe rule must be set, unless there is no duplicate checking');
        }
      }
      break;

    case 'CRM_Event_Form_ManageEvent_EventInfo':
      // Ensure the End date is set for Events that are not templates
      $isTemplate = CRM_Utils_Array::value('is_template', $fields);
      $start = CRM_Utils_Date::processDate(CRM_Utils_Array::value('start_date', $fields), CRM_Utils_Array::value('start_date_time', $fields));
      $end = CRM_Utils_Date::processDate(CRM_Utils_Array::value('end_date', $fields), CRM_Utils_Array::value('end_date_time', $fields));
      if (empty($isTemplate)) {
        if (empty($end)) {
          $errors['end_date'] = ts('End Date and Time are required fields');
        }
        elseif ($end <= $start) {
          $errors['end_date'] = ts('End date should be after Start date');
        }
      }
      break;

    case 'CRM_Event_Form_ManageEvent_Registration':
      // Do not allow the Register multiple participants flag to be set
      $isMultiple = CRM_Utils_Array::value('is_multiple_registrations', $fields);
      if (!empty($isMultiple)) {
        $errors['is_multiple_registrations'] = ts('This option is not allowed. It causes too many user errors who a) try to use Price Sets with this option and b) do not fix data quality issues after the event');
      }
      break;

    case 'CRM_Export_Form_Select':
      /*
       * Selecting the 'Export PRIMARY fields' option for many contacts will
       * create multi-Gb temporary files. Reject this option.
       */
      $exportOption = CRM_Utils_Array::value('exportOption', $fields);
      if ($exportOption == 1) {
        $errors['exportOption'] = ts('Exporting Primary fields on large numbers of contacts can crash the web server. Select the fields you want to export.');
      }
      break;
  }
}

/*
 * This function is called before CiviCRM passes payment details to a Payment Processor.
 */
function cbf_civicrm_civicrm_alterPaymentProcessorParams($paymentObj, &$rawParams, &$cookedParams) {
  /*
   * For the eWAY processor ...
   * If the contact names have not been captured then get them from the contact.
   * Capture the Credit Card Holder is captured.
   * Clear the Purchaser Address details, since the Billing Address is not captured.
   */
  if ($paymentObj instanceof CRM_Core_Payment_Ewayrecurring) {
    $is_recur = CRM_Utils_Array::value('is_recur', $rawParams);
    $credit_card_holder = CRM_Utils_Array::value('credit_card_holder', $rawParams);
    $first_name = null;
    $last_name = null;

    if (
      !empty(CRM_Utils_Array::value('contact_id', $rawParams))
      && (empty(CRM_Utils_Array::value('first_name', $rawParams))
          || empty(CRM_Utils_Array::value('last_name', $rawParams)))
    ) {
      try {
        $record = civicrm_api3('Contact', 'get', [
          'sequential' => 1,
          'return' => ['first_name', 'last_name'],
          'id' => CRM_Utils_Array::value('contact_id', $rawParams),
        ]);
        $first_name = $record['values'][0]['first_name'];
        $last_name = $record['values'][0]['last_name'];
      } catch (CiviCRM_API3_Exception $e) {
        ;
      }
    }

    if ($is_recur ?? false) {
      // Set credit card holder
      if ($credit_card_holder) {
        $cookedParams['man:CCNameOnCard'] = $credit_card_holder;
      }
      // Set name if needed
      if (empty($cookedParams['man:FirstName']) && !empty($first_name)) {
        $cookedParams['man:FirstName'] = $first_name;
      }
      if (empty($cookedParams['man:LastName']) && !empty($last_name)) {
        $cookedParams['man:LastName'] = $last_name;
      }
      // Set address
      $cookedParams['man:Address']  = 'c/o Level 3, 13-15 Bridge St';
      $cookedParams['man:Suburb']   = 'Sydney';
      $cookedParams['man:State']    = 'NSW';
      $cookedParams['man:PostCode'] = '2000';
    }
    else {
      // Set credit card holder
      if ($credit_card_holder) {
        $cookedParams->CardHolderName($credit_card_holder);
      }
      // Set name if needed
      if (empty(CRM_Utils_Array::value('first_name', $rawParams)) && !empty($first_name)) {
        $cookedParams->PurchaserFirstName($first_name);
      }
      if (empty(CRM_Utils_Array::value('last_name', $rawParams)) && !empty($last_name)) {
        $cookedParams->PurchaserLastName($last_name);
      }
      // Clear address information
      $cookedParams->PurchaserAddress('');
      $cookedParams->PurchaserPostalCode('');
    }
  }

  /*
   * For the PayPal Standard processor ...
   * Set the return URLs to come back to this $host to avoid invalid session issues
   */
  if ($paymentObj instanceof CRM_Core_Payment_PayPalImpl) {
    $host = $_SERVER['SERVER_NAME'];
    $cookedParams['notify_url'] = str_replace(
      '//citybibleforum.org/',
      '//' . $host . '/',
      $cookedParams['notify_url']
      );
    $cookedParams['cancel_return'] = str_replace(
      '//citybibleforum.org/',
      '//' . $host . '/',
      $cookedParams['cancel_return']
      );
    $cookedParams['return'] = str_replace(
      '//citybibleforum.org/',
      '//' . $host . '/',
      $cookedParams['return']
      );
    CRM_Core_Error::debug_var('PayPal variables', [
      'cooked' => $cookedParams,
    ]);
  }
}

function cbf_civicrm_civicrm_tokens( &$tokens ) {
  $tokens['cbf'] = array('cbf.hostname');
}

function cbf_civicrm_civicrm_tokenValues( &$details, &$contactIDs ) {
  $config = CRM_Core_Config::singleton( );
  $hostname = preg_replace('!^https?://([^/]+)/$!i', '$1', $config->userFrameworkBaseURL);
  if (is_array($contactIDs)) {
    foreach ($details as $id => $detail) {
      $details[$id]['cbf.hostname'] = $hostname;
    }
  }
  else {
    $details['cbf.hostname'] = $hostname;
  }
}

/*
 * Modify API permissions ...
 *  * Allow users with 'edit contributions' permission to create
 *    civicrm_account_contact records. This allows them to queue contacts to
 *    sync with Xero (from the Contact Summary screen).
 *  * Allow users who are editing events to set the payment processor. To do
 *    this they need to execute 'getlist' and 'get'. The permission needed is
 *    either 'administer CiviCRM' (the default) or 'edit all events'.
 *  * Allow users to modify price fields
 *  * Allow users to access the CSV Import Helper objects
 *  * Allow users to create/update Export mappings
 */
function cbf_civicrm_civicrm_alterAPIPermissions($entity, $action, &$params, &$permissions) {
  $permissions['account_contact']['create'] = ['access CiviCRM', 'edit contributions'];

  $permissions['payment_processor']['getlist'] =
  $permissions['payment_processor']['get'] = [ ['administer CiviCRM', 'edit all events'] ];

  $permissions['price_field']['create'] =
  $permissions['price_field']['update'] =
  $permissions['price_field_value']['create'] =
  $permissions['price_field_value']['update'] = [
    [
      'administer CiviCRM',
      'edit all events',
      'edit contributions',
    ]
  ];

  $permissions['csv_helper']['default'] = ['access CiviCRM'];

  $permissions['mapping']['create'] =
  $permissions['mapping']['update'] =
  $permissions['mapping']['delete'] =
  $permissions['mapping_field']['get'] =
  $permissions['mapping_field']['create'] =
  $permissions['mapping_field']['update'] =
  $permissions['mapping_field']['delete'] = [ ['administer CiviCRM', 'import contacts'] ];
}

/*
 * Add extra variables to help with debugging, then return false so
 * the standard error handling continues.
 */
function cbf_civicrm_fatal_error_handler(&$vars) {
  /*
   * Add extra $vars to help with debugging
   */
  $vars['ip'] = ip_address();
  $vars['host'] = $_SERVER['HTTP_HOST'];
  $vars['url']  = 'https://' . $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI'];
  $vars['agent'] = $_SERVER['HTTP_USER_AGENT'] ?? 'not available';
  if (user_is_logged_in()) {
    $vars['username'] = $GLOBALS['user']->name;
  }

  /*
   * There is an issue where users being redirected back to our site after making
   * a PayPal payment are sent an error message because their session has changed.
   * Redirect them to get a thank you message. The page to which they will be
   * redirected has no personal information.
   */
  if (stripos($vars['message'], 'Could not find a valid session key') !== false
    && stripos($_SERVER['QUERY_STRING'], '_qf_ThankYou_display') !== false
    && stripos($_SERVER['HTTP_REFERER'], 'paypal.com') !== false) {
      CRM_Core_Error::debug_var('PayPal error', $vars, true, true, '', PEAR_LOG_ERR);
      CRM_Core_Error::debug_var('Cookies', $_COOKIE, true, true, '', PEAR_LOG_ERR);
      CRM_Core_Error::backtrace('backTrace', true);
      _cbf_civicrm_redirect_to_session_for_qfKey();
      CRM_Utils_System::redirect('/paypal-thankyou');
  }

  /*
   * There are a number of annoying errors that get logged. They seem to be due to
   * robots etc. The $ignore array stores the patterns that should be ignored.
   *
   * The $ignore array consists of a number of pattern sets. Each set is matched
   * against elements of the $vars array. If all the patterns in a set match, we
   * simply return 'true'. This tells CiviCRM to abend processing, and nothing
   * is logged.
   *
   * Note that the preg_match uses '#' as a pattern delimiter so this should not
   * be used in a pattern in $ignore.
   */
  $ignore = [
    [
      'message' => 'Invalid value passed to getPayment function',
      'url' => '/civicrm/event/register.*id=[0-9][0-9][0-9]($|[^0-9])',
    ],
    [
      // People try to inject SQL via the Id parameter
      'message' => 'id .* is not of the type Positive',
      'guard' => 'SQL injection issue',
    ],
    [
      'message' => 'Invalid form parameters',
      'url' => '/civicrm/mailing/forward$',
    ],
    [
      'message' => 'Missing (input )?parameters',
      'url' => '/civicrm/mailing/(optout|unsubscribe)$',
    ],
    [
      'agent' => 'detectify\.com',
    ],
    [
      'message' => 'Error type: Could not find a valid session key',
    ],
    [
      // Robots trawling templates/CRM/common/paymentBlock.tpl
      'message' => 'processor_id \(value: \) is not of the type Integer',
      'url' => '/civicrm/payment/form\?.+&processor_id=$',
    ],
    [
      // People try to poison our database by unsubscribing or opting out
      'message' => '(There was an error in your request|Missing (input )?parameters)',
      'url' => '/civicrm/mailing/(optout|unsubscribe)\?.+',
      'guard' => 'Mailing unsubscribe issue',
    ],
    [
      // Robots trawling an old 'sign Petition' link
      'message' => 'Petition is no longer active',
      'url' => '/civicrm/petition/sign\?',
      'agent' => 'bot',
    ],
    [
      // Robots trawling a registration link
      'message' => 'Could not find valid value for id',
      'url' => '/civicrm/event/register$',
      'agent' => 'bot',
    ],
    [
      // People who register and re-visit the Thankyou page
      'message' => 'Could not find valid value for id',
      'url' => '/civicrm/event/register\?_qf_ThankYou_display=true&qfKey=',
    ],
    [
      // People who are attempting to hack trackable URLs
      'message' => 'One of parameters .* is not of the type Integer',
      'url' => '/sites/all/modules/civicrm/extern/url\.php',
      'guard' => 'Trackable URL issue',
    ],
    [
      // People who trigger the IDS
      'message' => 'Your activity is a bit suspicious, hence aborting',
      'guard' => 'IDS issue',
    ],
  ];

  foreach ($ignore as $patternSet) {
    $guard = false;
    foreach ($patternSet as $element => $pattern) {
      if ($element == 'guard') {
        $guard = $pattern;
      }
      else if (preg_match('#' . $pattern . '#i', $vars[$element] ?? '') != 1) {
        continue 2;
      }
    }
    if (!empty($guard)) {
      CRM_Core_Error::debug_log_message("|CiviCRM guard|$guard|anonymous|{$vars['ip']}|{$vars['url']}");
    }
    return true;
  }

  $vars['ip-details'] = json_decode(file_get_contents("http://ipinfo.io/" . $vars['ip'] . "/json"));
  if (isset($_SESSION)) {
    $vars['session'] = $_SESSION;
    unset($vars['session']['csrf_token_seed']);
    unset($vars['session']['CiviCRM']['qfPrivateKey']);
  }

  return false;
}

/*
 * Implementation of hook_civicrm_pre() to capture changes before they're saved
*/
function cbf_civicrm_civicrm_pre( $op, $objectName, $id, &$params ) {
  /*
   * Whenever an Archived_team ("Past team") is created or edited, ensure
   * its name includes 'No longer meets: ' and its relationships are
   * inactive.
   */
  if ($objectName == 'Household') {
    switch ($op) {
      case 'create':
      case 'edit':
        foreach ($params['contact_sub_type'] as $sub_type) {
          if ($sub_type == 'Archived_team') {
            $archived_team_prefix = 'No longer meets: ';

            if (strpos($params['household_name'], $archived_team_prefix) === false) {
              $params['household_name'] = $archived_team_prefix . $params['household_name'];
            }

            try {
              $get_a = civicrm_api3('Relationship', 'get', array(
                'sequential' => 1,
                'contact_id_a' => $id,
                'is_active' => 1,
              ));
              $get_b = civicrm_api3('Relationship', 'get', array(
                'sequential' => 1,
                'contact_id_b' => $id,
                'is_active' => 1,
              ));
              $get = array_merge($get_a['values'], $get_b['values']);

              foreach ($get as $relationship) {
                $arguments = array(
                  'sequential' => 1,
                  'id' => $relationship['id'],
                  'is_active' => 0,
                );

                if (!isset($relationship['end_date'])) {
                  $arguments['end_date'] = CRM_Utils_Date::getToday();
                }

                $result = civicrm_api3('Relationship', 'create', $arguments);
              }

            } catch (CiviCRM_API3_Exception $e) {
              ;
            }
          }
        }
        break;
    }
  }

  /*
   * The payment_processor field on the civicrm-event-form doesn't support
   * multiselect, but we want people to be able to choose to pay via credit
   * card or PayPal.
   *
   * Until this is resolved, ignore input from this field on this form. This
   * is signalled by cbf__civicrm_entity_form_submit() which sets the
   * payment_processor to be one that is never used. It's name is 'Hack for
   * CiviCRM Event entities' and its number is 15.
   */
  if ($objectName == 'Event') {
    switch ($op) {
      case 'create':
      case 'edit':
        $dummyPaymentProcessor = '15';
        if (($params['payment_processor'] ?? '') == $dummyPaymentProcessor) {
          unset($params['payment_processor']);
        }
        break;
    }
  }
}

/*
 * Implementation of hook_civicrm_post() which is called after a db write on some core objects
 */
function cbf_civicrm_civicrm_post($op, $objectName, $id, &$params) {
  switch ($objectName) {
    case 'Participant':
      _cbf_civicrm_civicrm_post_participant($op, $id, $params);
      break;

    /*
     * When a team is updated, check if there is a Ministry Team entityform associated with it.
     * If so, update it too.
     */
    case 'Household':
      switch ($op) {
        case 'edit':
          if (strpos($params->contact_sub_type, 'Team') !== false) {
            $query = new EntityFieldQuery();
            $result = $query->entityCondition('entity_type', 'entityform')
            ->entityCondition('bundle', 'ministry_team')
            ->fieldCondition('field_ministry_team', 'contact_id', $id, '=')
            ->execute();
            foreach ($result as $entityType => $entities) {
              $entities = entity_load($entityType, array_keys($entities));
              foreach ($entities as $entity) {
                entity_save($entityType, $entity);
              }
            }
          }
          break;
      }
      break;
  }
}

function _cbf_civicrm_civicrm_add_to_list_via_entity($contactId, $entityTable, $entityId, $fieldNumber) {
  try {
    $custom_values = civicrm_api3('CustomValue', 'get', array(
      'sequential' => 1,
      'entity_id' => $entityId,
      'entity_table' => $entityTable,
      'id' => $fieldNumber,
    ));

    $listId = null;

    foreach ($custom_values['values'] as $custom_value) {
      if (isset($custom_value['latest']) && isset($custom_value['id']) && $custom_value['id'] == $fieldNumber) {
        $listId = (int) $custom_value['latest'];
        break;
      }
    }

    if ($listId > 0) {
      $result = civicrm_api3('GroupContact', 'create', array(
        'sequential' => 1,
         'contact_id' => $contactId,
         'status' => 'Added',
         'group_id' => $listId,
      ));
    }
  } catch (Exception $e) {
    return;
  }
}

function _cbf_civicrm_civicrm_post_participant($op, $id, &$params) {
  switch ($op) {
    /*
     * Whenever a Participant is created, ensure the contact has a Ministry
     * Centre tag. If it doesn't, add a tag that corresponds to the Ministry
     * Centre of the event.
     */
    case 'create':
      try {
        if (_cbf_civicrm_civicrm_contact_ministry_centre($params->contact_id) !== false) {
          break;
        }

        list($tagId, $name) = _cbf_civicrm_civicrm_event_ministry_centre($params->event_id);

        if ($tagId !== false) {
          $create = civicrm_api3('EntityTag', 'create', array(
            'sequential' => 1,
            'entity_table' => 'civicrm_contact',
            'entity_id' => $params->contact_id,
            'tag_id' => $tagId,
          ));
        }
      } catch (CiviCRM_API3_Exception $e) {
        ;
      }
      break;
  }
}

/*
 * Originally intended this function to be called like _cbf_civicrm_civicrm_post_participant
 * but the desired functionality didn't work due to timing - the post hook was called before
 * the City was attached to the Contribution.
 *
 * So the 3rd argument was changed for convenience, and this function is now called when an
 * Account Invoice is being sent to Xero.
 */
function _cbf_civicrm_civicrm_post_contribution($op, $id, $contact_id) {
  switch ($op) {
    /*
     * Whenever a Contribution is created, ensure the contact has a Ministry
     * Centre tag. If it doesn't, add a tag that corresponds to the City they
     * entered.
     */
    case 'create':
      try {
        if (_cbf_civicrm_civicrm_contact_ministry_centre($contact_id) !== false) {
          break;
        }

        $ministry_centre = _cbf_civicrm_civicrm_contribution_ministry_centre($id);

        if ($ministry_centre !== false) {
          $create = civicrm_api3('EntityTag', 'create', array(
            'sequential' => 1,
            'entity_table' => 'civicrm_contact',
            'entity_id' => $contact_id,
            'tag_id' => $ministry_centre,
          ));
        }
      } catch (CiviCRM_API3_Exception $e) {
        ;
      }
      break;
  }
}

function _cbf_civicrm_civicrm_contact_ministry_centre($contact_id) {
  $ministry_centre_prefix = 'Ministry centre is ';

  $entity_tags = civicrm_api3('EntityTag', 'get', array(
    'sequential' => 1,
    'entity_table' => 'civicrm_contact',
    'entity_id' => $contact_id,
  ));

  foreach ($entity_tags['values'] as $entity_tag) {
    $tag = civicrm_api3('Tag', 'get', array(
      'sequential' => 1,
      'id' => $entity_tag['tag_id'],
      'return' => 'name',
    ));

    $exploded = explode($ministry_centre_prefix, $tag['values'][0]['name']);
    if (count($exploded) == 2 && $exploded[0] == '' && $exploded[1] != $tag['values'][0]['name']) {
      return $exploded[1];
    }
  }

  return false;
}

function _cbf_civicrm_civicrm_event_ministry_centre($event_id) {
  $ministry_centre_group_id = 326;
  $ministry_centre_prefix = 'Ministry centre is ';

  try {
    $custom_values = civicrm_api3('CustomValue', 'get', array(
      'sequential' => 1,
      'entity_id' => $event_id,
      'entity_table' => 'civicrm_event',
      'id' => 25,
    ));

    $ministry_centre_id = null;

    foreach ($custom_values['values'] as $custom_value) {
      if (isset($custom_value['latest']) && isset($custom_value['id']) && $custom_value['id'] == 25) {
        $ministry_centre_id = (int) $custom_value['latest'];
        break;
      }
    }

    if (empty($ministry_centre_id)) {
      return array(false, false);
    }

    $ministry_centre = civicrm_api3('OptionValue', 'getvalue', array(
      'sequential' => 1,
      'option_group_id' => $ministry_centre_group_id,
      'value' => $ministry_centre_id,
      'return' => 'label',
    ));

    $tag = civicrm_api3('Tag', 'getvalue', array(
      'sequential' => 1,
      'name' => $ministry_centre_prefix . $ministry_centre,
      'return' => 'id',
    ));

    return array($tag, $ministry_centre);
 
  } catch (CiviCRM_API3_Exception $e) {
    return array(false, false);
  }
}

function _cbf_civicrm_civicrm_contribution_ministry_centre($contribution_id) {
  $focus_group_id = 329;
  $ministry_centre_prefix = 'Ministry centre is ';

  try {
    // Since the City value is publicly visible, no need to use CustomValue API
    $cityCode = civicrm_api3('Contribution', 'getvalue', array(
      'sequential' => 1,
      'return' => 'custom_26',
      'id' => $contribution_id,
    ));

    if (empty($cityCode)) {
      return false;
    }

    $city = civicrm_api3('OptionValue', 'getvalue', array(
      'sequential' => 1,
      'option_group_id' => $focus_group_id,
      'value' => $cityCode,
      'return' => 'label',
    ));

    $tag = civicrm_api3('Tag', 'get', array(
      'sequential' => 1,
      'return' => 'id',
      'name' => $ministry_centre_prefix . $city,
    ));

    if ($tag['count'] == 1) {
      return $tag['values'][0]['id'];
    }
  } catch (CiviCRM_API3_Exception $e) {
    ;
  }

  return false;
}

/*
 * A hook that gets called by the AccountSync extension, prior to pulling data
 * from Xero.
 *
 * @param string $entity entity - eg. 'contact'
 * @param array $data data from accounts being processing
 * @param bool $save save? - set this to false if it should be skipped
 * @param $params
 *
 * @return mixed
 *   Ignore value.
 */
function cbf_civicrm_civicrm_accountPullPreSave($entity, &$data, &$save, &$params) {
  switch ($entity) {
    case 'contact':
      break;

    case 'invoice':
      // Don't try to pull Invoices when the Contribution Id is not numeric
      if (isset($params['contribution_id']) && !is_numeric($params['contribution_id'])) {
        $save = false;
      }
      break;
  }
}


/*
 * A hook that gets called by the AccountSync extension, prior to pushing data
 * to Xero.
 *
 * @param string $entity entity - eg. 'contact'
 * @param array $data data from accounts being processing
 * @param bool $save save? - set this to false if it should be skipped
 * @param $params
 *
 * @return mixed
 *   Ignore value.
 */
function cbf_civicrm_civicrm_accountPushAlterMapped($entity, &$data, &$save, &$params) {
  switch ($entity) {
    case 'contact':
      /* Baulk if all the Contributions for this Contact have
       *  - the Suppress Xero Invoice is set
       *  - the contribution is a test
       *  - the contribution is zero-valued
       */
      try {
        $contributions = \Civi\Api4\Contribution::get(FALSE)
          ->addWhere('contact_id', '=', $data['contact_id'])
          ->addClause(
            'OR',
            ['Xero_invoice.Suppress_Xero_invoice', '=', 0],
            ['Xero_invoice.Suppress_Xero_invoice', 'IS NULL'])
          ->addWhere('is_test', '=', FALSE)
          ->addWhere('total_amount', '>', 0)
          ->setLimit(1)
          ->execute();
          $save = false;
        foreach ($contributions as $_) {
          $save = true;
        }
        CRM_Core_Error::debug_var('cbf_civicrm_civicrm_accountPushAlterMapped', [
          'contact' => $data['contact_id'],
          'push to Xero' => $save,
        ]);
      } catch (\API_Exception $e) {
        CRM_Core_Error::debug_var('cbf_civicrm_civicrm_accountPushAlterMapped exception', $e);
      }

      // Remove prefixes etc from Contact name
      if ($data['contact_type'] == 'Individual') {
        $params['Name'] = $data['first_name'] . ' ' . $data['last_name'] . ' - ' . $data['contact_id'];
      }
      // Highlight deleted contacts in Xero
      $deletedSuffix = ' (deleted in CiviCRM)';
      if (!empty($data['contact_is_deleted']) && stristr($params['Name'], $deletedSuffix) === false) {
        $params['Name'] .= $deletedSuffix;
      }
      break;

    case 'invoice':
      // Ensure the contact has a Ministry Centre tag
      _cbf_civicrm_civicrm_post_contribution('create', $data['contribution_id'], $data['contact_id']);

      /* Baulk if
       *  - the Suppress Xero Invoice is set
       *  - the contribution is a test
       *  - the contribution is zero-valued
       */
      if (!empty($data['custom_43']) || $data['is_test'] != '0' || $data['total_amount'] == '0.00') {
        $save = false;
        break;
      }

      /*
       * Include the Transaction Id in the Invoice reference
       * Clean the reference of non-ASCII characters
       */
      if (!empty($data['trxn_id'])) {
        $params['Reference'] = $data['trxn_id'] . ' - ' . $params['Reference'];
      }
      $params['Reference'] = filter_var(
        $params['Reference'],
        FILTER_SANITIZE_STRING,
        FILTER_FLAG_STRIP_LOW | FILTER_FLAG_STRIP_HIGH
      );

      // Ensure there is at least one Line Item in the Invoice
      if (empty($params['LineItems']['LineItem'])) {
        $accountCode = CRM_Accountsync_BAO_AccountInvoice::getAccountCode($data['financial_type_id']);
        if (empty($accountCode)) {
          $accountCode = civicrm_api('setting', 'getvalue', array(
            'group' => 'Xero Settings',
            'name' => 'xero_default_revenue_account',
            'version' => 3,
          ));
        }
        $params['LineItems']['LineItem'][] = array(
          'Description' => 'Amount',
          'Quantity' => '1.00',
          'UnitAmount' => $data['total_amount'],
          'AccountCode' => $accountCode,
        );
        $data['line_items'][] = array('label' => 'Amount');
      }

      // Process each Line Item
      $lineItemKeys = array_keys($data['line_items']);
      foreach ($params['LineItems']['LineItem'] as $key => $lineitem) {
        $local = $data['line_items'][$lineItemKeys[$key]];

        // Remove some gumph from the Description
        $params['LineItems']['LineItem'][$key]['Description'] = filter_var(
          $local['label'],
          FILTER_SANITIZE_STRING,
          FILTER_FLAG_STRIP_LOW | FILTER_FLAG_STRIP_HIGH
        );

        // Set the Account Code for recurring contributions
        if (!empty($data['contribution_recur_id'])) {
          $params['LineItems']['LineItem'][$key]['AccountCode'] = '40110';
        }

        // Capture the City tracking category. This may be supplied for
        // Contributions, but can be derived from the Event's ministry
        // centre.
        if (!empty($data['custom_26'])) {
          $params['LineItems']['LineItem'][$key]['Tracking']
            = array(
                'TrackingCategory' =>
                  array(
                    array(
                     'Name' => 'City',
                     'Option' => $data['custom_26']
                  )
              )
          );
        } elseif (!empty($data['api.participant_payment.get']) && $data['api.participant_payment.get']['count'] > 0) {
          $event_id = $data['api.participant_payment.get']['values'][0]['api.participant.get']['values'][0]['event_id'];
          list($tagId, $name) = _cbf_civicrm_civicrm_event_ministry_centre($event_id);
          if (!empty($name)) {
            $params['LineItems']['LineItem'][$key]['Tracking']
              = array(
                  'TrackingCategory' =>
                    array(
                      array(
                       'Name' => 'City',
                       'Option' => strtoupper(substr($name, 0, 3))
                    )
                )
            );
          }
        }
      }

      // Capture the Purpose if supplied as an extra Line Item
      if (!empty($data['custom_27'])) {
        $params['LineItems']['LineItem'][] = array(
          'Description' => filter_var(
            $data['custom_27'],
            FILTER_SANITIZE_STRING,
            FILTER_FLAG_STRIP_LOW | FILTER_FLAG_STRIP_HIGH),
        );
      }
      break;
  }
}

/*
 * Support integer custom fields that map to group ids. These are set with a dummy
 * option of 0 => 'None', which needs to be removed.
 */
function cbf_civicrm_civicrm_fieldOptions($entity, $field, &$options, $params) {
  static $activeMailingLists = null;

  switch ($field) {
    case 'custom_45': // 'Events like this' list
    case 'custom_46': // 'News and updates' list
      try {
        if (!isset($activeMailingLists)) {
          $activeMailingLists = civicrm_api3(
            'Group',
            'get',
            array(
              'sequential' => 1,
              'is_active' => 1,
              'group_type' => 2, // Mailing list
              'is_hidden' => 0,
              'options' => array('limit' => 0),
            )
          );
        }
        if ($activeMailingLists['is_error'] != 0) {
          return;
        }
        foreach ($activeMailingLists['values'] as $list) {
          $options[$list['id']] = $list['title'];
        }
        if ($options[0] == 'None') {
          unset($options[0]);
        }
      } catch (Exception $e) {
        return;
      }
      break;

    default:
      return;
  }
}

function _cbf_civicrm_civicrm_event_staff_contact($event_id) {
  try {
    $contact = civicrm_api3('Event', 'get', [
      'sequential' => 1,
      'return' => ['custom_62'],
      'id' => $event_id,
    ]);

    if (count($contact['values']) == 1 && !empty($contact['values'][0]['custom_62'])) {
      return [
        'id' => $contact['values'][0]['custom_62_id'],
        'name' => $contact['values'][0]['custom_62'],
      ];
    }
  } catch (CiviCRM_API3_Exception $e) {
    ;
  }

  return false;
}

function _cbf_civicrm_civicrm_event_ministry_centre_id($name) {
  $ministry_centre_group_id = 326;

  try {
    $tag = civicrm_api3('OptionValue', 'get', array(
      'sequential' => 1,
      'label' => $name,
      'option_group_id' => $ministry_centre_group_id,
      'return' => 'value',
    ));

    if (count($tag['values']) == 1) {
      return $tag['values'][0]['value'];
    }
  } catch (CiviCRM_API3_Exception $e) {
    ;
  }

  return false;
}

/*
 * Track the CiviCRM form which we are currently processing
 */
function _cbf_civicrm_current_form($formName = null) {
  $name = &drupal_static(__FUNCTION__);

  if ($formName !== null) {
    $name = $formName;
  }
  return $name;
}

/*
 * Alter any Facebook tracking pixels that are linked to a CiviCRM path.
 *
 * If this is a CiviEvent, we need to be on the thankyou page for an event
 * in which we are interested.
 */
function cbf_civicrm_facebook_tracking_pixel_alter(&$trackingpaths) {
  $currentForm = _cbf_civicrm_current_form();
  if (!empty($trackingpaths)) {
    foreach ($trackingpaths as $index => $code) {
      $unset = true;
      $path = explode('|', $code['event_path']);
      $matches = null;
      switch ($path[0]) {
        case 'civicrm/event/register':
          if ($currentForm == 'CRM_Event_Form_Registration_ThankYou') {
            preg_match('![?&;]id=([0-9]+)!i', $_SESSION['CiviCRM']['entryURL'], $matches);
            $eventId = empty($matches[1]) ? null : $matches[1];
            if (!empty($path[1]) && $eventId == $path[1]) {
              /*
               * Preserve this tracking path
               * Prevent the default tracking path rule removing it
               */
              $unset = false;
            }
          }
          break;

        case 'civicrm/contribute/transact':
          if ($currentForm == 'CRM_Contribute_Form_Contribution_ThankYou') {
            preg_match('![?&;]id=([0-9]+)!i', $_SESSION['CiviCRM']['entryURL'], $matches);
            $eventId = empty($matches[1]) ? null : $matches[1];
            if (!empty($path[1]) && $eventId == $path[1]) {
              /*
               * Preserve this tracking path
               * Prevent the default tracking path rule removing it
               */
              $unset = false;
            }
          }
          break;
      }
      if ($unset) {
        unset($trackingpaths[$index]);
      }
      else {
        $trackingpaths[$index]['event_path'] = $path[0];
      }
    }
  }
}

function _cbf_civicrm_civicrm_address_get_location_data($id) {
  $result = [];

  try {
    // Get the Address
    $record = civicrm_api3('Address', 'get', [
      'sequential' => 1,
      'return' => [
        "name",
        "supplemental_address_1",
        "street_address",
        "city",
        "state_province_id",
        "postal_code",
        "country_id",
        "geo_code_1",
        "geo_code_2",
      ],
      'id' => $id,
    ]);
    if (!isset($record['values'][0]['state_province_id'])) {
      return $result;
    }
    else {
      $result['name'] = empty($record['values'][0]['supplemental_address_1'])
        ? $record['values'][0]['name']
        : $record['values'][0]['supplemental_address_1'];
      $result['street'] = $record['values'][0]['street_address'];
      $result['city'] = $record['values'][0]['city'];
      $result['postal_code'] = $record['values'][0]['postal_code'];
      $result['latitude']	= $record['values'][0]['geo_code_1'];
      $result['longitude'] = $record['values'][0]['geo_code_2'];
      $result['country'] = "au";
      $result['country_name'] = "Australia";

      // Get the State/Province
      $record = civicrm_api3('StateProvince', 'get', [
        'sequential' => 1,
        'return' => ["name", "abbreviation"],
        'id' => $record['values'][0]['state_province_id'],
      ]);
      if (!isset($record['values'][0]['name'])) {
        return $result;
      }
      else {
        $result['province'] = $record['values'][0]['abbreviation'];
        $result['province_name'] = $record['values'][0]['name'];
      }
    }
  } catch (CiviCRM_API3_Exception $e) {
    ;
  }

  return $result;
}

function cbf_civicrm_civicrm_event_get_location_data($id) {
  $result = [];

  try {
    // Get the Event
    $record = civicrm_api3('Event', 'get', [
      'sequential' => 1,
      'return' => ["loc_block_id"],
      'id' => $id,
    ]);
    if (!isset($record['values'][0]['loc_block_id'])) {
      return $result;
    }
    else {
      $id = $record['values'][0]['loc_block_id'];
    }

    // Get the Location Block
    $record = civicrm_api3('LocBlock', 'get', [
      'sequential' => 1,
      'return' => ["address_id"],
      'id' => $id,
    ]);
    if (!isset($record['values'][0]['address_id'])) {
      return $result;
    }
    else {
      $id = $record['values'][0]['address_id'];
    }

    // Get the location data from the Address
    $result = _cbf_civicrm_civicrm_address_get_location_data($id);

  } catch (CiviCRM_API3_Exception $e) {
    ;
  }

  return $result;
}

function cbf_civicrm_ministry_team_viewable_fields($team) {
  $result = [];
  try {
    $record = civicrm_api3('Contact', 'get', [
      'sequential' => 1,
      'return' => ["nick_name", "custom_7", "custom_6", "custom_61", "address_id"],
      'id' => $team,
    ]);
    if (!isset($record['values'][0]['id'])) {
      return $result;
    }

    if (!empty($record['values'][0]['nick_name'])) {
      $result['nickname'] = $record['values'][0]['nick_name'];
    }
    if (!empty($record['values'][0]['custom_7'])) {
      $result['meeting day/time'] = $record['values'][0]['custom_7'];
    }
    if (!empty($record['values'][0]['address_id'])) {
      $result['address']
        = _cbf_civicrm_civicrm_address_get_location_data(
            $record['values'][0]['address_id']
          );
    }
    if (!empty($record['values'][0]['custom_61'])) {
      $record = civicrm_api3('Contact', 'get', [
        'sequential' => 1,
        'return' => ["display_name"],
        'id' => $record['values'][0]['custom_61'],
      ]);
      if (!empty($record['values'][0]['display_name'])) {
        $result['staff contact'] = [
          'id' => $record['values'][0]['id'],
          'display_name' => $record['values'][0]['display_name'],
        ];
      }
    }

    $record = civicrm_api3('EntityTag', 'get', [
      'sequential' => 1,
      'return' => ["tag_id"],
      'entity_table' => "civicrm_contact",
      'entity_id' => $team,
    ]);
    $result['tags'] = [];
    foreach ($record['values'] as $tag) {
      $result['tags'][] = $tag['tag_id'];
    }

  } catch (CiviCRM_API3_Exception $e) {
    ;
  }
  return $result;
}

function _cbf_civicrm_thinkific_enrolment($first, $last, $email, $id, $course, $expiry) {
  $api = 'https://api.thinkific.com/api/public/v1/';
  $headers = [
    'X-Auth-API-Key' => variable_get('cbf_thinkific_api'),
    'X-Auth-Subdomain' => variable_get('cbf_thinkific_subdomain'),
    'Content-Type' => 'application/json',
  ];
  $thinkificDateFormat = 'Y-m-d\TH:i:s\Z';
  $activation_time = new DateObject(strtotime('now'), 'UTC');
  $activation_time = $activation_time->format($thinkificDateFormat);
  $expiry_time = new DateObject(strtotime($expiry), 'UTC');
  $expiry_time = $expiry_time->format($thinkificDateFormat);

  $result = [
    'status' => 'find user',
    'progress' => [],
    'thinkific' => [
      'user' => '',
      'course' => '',
    ],
  ];

  while (true) {
    $steps = [
      'find user' => [
        'method' => 'GET',
        'endpoint' => 'users?query[email]=' . $email,
        'data' => [],
      ],
      'create user' => [
        'method' => 'POST',
        'endpoint' => 'users',
        'data' => [
          'first_name' => $first,
          'last_name' => $last,
          'email' => $email,
        ],
      ],
      'find course' => [
        'method' => 'GET',
        'endpoint' => 'courses/' . $course,
        'data' => [],
      ],
      'enrol user' => [
        'method' => 'POST',
        'endpoint' => 'enrollments',
        'data' => [
          'course_id' => $course . '',
          'user_id' => $result['thinkific']['user'] . '',
          'activated_at' => $activation_time,
          'expiry_date' => $expiry_time,
        ],
      ],
    ];
    if (is_numeric($id)) {
      $steps['create user']['data']['external_id'] = $id . '';
    }

    $step = $steps[$result['status']];
    $httpResult = drupal_http_request(
      $api . $step['endpoint'],
      [
        'headers' => $headers,
        'method' => $step['method'],
        'data' => json_encode($step['data']),
      ]
    );

    switch ($httpResult->code) {
      case 200: // OK
      case 201: // Created
        $httpResponse = json_decode($httpResult->data);
        switch ($result['status']) {
          case 'find user':
            if (empty($httpResponse->items)) {
              $result['progress'][] = "No existing user for {$email}";
              $result['status'] = 'create user';
            }
            else {
              $result['thinkific']['user'] = $httpResponse->items[0]->id;
              $result['progress'][] = "User {$email} found";
              $result['status'] = 'find course';
            }
            break;

          case 'create user':
            $result['thinkific']['user'] = $httpResponse->id;
            $result['progress'][] = "User {$email} created";
            $result['status'] = 'find course';
            break;

          case 'find course':
            $result['thinkific']['course'] = $httpResponse->name;
            $result['progress'][] = "Course '{$result['thinkific']['course']}' found";
            $result['status'] = 'enrol user';
            break;

          case 'enrol user':
            $result['progress'][] = "User {$email} enrolled in course";
            $result['status'] = 'Success';
            return $result;
        }
        break;

      case 400: // Bad request
      case 403: // Access forbidden
      case 404: // Not found
      case 422: // Validation error
      case 500: // Internal server error
      default:  // Unexpected error
        $result['progress'][] = "Failed to {$result['status']}";
        $result['progress'][] = "HTTP code was {$httpResult->code}";
        $result['status'] = 'Failure';
        return $result;
    }
  }
}

/*
 * Redirect the visitor to a session that matches the qfKey they specify.
 *
 * If not “we have been here before”, then
 *   If can find the original session, then
 *     Load data from original session into this session
 *     Redirect to try again, marking “we have been here before” to avoid a loop
 *
 * If the redirect doesn't happen for any reason, this function will return false.
 * The calling logic should assume that if this function returns that's a failure.
 */
function _cbf_civicrm_redirect_to_session_for_qfKey() {
  $progress = [];
  $qfKey = CRM_Utils_Request::retrieve('qfKey', 'String') ?? false;
  $progress[] = 'qfKey = ' . $qfKey;
  $beenHere = CRM_Utils_Request::retrieve('cbf', 'Boolean') ?? false;
  $progress[] = 'beenHere = ' . $beenHere;

  if ($qfKey && !$beenHere) { // We have a qfKey and we've not been here before
    /*
     * Reproduce the logic for finding a session from _drupal_session_read
     * But: assume HTTPS;
     *      search by hostname rather than ssid;
     *      allow for zero to many results.
     */
    $hostname = ip_address();
    $progress[] = 'hostname = ' . ip_address();
    $progress[] = 'HTTP_HOST = ' . $_SERVER['HTTP_HOST'];
    $result =
      db_query(
        "SELECT u.*, s.* FROM {users} u INNER JOIN {sessions} s ON u.uid = s.uid WHERE s.hostname = :hostname",
        [':hostname' => $hostname]
      )->fetchAll();
    $sessions = [];
    foreach ($result as $session) {
      $sessions[] = [
        'ssid' => $session->ssid,
        'uid' => $session->uid ?? 0,
        'session' => $session->session
      ];
      $progress[] = 'Found session with ssid = ' . $session->ssid;
    }

    /*
     * Reproduce the logic for validating a qfKey from CRM_Core_Key
     * But: lookup the name of the CiviCRM controller
     *      Ensure a Drupal session has started as we intend to encode an decode sessions
     *      preserve the original $_SESSION and restore it even if there is an
     *      load each session into $_SESSION
     *      exception
     *      track the sessions which match the qfKey
     */
    $controller = '';
    $path = drupal_parse_url($_SERVER['REQUEST_URI'])['path'];
    $progress[] = 'path = ' . $path;
    switch ($path) {
      case '/civicrm/contribute/transact':
        $controller = 'CRM_Contribute_Controller_Contribution';
        break;
      case '/civicrm/event/register':
        $controller = 'CRM_Event_Controller_Registration';
        break;
    }
    $progress[] = 'controller = ' . $controller;

    $matches = [];
    drupal_session_start();
    $thisSession = session_encode();
    $progress[] = 'Current session = ' . $thisSession;
    try {
      foreach ($sessions as $session) {
        $_SESSION = [];
        $progress[] = 'Trying session with ssid = ' . $session['ssid'];
        if (session_decode($session['session'])) {
          list($k, $t) = explode('_', $qfKey);
          if ($t >= 1 && $t < 10000) {
            $prefix = preg_replace('/[^a-zA-Z0-9]/', '', $controller);
            $hashKey = hash_hmac(
              CRM_Core_Key::HASH_ALGO,
              $_SESSION['CiviCRM']['qfSessionID'] . chr(0) . $controller,
              $_SESSION['CiviCRM']['qfPrivateKey']);
            $hashKey = $prefix . base_convert($hashKey, 16, 36);
            $progress[] = 'qfSessionID = ' . $_SESSION['CiviCRM']['qfSessionID'];
            $progress[] = 'qfPrivateKey = ' . $_SESSION['CiviCRM']['qfPrivateKey'];
            $progress[] = 'hashed key = ' . $hashKey;
            if (hash_equals($k, $hashKey)) {
              $matches[] = $session;
              $progress[] = 'Matched session with ssid = ' . $session['ssid'];
            }
          }
        }
        else {
          $progress[] = 'Failed to decode session with ssid = ' . $session['ssid'];
        }
      }
    } catch (Exception $e) {
      ;
    }

    if (count($matches) == 1) { // We have found the original session
      /*
       * Load data from the original session into this session, borrowing logic
       * from hybridauth_session_start()
       */
      $_SESSION = [];
      session_decode($matches[0]['session']);
      $progress[] = 'Loaded session = ' . $matches[0]['session'];
      db_delete('sessions')->condition('ssid', $matches[0]['ssid'])->execute();
      $progress[] = 'Deleted row from sessions table with ssid = ' . $matches[0]['ssid'];

      /*
       * Redirect to try again, marking “we have been here before” to avoid a loop
       * But: this implements CRM_Utils_System::redirect with response code 307
       *      this doesn't work if the current URL was redirected internally
       *      this may not work if the current method is not POST
       */
      $uri = $_SERVER['REQUEST_URI'] . '&cbf=1';
      $progress[] = 'Redirect to URI = ' . $uri;
      CRM_Core_Error::debug_var('_cbf_civicrm_redirect_to_session_for_qfKey', $progress);
      http_response_code(307);
      CRM_Utils_System::redirect($uri);
    }

    $_SESSION = [];
    session_decode($thisSession);
    $progress[] = 'Reloaded the starting session = ' . $thisSession;
  }

  CRM_Core_Error::debug_var('_cbf_civicrm_redirect_to_session_for_qfKey', $progress);
  return false;
}

/*
 * Implements hook_civicrm_dupeQuery
 *
 * This hook is called during the dedupe lookup process, and can be used to
 * alter the parameters and queries used to determine if two contacts are
 * duplicates.
 */
function cbf_civicrm_civicrm_dupeQuery($obj, $type, &$query) {
  switch ($type) {
    case 'table':
      $testRuleId = '20';
      if ($obj->id == $testRuleId) {
        /*
         * Nickname matching
         *
         * Modify the queries for matching Contact first and last names to
         * also match on nickname.
         */
        $schema = ['civicrm_contact' => ['first_name', 'last_name']];
        foreach ($schema as $table => $columns) {
          foreach ($columns as $column) {
            foreach ($query as $i => $sql) {
              if (preg_match("#^$table\.$column\.[0-9]+$#i", $i)) {
                $value = $obj->params[$table][$column] ?? '';
                if (empty($value)) {
                  /*
                   * An empty $value means the name query will JOIN the
                   * contact table to itself.
                   *
                   * Here are the steps for extending the name query to also
                   * use the nickname
                   *
                   *  1. Duplicate the SQL so we have 'name' SQL and 'nickname'
                   *     SQL
                   *  2. Replace the name column on the 2nd table with nickname
                   *  3. Replace the 'name equality' test with 2 tests: firstly
                   *     that the names don't match as that is handled by the
                   *     'name' SQL; secondly that 1st table's name is found in
                   *     the 2nd table's nickname (see comment below re how the
                   *     nickname test works)
                   *  4. Since the nickname test is not reflexive we need to
                   *     replace the 'less than' ID test with 'not equal' test
                   *  5. Since the 'name' SQL delivers results with id1 < id2
                   *     we need to do that for the 'nickname' SQL
                   *  6. We UNION the results of the 'name' SQL with that of
                   *     the 'nickname' SQL, using similar logic to that at the
                   *     end of CRM_Dedupe_BAO_Rule::sql(), while ensuring any
                   *     derived tables have different names ('subunion' etc)
                   */
                  $nicksql = $sql;
                  $nicksql = str_ireplace(
                    "t2.$column",
                    "t2.nick_name",
                    $nicksql);
                  $nicksql = str_ireplace(
                    "t1.$column = t2.nick_name",
                    "t1.$column <> t2.$column AND locate(concat(' ', t1.$column, ','), concat(' ', t2.nick_name, ',')) > 0",
                    $nicksql);
                  $nicksql = str_ireplace(
                    "t1.id < t2.id",
                    "t1.id <> t2.id",
                    $nicksql);
                  $nicksql = str_ireplace(
                    "SELECT t1.id id1, t2.id id2",
                    "SELECT IF(t1.id < t2.id, t1.id, t2.id) id1, IF(t1.id < t2.id, t2.id, t1.id) id2",
                    $nicksql);
                  $nicksql = str_ireplace(
                    ") subunion",
                    ") subunion1",
                    $nicksql);
                  $sql = "SELECT id1, id2, weight FROM ($sql UNION $nicksql) subunion2";
                }
                else {
                  /*
                   * A non-empty $value means the name SQL is looking to match
                   * the name with that $value.
                   *
                   * Replace the 'name equality' test with an A OR B test: A is
                   * the original name test, and B is a test that the $value is
                   * found in the nickname.
                   *
                   * The $value and nickname are book-ended with a space and a
                   * comma, so that ...
                   *
                   * Value   Nickname    Match?
                   * -----   --------    ------
                   * Ken     Ken         Yes
                   * Ken     Ken, Jim    Yes
                   * Ken     Kenneth     No
                   * Frazer  nee Frazer  Yes
                   */
                  $sql = str_ireplace(
                    "t1.$column = '$value'",
                    "(t1.$column = '$value' OR (t1.nick_name IS NOT NULL AND locate(' $value,', concat(' ', t1.nick_name, ',')) > 0))",
                    $sql);
                }
                $query[$i] = $sql;
                break;
              }
            }
          }
        }

        /*
         * Phone matching
         *
         * Modify the queries for matching Phone numbers to only look at the
         * last 9 digits.
         */
        $schema = ['civicrm_phone' => ['phone_numeric']];
        foreach ($schema as $table => $columns) {
          foreach ($columns as $column) {
            foreach ($query as $i => $sql) {
              if (preg_match("#^$table\.$column\.[0-9]+$#i", $i)) {
                $value = $obj->params[$table][$column] ?? '';
                if (empty($value)) {
                  /*
                   * An empty $value means the phone query will JOIN the
                   * phone table to itself.
                   */
                  $sql = str_ireplace(
                    "t1.$column = t2.$column",
                    "((t1.$column - t2.$column) mod 1000000000) = 0",
                    $sql);
                }
                else {
                  /*
                   * A non-empty $value means the name SQL is looking to match
                   * the name with that $value.
                   */
                  $sql = str_ireplace(
                    "t1.$column = '$value'",
                    "((t1.$column - '$value') mod 1000000000) = 0",
                    $sql);
                }
                $query[$i] = $sql;
                break;
              }
            }
          }
        }
      }
      break;
  }
}

/*
 * This hook is called when contacts are added/updated via profiles, event
 * registration pages, contribution pages etc. When a form is submitted CiviCRM
 * checks if a contact already exists using one of the built-in deduplication
 * rules and returns a contact ID if a match is found.
 *
 * This hook allows you to override the contact matching rules to implement
 * more complex rules.
 */
function cbf_civicrm_civicrm_findDuplicates($dedupeParams, &$dedupeResults, $contextParams) {
  $externalId = $dedupeParams['civicrm_contact']['external_identifier'] ?? '';
  if (!empty($externalId)) {
    try {
      $found = [];

      // Find a contact that matches using Contact Id
      $result = civicrm_api3('Contact', 'get', [
        'sequential' => 1,
        'return' => ['id'],
        'id' => $externalId,
        'contact_type' => $dedupeParams['contact_type'],
        'is_deleted' => 0,
      ]);
      if ($result['id'] == $externalId) { // $result can't be multiple items
        $found[] = $externalId;
      }

      // Find a contact that matches using External Id
      $result = civicrm_api3('Contact', 'get', [
        'sequential' => 1,
        'return' => ['id'],
        'external_identifier' => ['LIKE' => "%$externalId%"],
        'contact_type' => $dedupeParams['contact_type'],
        'is_deleted' => 0,
      ]);
      foreach ($result['values'] as $match) {
        $externalIds = $match['external_identifier'];
        if (stristr(" $externalIds,", " $externalId,")) {
          $found[] = $match['id'];
        }
      }

      // Find a not-deleted contact that the searched-for contact was merged into
      if (empty($found)) {
        $result = civicrm_api3('Activity', 'get', [
          'sequential' => 1,
          'return' => ['target_contact_id', 'subject'],
          'activity_type_id' => 'Contact Merged',
          'subject' => ['LIKE' => "% $externalId %"],
        ]);
        foreach ($result['values'] as $match) {
          foreach ($match['target_contact_id'] as $i) {
            $result1 = civicrm_api3('Contact', 'get', [
              'sequential' => 1,
              'return' => ['id', 'external_identifier'],
              'id' => $i,
              'contact_type' => $dedupeParams['contact_type'],
              'is_deleted' => 0,
            ]);
            if ($result1['id'] == $i) { // $result1 can't be multiple items
              $found[] = $i;

              // Remember the External Identifier for next time
              $eid = $result1['values'][0]['external_identifier'];
              if (empty($eid)) {
                $eid = $externalId;
              }
              else {
                $eid .= ", $externalId";
              }
              $result2 = civicrm_api3('Contact', 'create', [
                'contact_type' => $dedupeParams['contact_type'],
                'id' => $i,
                'external_identifier' => $eid,
              ]);
            }
          }
        }
      }

      // Return any found results
      $dedupeResults['ids'] = $found;
      $dedupeResults['handled'] = true;
    } catch (CiviCRM_API3_Exception $e) {
    }
  }
}

/*
 * Advise if this staff member is contactable
 */
function _cbf_civicrm_staff_is_contactable($id) {

  $contactable = 'Staff.Contactable';
  $email = 'Staff.Staff_email_on_website';
  $mobile = 'Staff.Staff_mobile_on_website';
  $phone = 'Staff.Staff_phone_on_website';

  $contact = \Civi\Api4\Contact::get()
  ->addSelect($contactable, $email, $mobile, $phone)
    ->addWhere('id', '=', $id)
    ->addWhere('contact_sub_type', '=', 'Staff')
    ->setLimit(1)
    ->setCheckPermissions(FALSE)
    ->execute()
    ->first();

  return [
    'contactable' => $contact[$contactable] ?? false,
    'email' => $contact[$email] ?? false,
    'mobile' => $contact[$mobile] ?? false,
    'phone' => $contact[$phone] ?? false,
  ];
}
