<?php

/*
 *  This hook is called when an email is about to be sent by CiviCRM.
 *  It ensures the email contains no relative links.
 *  It adds the closing tags for the BODY and HTML elements, as these are
 *  left off so CiviMail can add a tracking token to the email.
 */
function cbf_civicrm_civicrm_alterMailParams( &$params, $context = null ) {
  // Don't send event confirmations when a Pending attendee is marked as Attended after the event
  $now = date('Y-m-d G:i:s');
  if (isset($params['valueName']) && $params['valueName'] == 'event_online_receipt'
    && isset($params['tplParams']['participant_status']) && $params['tplParams']['participant_status'] == 'Attended'
    && isset($params['tplParams']['event']['is_pay_later']) && $params['tplParams']['event']['is_pay_later'] == 1
    && isset($params['tplParams']['event']['end_date']) && $params['tplParams']['event']['end_date'] < $now) {
    $params['abortMailSend'] = 1;
    return;
  }

  $htmlMessage = CRM_Utils_Array::value( 'html', $params );
  if ( $htmlMessage ) {

    /*
     *  Change relative URLs to absolute.
     *  Links:  Relative URLs start with a '/' and occur in the HREF attribute of an A element
     *  Images: Relative URLs start with a '/' and occur in the SRC attribute of an IMG element
     *  The '/' is replaced by the CiviCRM User Framework Base URL, which terminates with a '/'
     */
    $config = CRM_Core_Config::singleton( );
    $htmlMessage = str_replace(' href="//', ' href="http://', $htmlMessage);
    $htmlMessage = str_replace(' src="//',  ' src="http://',  $htmlMessage);
    $htmlMessage = str_replace(' href="/',  ' href="'.$config->userFrameworkBaseURL, $htmlMessage);
    $htmlMessage = str_replace(' src="/',   ' src="'.$config->userFrameworkBaseURL,  $htmlMessage);

    /*
     *  Remove empty paragraphs and non-breaking spaces inserted by CKeditor
     */
    $htmlMessage = preg_replace('!<p>(\r\n\t)*&nbsp;</p>!i', '', $htmlMessage);
    $htmlMessage = preg_replace('!&nbsp;!i', ' ', $htmlMessage);

    /*
     * The CKeditor Image Dialog removes width attributes from HTML IMGs. This causes an issue
     * for responsive email templates when the email is viewed in Outlook. As these images have
     * a CSS style setting their width or max-width to 280px, we reinsert the HTML attribute on
     * images that match that pattern.
     */
    $htmlMessage = preg_replace('!<img ([^w/>][^>]+width: 280px[^>]+)/>!i', '<img width="280" $1/>', $htmlMessage);

    /*
     * The HTML IMGs that have been set to 280px wide will not scale properly if the height
     * attribute is set. We remove that.
     */
    $htmlMessage = preg_replace('!<img width="280" ([^>]+)height: [0-9px%]+[;]?([^>]+)/>!i', '<img width="280" $1$2/>', $htmlMessage);

    /*
     * Look for the closing tag for the BODY element, and add it if needed
     */
    if (stripos($htmlMessage, '</body>') === false) {
      $htmlMessage .= '</body></html>';
    }

    /*
     * Ensure the email has a Title in its title-field, and that if on-line
     * receipts have a title of 'Contribution' give them something better
     */
    if (isset($params['subject'])) {
      if (isset($params['tplParams'])) {
        if (!isset($params['tplParams']['title'])) {
          $htmlMessage = preg_replace('!class="title-field">  </p>!i', 'class="title-field"> ' . $params['subject'] . ' </p>', $htmlMessage);
        } elseif ($params['tplParams']['title'] == 'Contribution' && isset($params['valueName']) && $params['valueName'] == 'contribution_online_receipt') {
          $htmlMessage = preg_replace('!class="title-field"> Contribution </p>!i', 'class="title-field"> ' . $params['subject'] . ' </p>', $htmlMessage);
        }
      }
    }

    /*
     * Replace the '<tax-invoice/>' HTML element with the Tax Invoice text.
     * This is usually empty, except for event registrations and contributions
     * for Event Fees and Sales.
     */
    $taxInvoice = '<tr><td>This email serves as a Tax Invoice. Amounts quoted include GST.</td></tr>';
    $isTaxInvoice = FALSE;
    if (isset($params['valueName'])) {
      switch ($params['valueName']) {
        case 'contribution_offline_receipt':
        case 'contribution_online_receipt':
          if (isset($params['tplParams']['contributionTypeName'])) {
            $financialType = $params['tplParams']['contributionTypeName'];
          }
          else {
            try {
              $contribution = civicrm_api3('Contribution', 'get', array(
                'sequential' => 1,
                'id' => $params['contributionId'],
              ));
              $financialType = $contribution['values'][0]['financial_type'];
            } catch (CiviCRM_API3_Exception $e) {
              $financialType = '';
            }
          }
          switch ($financialType) {
            case 'Event Fee':
            case 'Sales':
              $isTaxInvoice = TRUE;
              break;
          }
          break;

        case 'event_offline_receipt':
        case 'event_online_receipt':
          $isTaxInvoice = TRUE;
          break;
      }
    }
    $htmlMessage = preg_replace('!<tax-invoice/>!i', $isTaxInvoice ? $taxInvoice : '', $htmlMessage);

    /*
     * There are occasions when CiviCRM uses an online contribution receipt for
     * offline purposes. In that case there is no contribution page, so certain
     * items won't appear on the receipt. The custom field logic is copied from
     * CRM_Contribute_Form_AdditionalInfo::emailReceipt() and the other items
     * from the contribution_online_receipt template.
     */
    if (isset($params['valueName'])) {
      switch ($params['valueName']) {
        case 'contribution_online_receipt':
          if (stripos($htmlMessage, '<no-contribution-page/>') !== false) {
            $noContributionPage = _cbf_civicrm_civicrm_no_contribution_page($params);
            $htmlMessage = preg_replace('!<no-contribution-page/>!i', $noContributionPage, $htmlMessage);
          }
          break;
      }
    }

    /*
     * When sending a single email, remove the 'civimailBlock' from the HTML part.
     * This allows email templates to be used for CiviMails and for sending emails.
     */
    if ($context == 'singleEmail') {
      $htmlMessage = preg_replace('#<!-- civimailBlock -->.*<!-- /civimailBlock -->#is', '', $htmlMessage);
    }

    $params['html'] = $htmlMessage;
  }
}

function _cbf_civicrm_civicrm_no_contribution_page($params) {
  $headerFormat = '"text-align: left; padding: 4px; border-bottom: 1px solid #999; background-color: #eee;"';
  $labelFormat = '"padding: 4px; border-bottom: 1px solid #999; background-color: #f7f7f7;"';
  $dataFormat = '"padding: 4px; border-bottom: 1px solid #999;"';
  $result = '';
  $form = null;

  try {
    $contribution = civicrm_api3('Contribution', 'get', array(
      'sequential' => 1,
      'id' => $params['tplParams']['contributionID'],
    ));
    if ($contribution['is_error'] || $contribution['count'] != 1) {
      return $result;
    }
    $contributionInfo = array(
      'Financial Type' => $contribution['values'][0]['financial_type'],
      'Receipt Date' => $contribution['values'][0]['receipt_date'],
      'Paid By' => $contribution['values'][0]['payment_instrument'],
//      'Transaction ID' => $contribution['values'][0]['trxn_id'],
    );
    if (!empty($contributionInfo['Receipt Date'])) {
      $config = CRM_Core_Config::singleton();
      $contributionInfo['Receipt Date'] = CRM_Utils_Date::customFormat($contributionInfo['Receipt Date'], $config->dateformatFull);
    }
    foreach ($contributionInfo as $label => $data) {
      if (!empty($data)) {
        $result .= "<tr><td style=$labelFormat>$label</td><td style=$dataFormat>$data</td></tr>";
      }
    }
    // Assume this receipt is being sent to an anonymous user. This code emulates
    // CRM_Core_Permission::customGroup() being called for an anonymous user, and
    // assumes that anonymous users are not granted the 'access all custom data'
    // permission. Anonymous users are only shown public custom data groups.
    $customGroups = array();
    $publicGroups = CRM_ACL_BAO_ACL::group(
      CRM_Core_Permission::VIEW,
      0,
      'civicrm_custom_group',
      CRM_Core_PseudoConstant::get('CRM_Core_DAO_CustomField', 'custom_group_id', array('fresh' => false))
    );
    $groupTree = CRM_Core_BAO_CustomGroup::getTree('Contribution', $form);
    foreach ($groupTree as $groupID => $group) {
      if ($groupID == 'info') {
        continue;
      } elseif (in_array($groupID, $publicGroups) === false) {
        continue;
      }
      $customGroups[$group['title']] = array();
      $nonEmpty = 0;
      foreach ($group['fields'] as $k => $field) {
        if (!empty($contribution['values'][0]["custom_{$k}"])) {
          if ($k == 26) {
            $ministry_centre = civicrm_api3('OptionValue', 'getvalue', array(
              'sequential' => 1,
              'option_group_id' => 329,
              'value' => $contribution['values'][0]["custom_{$k}"],
              'return' => 'label',
            ));
            $customGroups[$group['title']][$field['label']] = $ministry_centre;
          } else {
            $customGroups[$group['title']][$field['label']] = $contribution['values'][0]["custom_{$k}"];
          }
          $nonEmpty++;
        } else {
          $customGroups[$group['title']][$field['label']] = '';
        }
      }
      if ($nonEmpty == 0) {
        unset($customGroups[$group['title']]);
      }
    }
    foreach ($customGroups as $groupTitle => $group) {
      $result .= "<tr><th colspan=\"2\" style=$headerFormat>$groupTitle</th></tr>";
      foreach ($group as $label => $data) {
        $result .= "<tr><td style=$labelFormat>$label</td><td style=$dataFormat>$data</td></tr>";
      }
    }
  } catch (Exception $e) {
    ;
  }
  return $result;
}

/*
 * This hook is called when a form is being built by CiviCRM.
 * It adds the Credit Card Holder to credit card payment forms, and makes the holder
 * field available on confirmation and thank-you pages. This doesn't work for the
 * event forms since they protect their _param variables.
 * It makes the Billing Name and Address not-required, as these are not presented
 * on CBF payment forms.
 */
function cbf_civicrm_civicrm_buildForm( $formName, &$form ) {
  switch ($formName) {

    case 'CRM_Contribute_Form_Contribution':
    case 'CRM_Contribute_Form_Contribution_Main':
    case 'CRM_Event_Form_Participant':
    case 'CRM_Event_Form_Registration_Register':
    case 'CRM_Financial_Form_Payment':
      if (user_is_anonymous() && isset($_SESSION['CiviCRM']['status'][0]['text'])) {
        $status_text = $_SESSION['CiviCRM']['status'][0]['text'];
        if (stristr($status_text, 'Payment Processor Error') !== false) {
          if (stristr($status_text, '9001') !== false) {
            if (isset($_SESSION['City Bible Forum']['Card issues'])) {
              $_SESSION['City Bible Forum']['Card issues']++;
            } else {
              $_SESSION['City Bible Forum']['Card issues'] = 1;
            }
          }
        }
      }

      if (isset($_SESSION['City Bible Forum']['Card issues']) && $_SESSION['City Bible Forum']['Card issues'] > 5) {
        CRM_Utils_System::redirect(CRM_Utils_System::url('full-stop.html'));
      }

      // End users are getting confused when they enter email addresses with an additional space
      // To avoid this we trim submitted email addresses
      foreach ($form->getSubmitValues() as $field => $value) {
        if (strpos($field, 'email-') !== FALSE) {
          $form->applyFilter($field, 'trim');
        }
      }

      // Add a form element for the credit card holder
      // It is required if the credit card number is required
      if ($form->elementExists('credit_card_number') && !$form->elementExists('credit_card_holder')) {
        $form->add (
          'text',
          'credit_card_holder',
          ts('Card Holder'),
          array (
            'size' => 20,
            'maxlength' => 30,
            'autocomplete' => 'off' ),
          $form->isElementRequired('credit_card_number'),
          null);
      }

      // Assume the person's first and last name are being captured via a profile
      // Make the address optional so donors have less data to supply
      if (isset($form->_bltID)) {
        $bltID = $form->_bltID;
        $unnecessaryFields = array(
          "billing_first_name",
          "billing_last_name",
          "billing_street_address-{$bltID}",
          "billing_city-{$bltID}",
          "billing_postal_code-{$bltID}",
          "billing_state_province_id-{$bltID}",
          "billing_country_id-{$bltID}"
        );
        $form->_required = array_diff($form->_required, $unnecessaryFields);
        foreach ($unnecessaryFields as $field) {
          if ( isset($form->_paymentFields[$field]) ) {
            $form->_paymentFields[$field]['is_required'] = false;
          }
        }
      }

      if ($formName == 'CRM_Contribute_Form_Contribution_Main' && $form->elementExists('buttons') ) {
        $buttons = $form->getElement('buttons');
        $submit = $buttons->getElements();
        $submit[0]->setValue('Next >>');
      }

      // Prevent the user from editing their name or email during
      // online donations or registrations
      switch ($formName) {
        case 'CRM_Contribute_Form_Contribution_Main':
        case 'CRM_Event_Form_Registration_Register':
          $protect = array(
            'first_name',
            'last_name',
            'email-5',    // Billing email, donation form
            'email-6',    // Primary email, registration form
            'phone-6-2',  // Primary mobile, registration form
          );
          foreach ($protect as $i) {
            if ($form->elementExists($i) && !empty($form->_defaultValues[$i])) {
              $form->getElement($i)->freeze();
            }
          }
          break;
      }

      break;

    case 'CRM_Contribute_Form_Contribution_Confirm':
    case 'CRM_Contribute_Form_Contribution_ThankYou':
    case 'CRM_Event_Form_Registration_Confirm':
    case 'CRM_Event_Form_Registration_ThankYou':
      // Set the Credit Card Holder in the Smarty template
      // Clear the Address in the Smarty template
      $tpl = $form->getTemplate();
      $tpl_credit_card_number = $tpl->get_template_vars('credit_card_number');
      if ( isset($tpl_credit_card_number) ) {
        if ( isset($form->_params['credit_card_holder']) ) {
          $form->assign( 'credit_card_holder', $form->_params['credit_card_holder'] );
        }
        else if (isset($form->_params[0]) && isset($form->_params[0]['credit_card_holder'])) {
          $form->assign( 'credit_card_holder', $form->_params[0]['credit_card_holder'] );
        }
      }
      $form->assign( 'address', '' );

      if ($formName == 'CRM_Contribute_Form_Contribution_Confirm' && $form->elementExists('buttons')) {
        $makePaymentLabel = 'Make payment';

        $buttons = $form->getElement('buttons');
        $submit = $buttons->getElements();
        $submit[0]->setValue($makePaymentLabel);

        $tpl->assign('button', $makePaymentLabel);
      }

      // Add participants who elect for future communications to the
      // appropriate list
      if ($formName == 'CRM_Event_Form_Registration_ThankYou') {
        if (isset($form->_params[0]['custom_28']) && $form->_params[0]['custom_28'] == 1) {
          _cbf_civicrm_civicrm_add_to_list_via_entity(
            $form->_values['participant']['contact_id'],
            'civicrm_event',
            $form->_values['participant']['event_id'],
            45); // 'Events like this' list
        }
        if (isset($form->_params[0]['custom_29']) && $form->_params[0]['custom_29'] == 1) {
          _cbf_civicrm_civicrm_add_to_list_via_entity(
            $form->_values['participant']['contact_id'],
            'civicrm_event',
            $form->_values['participant']['event_id'],
            46); // 'News and updates' list
        }
      }
      break;

    case 'CRM_Mailing_Form_Upload':
      // For CiviMails, unset the From email address when the Subject is empty.
      // This is a roundabout way of unsetting the CiviMail default, to force
      // the user to enter an From address.
      if ( $form->getElementValue('subject') == null ) {
        $fromAddress = $form->getElement('from_email_address');
        $fromAddress->setSelected(0);
      }
      break;
  }
}

/*
 * This function is called when a form is being validated by CiviCRM.
 * In cases where the Credit Card Holder field is not-required, it is mandatory if the
 * Credit Card Number has been entered.
 */
function cbf_civicrm_civicrm_validateForm( $formName, &$fields, &$files, &$form, &$errors ) {
  switch ($formName) {

    case 'CRM_Contribute_Form_Contribution':
    case 'CRM_Contribute_Form_Contribution_Main':
    case 'CRM_Event_Form_Participant':
    case 'CRM_Event_Form_Registration_Register':
      /*
       * The credit card holder is required for credit card transactions.
       * Assume that a credit card payment is being made if the CC number
       * is supplied. This test is only required if the Card Holder field
       * exists and is not a required field.
       */
      if ($form->elementExists('credit_card_holder') && !$form->isElementRequired('credit_card_holder')) {
        $credit_card_number = CRM_Utils_Array::value('credit_card_number', $fields);
        $credit_card_holder = CRM_Utils_Array::value('credit_card_holder', $fields);
        if ($credit_card_number && !$credit_card_holder) {
          $errors['credit_card_holder'] = ts('Card Holder is required if Card Number is supplied');
        }
      }
      /*
       * Online event registrations:
       *
       * Prevent visitors mistakenly entering the cost of a Price Set field,
       * rather than the number of participants. We do this by putting a
       * limit on the number that can be selected.
       * 
       * Also, prevent visitors trying to register without selecting any
       * options from a Price Set.
       */
      if ($formName == 'CRM_Event_Form_Registration_Register') {
        if (!empty($form->_priceSetId)) {
          $registrationLimit = 20;
          $optionSelected = false;
          $publicField = false;
          foreach ($form->_priceSet['fields'] as $priceSetFieldId => $priceSetField) {
            $submit = "price_$priceSetFieldId";
            if (!empty($form->_submitValues[$submit])) {
              $optionSelected = true;
              $participantCount = current($priceSetField['options'])['count'];
              if (
                !empty($priceSetField['is_display_amounts']) &&
                !empty($priceSetField['is_enter_qty']) &&
                !empty($participantCount) &&
                $form->_submitValues[$submit] > $registrationLimit
              ) {
                $errors[$submit] = ts('To protect our visitors, registrations are limited to ') . $registrationLimit . ts('. To register more, either make a separate registration or contact our office.');
              }
            }
            if ($publicField === false && $priceSetField['visibility'] == 'public') {
              $publicField = $submit;
            }
          }
          if ($optionSelected === false) {
            $errors[($publicField === false) ? $submit : $publicField] = ts('No registration options appear to have been selected');
          }
        }
      }
      break;

    case 'CRM_Contact_Import_Form_DataSource':
      // The dedupe rule is needed, except when 'No Duplicate Checking' is selected
      $onDuplicate = CRM_Utils_Array::value( 'onDuplicate', $fields );
      foreach ($form->getElement('onDuplicate')->getElements() as $duplicateOption ) {
        if ($duplicateOption->getValue() == $onDuplicate) {
          break; // We've found the option that's been selected
        }
      }
      if ($duplicateOption->getText() <> 'No Duplicate Checking') {
        if (CRM_Utils_Array::value( 'dedupe', $fields ) == '') {
          $errors['dedupe'] = ts('Dedupe rule must be set, unless there is no duplicate checking');
        }
      }
      break;

    case 'CRM_Event_Form_ManageEvent_EventInfo':
      // Ensure the End date is set for Events that are not templates
      $isTemplate = CRM_Utils_Array::value('is_template', $fields);
      $start = CRM_Utils_Date::processDate(CRM_Utils_Array::value('start_date', $fields), CRM_Utils_Array::value('start_date_time', $fields));
      $end = CRM_Utils_Date::processDate(CRM_Utils_Array::value('end_date', $fields), CRM_Utils_Array::value('end_date_time', $fields));
      if (empty($isTemplate)) {
        if (empty($end)) {
          $errors['end_date'] = ts('End Date and Time are required fields');
        }
        elseif ($end <= $start) {
          $errors['end_date'] = ts('End date should be after Start date');
        }
      }
      break;

    case 'CRM_Export_Form_Select':
      /*
       * Selecting the 'Export PRIMARY fields' option for many contacts will
       * create multi-Gb temporary files. Reject this option.
       */
      $exportOption = CRM_Utils_Array::value('exportOption', $fields);
      if ($exportOption == 1) {
        $errors['exportOption'] = ts('Exporting Primary fields on large numbers of contacts can crash the web server. Select the fields you want to export.');
      }
      break;
  }
}

/*
 * This function is called before CiviCRM passes payment details to a Payment Processor.
 * The Credit Card Holder is captured.
 * The Purchaser Address details are cleared, since the Billing Address is not captured.
 */
function cbf_civicrm_civicrm_alterPaymentProcessorParams( $paymentObj, &$rawParams, &$cookedParams ) {
  $is_recur           = CRM_Utils_Array::value('is_recur',           $rawParams);
  $credit_card_holder = CRM_Utils_Array::value('credit_card_holder', $rawParams);
  if (isset($is_recur) && $is_recur) {
    if ($paymentObj instanceof org_civicrm_ewayrecurring) {
      // Set credit card holder
      if ($credit_card_holder) {
        $cookedParams['CCNameOnCard'] = $credit_card_holder;
      }
      // Set address
      $cookedParams['Address']  = 'c/o Level 3, 13-15 Bridge St';
      $cookedParams['Suburb']   = 'Sydney';
      $cookedParams['State']    = 'NSW';
      $cookedParams['PostCode'] = '2000';
    }
    else if ($paymentObj instanceof com_chrischinchilla_ewayrecurring || $paymentObj instanceof CRM_Core_Payment_Ewayrecurring) {
      // Set credit card holder
      if ($credit_card_holder) {
        $cookedParams['man:CCNameOnCard'] = $credit_card_holder;
      }
      // Set address
      $cookedParams['man:Address']  = 'c/o Level 3, 13-15 Bridge St';
      $cookedParams['man:Suburb']   = 'Sydney';
      $cookedParams['man:State']    = 'NSW';
      $cookedParams['man:PostCode'] = '2000';
    }
  }
  else {
    if ($paymentObj instanceof CRM_Core_Payment_eWAY  ||
        $paymentObj instanceof org_civicrm_ewayrecurring  ||
        $paymentObj instanceof com_chrischinchilla_ewayrecurring ||
        $paymentObj instanceof CRM_Core_Payment_Ewayrecurring) {
      // Set credit card holder
      if ($credit_card_holder) {
        $cookedParams->CardHolderName($credit_card_holder);
      }
      // Clear address information
      $cookedParams->PurchaserAddress('');
      $cookedParams->PurchaserPostalCode('');
    }
  }
}

function cbf_civicrm_civicrm_tokens( &$tokens ) {
  $tokens['cbf'] = array('cbf.hostname');
}

function cbf_civicrm_civicrm_tokenValues( &$details, &$contactIDs ) {
  $config = CRM_Core_Config::singleton( );
  $hostname = preg_replace('!^https?://([^/]+)/$!i', '$1', $config->userFrameworkBaseURL);
  if (is_array($contactIDs)) {
    foreach ($details as $id => $detail) {
      $details[$id]['cbf.hostname'] = $hostname;
    }
  }
  else {
    $details['cbf.hostname'] = $hostname;
  }
}

/*
 * Modify API permissions ...
 *  * Allow users with 'edit contributions' permission to create
 *    civicrm_account_contact records. This allows them to queue contacts to
 *    sync with Xero (from the Contact Summary screen).
 *  * Allow users who are editing events to set the payment processor. To do
 *    this they need to execute 'getlist' and 'get'. The permission needed is
 *    either 'administer CiviCRM' (the default) or 'edit all events'.
 *  * Allow users to modify price fields
 *  * Allow users to access the CSV Import Helper objects
 */
function cbf_civicrm_civicrm_alterAPIPermissions($entity, $action, &$params, &$permissions) {
  $permissions['account_contact']['create'] = array('access CiviCRM', 'edit contributions');
  $permissions['payment_processor']['getlist'] =
  $permissions['payment_processor']['get'] = array(
    array(
      'administer CiviCRM',
      'edit all events',
    ));
  $permissions['price_field']['create'] =
  $permissions['price_field']['update'] =
  $permissions['price_field_value']['create'] =
  $permissions['price_field_value']['update'] = array(
    array(
      'administer CiviCRM',
      'edit all events',
      'edit contributions',
    ));
  $permissions['csv_helper']['default'] = array('access CiviCRM');
}

/*
 * Add extra variables to help with debugging, then return false so
 * the standard error handling continues.
 */
function cbf_civicrm_fatal_error_handler(&$vars) {
  if ( isset($_SERVER['HTTP_X_FORWARDED_FOR']) ) {
    $vars['ip']  = $_SERVER['HTTP_X_FORWARDED_FOR'];
    $vars['url'] = $_SERVER['HTTP_X_FORWARDED_PROTO'] . '://' . $_SERVER['HTTP_X_HOST'] . $_SERVER['REQUEST_URI'];
  }
  else {
    $vars['ip']  = $_SERVER['REMOTE_ADDR'];
    $vars['url'] = $_SERVER['REQUEST_SCHEME'] . '://' . $_SERVER['SERVER_NAME'] . $_SERVER['REQUEST_URI'];
  }
  $vars['agent']  = $_SERVER['HTTP_USER_AGENT'];

  /*
   * There are a number of annoying errors that get logged. They seem to be due to
   * robots etc. The $ignore array stores the patterns that should be ignored.
   *
   * The $ignore array consists of a number of pattern sets. Each set is matched
   * against elements of the $vars array. If all the patterns in a set match, we
   * simply return 'true'. This tells CiviCRM to abend processing, and nothing
   * is logged.
   *
   * Note that the preg_match uses '#' as a pattern delimiter so this should not
   * be used in a pattern in $ignore.
   */
  $ignore = array(
    array(
      'message' => 'Invalid value passed to getPayment function',
      'url' => '/civicrm/event/register.*id=[0-9][0-9][0-9]($|[^0-9])',
    ),
    array(
      'message' => 'id .* POST .* GET .* is not of the type Positive',
    ),
    array(
      'message' => 'Invalid form parameters',
      'url' => '/civicrm/mailing/forward$',
    ),
    array(
      'message' => 'Missing (input )?parameters',
      'url' => '/civicrm/mailing/(optout|unsubscribe)$',
    ),
    array(
      'agent' => 'detectify\.com',
    ),
    array(
      'message' => 'Error type: Could not find a valid session key',
    ),
  );

  foreach ($ignore as $patternSet) {
    foreach ($patternSet as $element => $pattern) {
      if (preg_match('#' . $pattern . '#i', $vars[$element]) != 1) {
        continue 2;
      }
    }
    return true;
  }

  $vars['ip-details'] = json_decode(file_get_contents("http://ipinfo.io/" . $vars['ip'] . "/json"));
  if (isset($_SESSION)) {
    $vars['session'] = $_SESSION;
    unset($vars['session']['csrf_token_seed']);
    unset($vars['session']['CiviCRM']['qfPrivateKey']);
  }

  return false;
}

/*
 * Implementation of hook_civicrm_pre() to capture changes before they're saved
*/
function cbf_civicrm_civicrm_pre( $op, $objectName, $id, &$params ) {
  /*
   * Whenever an Archived_team ("Past team") is created or edited, ensure
   * its name includes 'No longer meets: ' and its relationships are
   * inactive.
   */
  if ($objectName == 'Household') {
    switch ($op) {
      case 'create':
      case 'edit':
        foreach ($params['contact_sub_type'] as $sub_type) {
          if ($sub_type == 'Archived_team') {
            $archived_team_prefix = 'No longer meets: ';

            if (strpos($params['household_name'], $archived_team_prefix) === false) {
              $params['household_name'] = $archived_team_prefix . $params['household_name'];
            }

            try {
              $get_a = civicrm_api3('Relationship', 'get', array(
                'sequential' => 1,
                'contact_id_a' => $id,
                'is_active' => 1,
              ));
              $get_b = civicrm_api3('Relationship', 'get', array(
                'sequential' => 1,
                'contact_id_b' => $id,
                'is_active' => 1,
              ));
              $get = array_merge($get_a['values'], $get_b['values']);

              foreach ($get as $relationship) {
                $arguments = array(
                  'sequential' => 1,
                  'id' => $relationship['id'],
                  'is_active' => 0,
                );

                if (!isset($relationship['end_date'])) {
                  $arguments['end_date'] = CRM_Utils_Date::getToday();
                }

                $result = civicrm_api3('Relationship', 'create', $arguments);
              }

            } catch (CiviCRM_API3_Exception $e) {
              ;
            }
          }
        }
        break;
    }
  }

  /*
   * The payment_processor field on the civicrm-event-form doesn't support
   * multiselect, but we want people to be able to choose to pay via credit
   * card or PayPal.
   *
   * Until this is resolved, ignore input from this field on this form. This
   * is signalled by cbf__civicrm_entity_form_submit() which sets the
   * payment_processor to be one that is never used. It's name is 'Hack for
   * CiviCRM Event entities' and its number is 15.
   */
  if ($objectName == 'Event') {
    switch ($op) {
      case 'create':
      case 'edit':
        $dummyPaymentProcessor = '15';
        if ($params['payment_processor'] == $dummyPaymentProcessor) {
          unset($params['payment_processor']);
        }
        break;
    }
  }
}

/*
 * Implementation of hook_civicrm_post() which is called after a db write on some core objects
*/
function cbf_civicrm_civicrm_post( $op, $objectName, $id, &$params ) {
  switch ($objectName) {
    case 'Participant':
      _cbf_civicrm_civicrm_post_participant($op, $id, $params);
      break;
  }
}

function _cbf_civicrm_civicrm_add_to_list_via_entity($contactId, $entityTable, $entityId, $fieldNumber) {
  try {
    $custom_values = civicrm_api3('CustomValue', 'get', array(
      'sequential' => 1,
      'entity_id' => $entityId,
      'entity_table' => $entityTable,
      'id' => $fieldNumber,
    ));

    $listId = null;

    foreach ($custom_values['values'] as $custom_value) {
      if (isset($custom_value['latest']) && isset($custom_value['id']) && $custom_value['id'] == $fieldNumber) {
        $listId = (int) $custom_value['latest'];
        break;
      }
    }

    if ($listId > 0) {
      $result = civicrm_api3('GroupContact', 'create', array(
        'sequential' => 1,
         'contact_id' => $contactId,
         'status' => 'Added',
         'group_id' => $listId,
      ));
    }
  } catch (Exception $e) {
    return;
  }
}

function _cbf_civicrm_civicrm_post_participant($op, $id, &$params) {
  switch ($op) {
    /*
     * Whenever a Participant is created, ensure the contact has a Ministry
     * Centre tag. If it doesn't, add a tag that corresponds to the Ministry
     * Centre of the event.
     */
    case 'create':
      try {
        if (_cbf_civicrm_civicrm_contact_has_ministry_centre($params->contact_id)) {
          break;
        }

        list($tagId, $name) = _cbf_civicrm_civicrm_event_ministry_centre($params->event_id);

        if ($tagId !== FALSE) {
          $create = civicrm_api3('EntityTag', 'create', array(
            'sequential' => 1,
            'entity_table' => 'civicrm_contact',
            'entity_id' => $params->contact_id,
            'tag_id' => $tagId,
          ));
        }
      } catch (CiviCRM_API3_Exception $e) {
        ;
      }
      break;
  }
}

/*
 * Originally intended this function to be called like _cbf_civicrm_civicrm_post_participant
 * but the desired functionality didn't work due to timing - the post hook was called before
 * the City was attached to the Contribution.
 *
 * So the 3rd argument was changed for convenience, and this function is now called when an
 * Account Invoice is being sent to Xero.
 */
function _cbf_civicrm_civicrm_post_contribution($op, $id, $contact_id) {
  switch ($op) {
    /*
     * Whenever a Contribution is created, ensure the contact has a Ministry
     * Centre tag. If it doesn't, add a tag that corresponds to the City they
     * entered.
     */
    case 'create':
      try {
        if (_cbf_civicrm_civicrm_contact_has_ministry_centre($contact_id)) {
          break;
        }

        $ministry_centre = _cbf_civicrm_civicrm_contribution_ministry_centre($id);

        if ($ministry_centre !== FALSE) {
          $create = civicrm_api3('EntityTag', 'create', array(
            'sequential' => 1,
            'entity_table' => 'civicrm_contact',
            'entity_id' => $contact_id,
            'tag_id' => $ministry_centre,
          ));
        }
      } catch (CiviCRM_API3_Exception $e) {
        ;
      }
      break;
  }
}

function _cbf_civicrm_civicrm_contact_has_ministry_centre($contact_id) {
  $ministry_centre_prefix = 'Ministry centre is ';

  $entity_tags = civicrm_api3('EntityTag', 'get', array(
    'sequential' => 1,
    'entity_table' => 'civicrm_contact',
    'entity_id' => $contact_id,
  ));

  foreach ($entity_tags['values'] as $entity_tag) {
    $tag = civicrm_api3('Tag', 'get', array(
      'sequential' => 1,
      'id' => $entity_tag['tag_id'],
      'return' => 'name',
    ));

    if (stristr($tag['values'][0]['name'], $ministry_centre_prefix) !== false) {
      return TRUE;
    }
  }

  return FALSE;
}

function _cbf_civicrm_civicrm_event_ministry_centre($event_id) {
  $ministry_centre_group_id = 326;
  $ministry_centre_prefix = 'Ministry centre is ';

  try {
    $custom_values = civicrm_api3('CustomValue', 'get', array(
      'sequential' => 1,
      'entity_id' => $event_id,
      'entity_table' => 'civicrm_event',
      'id' => 25,
    ));

    $ministry_centre_id = null;

    foreach ($custom_values['values'] as $custom_value) {
      if (isset($custom_value['latest']) && isset($custom_value['id']) && $custom_value['id'] == 25) {
        $ministry_centre_id = (int) $custom_value['latest'];
        break;
      }
    }

    if ( ! isset($ministry_centre_id) ) {
      return array(FALSE, FALSE);
    }

    $ministry_centre = civicrm_api3('OptionValue', 'getvalue', array(
      'sequential' => 1,
      'option_group_id' => $ministry_centre_group_id,
      'value' => $ministry_centre_id,
      'return' => 'label',
    ));

    $tag = civicrm_api3('Tag', 'getvalue', array(
      'sequential' => 1,
      'name' => $ministry_centre_prefix . $ministry_centre,
      'return' => 'id',
    ));

    return array($tag, $ministry_centre);
 
  } catch (CiviCRM_API3_Exception $e) {
    return array(FALSE, FALSE);
  }
}

function _cbf_civicrm_civicrm_contribution_ministry_centre($contribution_id) {
  $ministry_centre_prefix = 'Ministry centre is ';

  try {
    // Since the City value is publicly visible, no need to use CustomValue API
    $city = civicrm_api3('Contribution', 'getvalue', array(
      'sequential' => 1,
      'return' => 'custom_26',
      'id' => $contribution_id,
    ));

    if (empty($city)) {
      return FALSE;
    }

    $tags = civicrm_api3('Tag', 'get', array(
      'sequential' => 1,
      'return' => 'id,name',
    ));

    foreach ($tags['values'] as $tag) {
      if (stristr($tag['name'], $ministry_centre_prefix . $city) !== FALSE) {
        return $tag['id'];
      }
    }
  } catch (CiviCRM_API3_Exception $e) {
    ;
  }

  return FALSE;
}

/*
 * A hook that gets called by the AccountSync extension, prior to pulling data
 * from Xero.
 *
 * @param string $entity entity - eg. 'contact'
 * @param array $data data from accounts being processing
 * @param bool $save save? - set this to false if it should be skipped
 * @param $params
 *
 * @return mixed
 *   Ignore value.
 */
function cbf_civicrm_civicrm_accountPullPreSave($entity, &$data, &$save, &$params) {
  switch ($entity) {
    case 'contact':
      break;

    case 'invoice':
      // Don't try to pull Invoices when the Contribution Id is not numeric
      if (isset($params['contribution_id']) && !is_numeric($params['contribution_id'])) {
        $save = FALSE;
      }
      break;
  }
}


/*
 * A hook that gets called by the AccountSync extension, prior to pushing data
 * to Xero.
 *
 * @param string $entity entity - eg. 'contact'
 * @param array $data data from accounts being processing
 * @param bool $save save? - set this to false if it should be skipped
 * @param $params
 *
 * @return mixed
 *   Ignore value.
 */
function cbf_civicrm_civicrm_accountPushAlterMapped($entity, &$data, &$save, &$params) {
  switch ($entity) {
    case 'contact':
      // Remove prefixes etc from Contact name
      if ($data['contact_type'] == 'Individual') {
        $params['Name'] = $data['first_name'] . ' ' . $data['last_name'] . ' - ' . $data['contact_id'];
      }
      // Highlight deleted contacts in Xero
      $deletedSuffix = ' (deleted in CiviCRM)';
      if (!empty($data['contact_is_deleted']) && stristr($params['Name'], $deletedSuffix) === false) {
        $params['Name'] .= $deletedSuffix;
      }
      break;

    case 'invoice':
      // Ensure the contact has a Ministry Centre tag
      _cbf_civicrm_civicrm_post_contribution('create', $data['contribution_id'], $data['contact_id']);

      /* Baulk if
       *  - the Suppress Xero Invoice is set
       *  - the contribution is a test
       *  - the contribution is zero-valued
       */
      if (!empty($data['custom_43']) || $data['is_test'] != '0' || $data['total_amount'] == '0.00') {
        $save = FALSE;
        break;
      }

      // Include the Transaction Id in the Invoice reference
      if (!empty($data['trxn_id'])) {
        $params['Reference'] = $data['trxn_id'] . ' - ' . $params['Reference'];
      }

      // Ensure there is at least one Line Item in the Invoice
      if (empty($params['LineItems']['LineItem'])) {
        $accountCode = CRM_Accountsync_BAO_AccountInvoice::getAccountCode($data['financial_type_id']);
        if (empty($accountCode)) {
          $accountCode = civicrm_api('setting', 'getvalue', array(
            'group' => 'Xero Settings',
            'name' => 'xero_default_revenue_account',
            'version' => 3,
          ));
        }
        $params['LineItems']['LineItem'][] = array(
          'Description' => 'Amount',
          'Quantity' => '1.00',
          'UnitAmount' => $data['total_amount'],
          'AccountCode' => $accountCode,
        );
        $data['line_items'][] = array('label' => 'Amount');
      }

      // Process each Line Item
      $lineItemKeys = array_keys($data['line_items']);
      foreach ($params['LineItems']['LineItem'] as $key => $lineitem) {
        $local = $data['line_items'][$lineItemKeys[$key]];

        // Remove some gumph from the Description
        $params['LineItems']['LineItem'][$key]['Description'] = $local['label'];

        // Set the Account Code for recurring contributions
        if (!empty($data['contribution_recur_id'])) {
          $params['LineItems']['LineItem'][$key]['AccountCode'] = '40110';
        }

        // Capture the City tracking category. This may be supplied for
        // Contributions, but can be derived from the Event's ministry
        // centre.
        if (!empty($data['custom_26'])) {
          $params['LineItems']['LineItem'][$key]['Tracking']
            = array(
                'TrackingCategory' =>
                  array(
                    array(
                     'Name' => 'City',
                     'Option' => $data['custom_26']
                  )
              )
          );
        } elseif (!empty($data['api.participant_payment.get']) && $data['api.participant_payment.get']['count'] > 0) {
          $event_id = $data['api.participant_payment.get']['values'][0]['api.participant.get']['values'][0]['event_id'];
          list($tagId, $name) = _cbf_civicrm_civicrm_event_ministry_centre($event_id);
          if (!empty($name)) {
            $params['LineItems']['LineItem'][$key]['Tracking']
              = array(
                  'TrackingCategory' =>
                    array(
                      array(
                       'Name' => 'City',
                       'Option' => strtoupper(substr($name, 0, 3))
                    )
                )
            );
          }
        }
      }

      // Capture the Purpose if supplied as an extra Line Item
      if (!empty($data['custom_27'])) {
        $params['LineItems']['LineItem'][] = array('Description' => $data['custom_27']);
      }
      break;
  }
}

/*
 * Support integer custom fields that map to group ids. These are set with a dummy
 * option of 0 => 'None', which needs to be removed.
 */
function cbf_civicrm_civicrm_fieldOptions($entity, $field, &$options, $params) {
  static $activeMailingLists = null;

  switch ($field) {
    case 'custom_45': // 'Events like this' list
    case 'custom_46': // 'News and updates' list
      try {
        if (!isset($activeMailingLists)) {
          $activeMailingLists = civicrm_api3(
            'Group',
            'get',
            array(
              'sequential' => 1,
              'is_active' => 1,
              'group_type' => 2, // Mailing list
              'is_hidden' => 0,
              'options' => array('limit' => 0),
            )
          );
        }
        if ($activeMailingLists['is_error'] != 0) {
          return;
        }
        foreach ($activeMailingLists['values'] as $list) {
          $options[$list['id']] = $list['title'];
        }
        if ($options[0] == 'None') {
          unset($options[0]);
        }
      } catch (Exception $e) {
        return;
      }
      break;

    default:
      return;
  }
}

function _cbf_civicrm_civicrm_contact_id($sort_name) {
  try {
    $contact = civicrm_api3('Contact', 'get', array(
      'sequential' => 1,
      'return' => array('id'),
      'sort_name' => $sort_name,
    ));

    if (count($contact['values']) == 1) {
      return $contact['values'][0]['id'];
    }
  } catch (CiviCRM_API3_Exception $e) {
    ;
  }

  return false;
}

function _cbf_civicrm_civicrm_event_ministry_centre_id($name) {
  $ministry_centre_group_id = 326;

  try {
    $tag = civicrm_api3('OptionValue', 'get', array(
      'sequential' => 1,
      'label' => $name,
      'option_group_id' => $ministry_centre_group_id,
      'return' => 'value',
    ));

    if (count($tag['values']) == 1) {
      return $tag['values'][0]['value'];
    }
  } catch (CiviCRM_API3_Exception $e) {
    ;
  }

  return false;
}
