<?php

/*
 *  This hook is called when an email is about to be sent by CiviCRM.
 *  It ensures the email contains no relative links.
 *  It adds the closing tags for the BODY and HTML elements, as these are
 *  left off so CiviMail can add a tracking token to the email.
 */
function cbf_civicrm_civicrm_alterMailParams( &$params, $context = null ) {
  /*
   *  Change relative URLs to absolute.
   */
  $htmlMessage = CRM_Utils_Array::value( 'html', $params );
  if ( $htmlMessage ) {
    /*
     *  Links:  Relative URLs start with a '/' and occur in the HREF attribute of an A element
     *  Images: Relative URLs start with a '/' and occur in the SRC attribute of an IMG element
     *  The '/' is replaced by the CiviCRM User Framework Base URL, which terminates with a '/'
     */
    $config = CRM_Core_Config::singleton( );
    $htmlMessage = str_replace(' href="//', ' href="http://', $htmlMessage);
    $htmlMessage = str_replace(' src="//',  ' src="http://',  $htmlMessage);
    $htmlMessage = str_replace(' href="/',  ' href="'.$config->userFrameworkBaseURL, $htmlMessage);
    $htmlMessage = str_replace(' src="/',   ' src="'.$config->userFrameworkBaseURL,  $htmlMessage);
    /*
     *  Remove empty paragraphs inserted by CKeditor
     */
    $htmlMessage = preg_replace('!<p>(\r\n\t)*&nbsp;</p>!i', '', $htmlMessage);
    /*
     * The CKeditor Image Dialog removes width attributes from HTML IMGs. This causes an issue
     * for responsive email templates when the email is viewed in Outlook. As these images have
     * a CSS style setting their width or max-width to 280px, we reinsert the HTML attribute on
     * images that match that pattern.
     */
    $htmlMessage = preg_replace('!<img ([^w/>][^>]+width: 280px[^>]+)/>!i', '<img width="280" $1/>', $htmlMessage);
    /*
     * The HTML IMGs that have been set to 280px wide will not scale properly if the height
     * attribute is set. We remove that.
     */
    $htmlMessage = preg_replace('!<img width="280" ([^>]+)height: [0-9px%]+[;]?([^>]+)/>!i', '<img width="280" $1$2/>', $htmlMessage);
    /*
     * Look for the closing tag for the BODY element, and add it if needed
     */
    if (stripos($htmlMessage, '</body>') === false) {
      $htmlMessage .= '</body></html>';
    }
    /*
     * Ensure the email has a Title in its title-field
     */
    if (isset($params['tplParams']) && !isset($params['tplParams']['title']) && isset($params['subject'])) {
      $htmlMessage = preg_replace('!class="title-field">  </p>!i', 'class="title-field"> ' . $params['subject'] . ' </p>', $htmlMessage);
    }
    /*
     * Replace the '<tax-invoice/>' HTML element with the Tax Invoice text.
     * This is usually empty, except for event registrations and contributions
     * for Event Fees and Sales.
     */
    $taxInvoice = '<tr><td>This email serves as a Tax Invoice. Amounts quoted include GST.</td></tr><tr><td>ABN 42 172 211 662</td></tr>';
    $isTaxInvoice = FALSE;
    if (isset($params['valueName'])) {
      switch ($params['valueName']) {
        case 'contribution_offline_receipt':
        case 'contribution_online_receipt':
          if (isset($params['tplParams']['contributionTypeName'])) {
            $financialType = $params['tplParams']['contributionTypeName'];
          }
          else {
            try {
              $contribution = civicrm_api3('Contribution', 'get', array(
                'sequential' => 1,
                'id' => $params['contributionId'],
              ));
              $financialType = $contribution['values'][0]['financial_type'];
            } catch (CiviCRM_API3_Exception $e) {
              $financialType = '';
            }
          }
          switch ($financialType) {
            case 'Event Fee':
            case 'Sales':
              $isTaxInvoice = TRUE;
              break;
          }
          break;

        case 'event_offline_receipt':
        case 'event_online_receipt':
          $isTaxInvoice = TRUE;
          break;
      }
    }
    $htmlMessage = preg_replace('!<tax-invoice/>!i', $isTaxInvoice ? $taxInvoice : '', $htmlMessage);

    $params['html'] = $htmlMessage;
  }
}

/*
 * This hook is called when a form is being built by CiviCRM.
 * It adds the Credit Card Holder to credit card payment forms, and makes the holder
 * field available on confirmation and thank-you pages. This doesn't work for the
 * event forms since they protect their _param variables.
 * It makes the Billing Name and Address not-required, as these are not presented
 * on CBF payment forms.
 */
function cbf_civicrm_civicrm_buildForm( $formName, &$form ) {
  switch ($formName) {

    case 'CRM_Contribute_Form_Contribution':
    case 'CRM_Contribute_Form_Contribution_Main':
    case 'CRM_Event_Form_Participant':
    case 'CRM_Event_Form_Registration_Register':
      if (user_is_anonymous() && isset($_SESSION['CiviCRM']['status'][0]['text'])) {
        $status_text = $_SESSION['CiviCRM']['status'][0]['text'];
        if (stristr($status_text, 'Payment Processor Error') !== false) {
          if (stristr($status_text, '9001') !== false) {
            if (isset($_SESSION['City Bible Forum']['Card issues'])) {
              $_SESSION['City Bible Forum']['Card issues']++;
            } else {
              $_SESSION['City Bible Forum']['Card issues'] = 1;
            }
          }
        }
      }

      if (isset($_SESSION['City Bible Forum']['Card issues']) && $_SESSION['City Bible Forum']['Card issues'] > 5) {
        CRM_Utils_System::redirect(CRM_Utils_System::url('full-stop.html'));
      }

      // Add a form element for the credit card holder
      // It is required if the credit card number is required
      if ($form->elementExists('credit_card_number') && !$form->elementExists('credit_card_holder')) {
        $form->add (
          'text',
          'credit_card_holder',
          ts('Card Holder'),
          array (
            'size' => 20,
            'maxlength' => 30,
            'autocomplete' => 'off' ),
          $form->isElementRequired('credit_card_number'),
          null);
      }

      // Assume the person's first and last name are being captured via a profile
      // Make the address optional so donors have less data to supply
      if (isset($form->_bltID)) {
        $bltID = $form->_bltID;
        $unnecessaryFields = array(
          "billing_first_name",
          "billing_last_name",
          "billing_street_address-{$bltID}",
          "billing_city-{$bltID}",
          "billing_postal_code-{$bltID}",
          "billing_state_province_id-{$bltID}",
          "billing_country_id-{$bltID}"
        );
        $form->_required = array_diff($form->_required, $unnecessaryFields);
        foreach ($unnecessaryFields as $field) {
          if ( isset($form->_paymentFields[$field]) ) {
            $form->_paymentFields[$field]['is_required'] = false;
          }
        }
      }

      if ($formName == 'CRM_Contribute_Form_Contribution_Main' && $form->elementExists('buttons') ) {
        $buttons = $form->getElement('buttons');
        $submit = $buttons->getElements();
        $submit[0]->setValue('Next >>');
      }

      break;

    case 'CRM_Contribute_Form_Contribution_Confirm':
    case 'CRM_Contribute_Form_Contribution_ThankYou':
    case 'CRM_Event_Form_Registration_Confirm':
    case 'CRM_Event_Form_Registration_ThankYou':
      // Set the Credit Card Holder in the Smarty template
      // Clear the Address in the Smarty template
      $tpl = $form->getTemplate();
      $tpl_credit_card_number = $tpl->get_template_vars('credit_card_number');
      if ( isset($tpl_credit_card_number) ) {
        if ( isset($form->_params['credit_card_holder']) ) {
          $form->assign( 'credit_card_holder', $form->_params['credit_card_holder'] );
        }
        else if (isset($form->_params[0]) && isset($form->_params[0]['credit_card_holder'])) {
          $form->assign( 'credit_card_holder', $form->_params[0]['credit_card_holder'] );
        }
      }
      $form->assign( 'address', '' );

      if ($formName == 'CRM_Contribute_Form_Contribution_Confirm' && $form->elementExists('buttons')) {
        $makePaymentLabel = 'Make payment';

        $buttons = $form->getElement('buttons');
        $submit = $buttons->getElements();
        $submit[0]->setValue($makePaymentLabel);

        $tpl->assign('button', $makePaymentLabel);
      }
      break;

    case 'CRM_Mailing_Form_Upload':
      // For CiviMails, unset the From email address when the Subject is empty.
      // This is a roundabout way of unsetting the CiviMail default, to force
      // the user to enter an From address.
      if ( $form->getElementValue('subject') == null ) {
        $fromAddress = $form->getElement('from_email_address');
        $fromAddress->setSelected(0);
      }
      break;
  }
}

/*
 * This function is called when a form is being validated by CiviCRM.
 * In cases where the Credit Card Holder field is not-required, it is mandatory if the
 * Credit Card Number has been entered.
 */
function cbf_civicrm_civicrm_validateForm( $formName, &$fields, &$files, &$form, &$errors ) {
  switch ($formName) {

    case 'CRM_Contribute_Form_Contribution':
    case 'CRM_Contribute_Form_Contribution_Main':
    case 'CRM_Event_Form_Participant':
    case 'CRM_Event_Form_Registration_Register':
      // The credit card holder is required for CC transactions
      // Assume that a credit card payment is being made if the CC number is supplied
      // This test is only required if the Card Holder field exists and is not a required field
      if ($form->elementExists('credit_card_holder') && !$form->isElementRequired('credit_card_holder')) {
        $credit_card_number = CRM_Utils_Array::value('credit_card_number', $fields);
        $credit_card_holder = CRM_Utils_Array::value('credit_card_holder', $fields);
        if ($credit_card_number && !$credit_card_holder) {
          $errors['credit_card_holder'] = ts('Card Holder is required if Card Number is supplied');
        }
      }
      break;

    case 'CRM_Contact_Import_Form_DataSource':
      // The dedupe rule is needed, except when 'No Duplicate Checking' is selected
      $onDuplicate = CRM_Utils_Array::value( 'onDuplicate', $fields );
      foreach ($form->getElement('onDuplicate')->getElements() as $duplicateOption ) {
        if ($duplicateOption->getValue() == $onDuplicate) {
          break; // We've found the option that's been selected
        }
      }
      if ($duplicateOption->getText() <> 'No Duplicate Checking') {
        if (CRM_Utils_Array::value( 'dedupe', $fields ) == '') {
          $errors['dedupe'] = ts('Dedupe rule must be set, unless there is no duplicate checking');
        }
      }
      break;

    case 'CRM_Event_Form_ManageEvent_EventInfo':
      // Ensure the End date is set for Events that are not templates
      $isTemplate = CRM_Utils_Array::value('is_template', $fields);
      $start = CRM_Utils_Date::processDate(CRM_Utils_Array::value('start_date', $fields), CRM_Utils_Array::value('start_date_time', $fields));
      $end = CRM_Utils_Date::processDate(CRM_Utils_Array::value('end_date', $fields), CRM_Utils_Array::value('end_date_time', $fields));
      if (empty($isTemplate)) {
        if (empty($end)) {
          $errors['end_date'] = ts('End Date and Time are required fields');
        }
        elseif ($end <= $start) {
          $errors['end_date'] = ts('End date should be after Start date');
        }
      }
      break;
  }
}

/*
 * This function is called before CiviCRM passes payment details to a Payment Processor.
 * The Credit Card Holder is captured.
 * The Purchaser Address details are cleared, since the Billing Address is not captured.
 */
function cbf_civicrm_civicrm_alterPaymentProcessorParams( $paymentObj, &$rawParams, &$cookedParams ) {
  $is_recur           = CRM_Utils_Array::value('is_recur',           $rawParams);
  $credit_card_holder = CRM_Utils_Array::value('credit_card_holder', $rawParams);
  if (isset($is_recur) && $is_recur) {
    if ($paymentObj instanceof org_civicrm_ewayrecurring) {
      // Set credit card holder
      if ($credit_card_holder) {
        $cookedParams['CCNameOnCard'] = $credit_card_holder;
      }
      // Set address
      $cookedParams['Address']  = 'c/o Level 3, 13-15 Bridge St';
      $cookedParams['Suburb']   = 'Sydney';
      $cookedParams['State']    = 'NSW';
      $cookedParams['PostCode'] = '2000';
    }
    else if ($paymentObj instanceof com_chrischinchilla_ewayrecurring || $paymentObj instanceof CRM_Core_Payment_Ewayrecurring) {
      // Set credit card holder
      if ($credit_card_holder) {
        $cookedParams['man:CCNameOnCard'] = $credit_card_holder;
      }
      // Set address
      $cookedParams['man:Address']  = 'c/o Level 3, 13-15 Bridge St';
      $cookedParams['man:Suburb']   = 'Sydney';
      $cookedParams['man:State']    = 'NSW';
      $cookedParams['man:PostCode'] = '2000';
    }
  }
  else {
    if ($paymentObj instanceof CRM_Core_Payment_eWAY  ||
        $paymentObj instanceof org_civicrm_ewayrecurring  ||
        $paymentObj instanceof com_chrischinchilla_ewayrecurring ||
        $paymentObj instanceof CRM_Core_Payment_Ewayrecurring) {
      // Set credit card holder
      if ($credit_card_holder) {
        $cookedParams->CardHolderName($credit_card_holder);
      }
      // Clear address information
      $cookedParams->PurchaserAddress('');
      $cookedParams->PurchaserPostalCode('');
    }
  }
}

function cbf_civicrm_civicrm_tokens( &$tokens ) {
  $tokens['cbf'] = array('cbf.hostname');
}

function cbf_civicrm_civicrm_tokenValues( &$details, &$contactIDs ) {
  $config = CRM_Core_Config::singleton( );
  $hostname = preg_replace('!^https?://([^/]+)/$!i', '$1', $config->userFrameworkBaseURL);
  if (is_array($contactIDs)) {
    foreach ($details as $id => $detail) {
      $details[$id]['cbf.hostname'] = $hostname;
    }
  }
  else {
    $details['cbf.hostname'] = $hostname;
  }
}

/*
 * Add extra variables to help with debugging, then return false so
 * the standard error handling continues.
 */
function cbf_civicrm_fatal_error_handler(&$vars) {
  if ( isset($_SERVER['HTTP_X_FORWARDED_FOR']) ) {
    $vars['ip']  = $_SERVER['HTTP_X_FORWARDED_FOR'];
    $vars['url'] = $_SERVER['HTTP_X_FORWARDED_PROTO'] . '://' . $_SERVER['HTTP_X_HOST'] . $_SERVER['REQUEST_URI'];
  }
  else {
    $vars['ip']  = $_SERVER['REMOTE_ADDR'];
    $vars['url'] = $_SERVER['REQUEST_SCHEME'] . '://' . $_SERVER['SERVER_NAME'] . $_SERVER['REQUEST_URI'];
  }

  /*
   * There are a number of annoying errors that get logged. They seem to be due to
   * robots etc. The $ignore array stores the patterns that should be ignored.
   *
   * The $ignore array consists of a number of pattern sets. Each set is matched
   * against elements of the $vars array. If all the patterns in a set match, we
   * simply return 'true'. This tells CiviCRM to abend processing, and nothing
   * is logged.
   */
  $ignore = array(
    array(
      'message' => 'Invalid value passed to getPayment function',
      'url' => '/civicrm/event/register.*id=[0-9][0-9][0-9]($|[^0-9])',
    ),
    array(
      'message' => 'id .* POST .* GET .* is not of the type Positive',
    ),
    array(
      'message' => 'Invalid form parameters',
      'url' => '/civicrm/mailing/forward$',
    ),
    array(
      'message' => 'Missing (input )?parameters',
      'url' => '/civicrm/mailing/(optout|unsubscribe)$',
    ),
  );

  foreach ($ignore as $patternSet) {
    foreach ($patternSet as $element => $pattern) {
      if (preg_match('#' . $pattern . '#i', $vars[$element]) != 1) {
        continue 2;
      }
    }
    return true;
  }

  $vars['ip-details'] = json_decode(file_get_contents("http://ipinfo.io/" . $vars['ip'] . "/json"));
  if (isset($_SESSION)) {
    $vars['session'] = $_SESSION;
    unset($vars['session']['CiviCRM']['qfPrivateKey']);
  }

  return false;
}

/*
 * Implementation of hook_civicrm_pre() to capture changes before they're saved
*/
function cbf_civicrm_civicrm_pre( $op, $objectName, $id, &$params ) {
  /*
   * Whenever an Archived_team ("Past team") is created or edited, ensure
   * its name includes 'No longer meets: ' and its relationships are
   * inactive.
   */
  if ($objectName == 'Household') {
    switch ($op) {
      case 'create':
      case 'edit':
        foreach ($params['contact_sub_type'] as $sub_type) {
          if ($sub_type == 'Archived_team') {
            $archived_team_prefix = 'No longer meets: ';

            if (strpos($params['household_name'], $archived_team_prefix) === false) {
              $params['household_name'] = $archived_team_prefix . $params['household_name'];
            }

            try {
              $get_a = civicrm_api3('Relationship', 'get', array(
                'sequential' => 1,
                'contact_id_a' => $id,
                'is_active' => 1,
              ));
              $get_b = civicrm_api3('Relationship', 'get', array(
                'sequential' => 1,
                'contact_id_b' => $id,
                'is_active' => 1,
              ));
              $get = array_merge($get_a['values'], $get_b['values']);

              foreach ($get as $relationship) {
                if (!isset($relationship['end_date'])) {
                  // 'setvalue' objects to dashes in dates
                  $result = civicrm_api3('Relationship', 'setvalue', array(
                    'sequential' => 1,
                    'field' => 'end_date',
                    'id' => $relationship['id'],
                    'value' => str_replace('-', '', CRM_Utils_Date::getToday()),
                  ));
                }

                $result = civicrm_api3('Relationship', 'setvalue', array(
                  'sequential' => 1,
                  'field' => 'is_active',
                  'id' => $relationship['id'],
                  'value' => 0,
                ));
              }

            } catch (CiviCRM_API3_Exception $e) {
              ;
            }
          }
        }
        break;
    }
  }
}

/*
 * Implementation of hook_civicrm_post() which is called after a db write on some core objects
*/
function cbf_civicrm_civicrm_post( $op, $objectName, $id, &$params ) {
  switch ($objectName) {
    case 'Participant':
      _cbf_civicrm_civicrm_post_participant($op, $id, $params);
      break;
  }
}

function _cbf_civicrm_civicrm_post_participant($op, $id, &$params) {
  switch ($op) {
    /*
     * Whenever a Participant is created, ensure the contact has a Ministry
     * Centre tag. If it doesn't, add a tag that corresponds to the Ministry
     * Centre of the event.
     */
    case 'create':
      try {
        if (_cbf_civicrm_civicrm_contact_has_ministry_centre($params->contact_id)) {
          break;
        }

        list($tagId, $name) = _cbf_civicrm_civicrm_event_ministry_centre($params->event_id);

        if ($tagId !== FALSE) {
          $create = civicrm_api3('EntityTag', 'create', array(
            'sequential' => 1,
            'entity_table' => 'civicrm_contact',
            'entity_id' => $params->contact_id,
            'tag_id' => $tagId,
          ));
        }
      } catch (CiviCRM_API3_Exception $e) {
        ;
      }
      break;
  }
}

/*
 * Originally intended this function to be called like _cbf_civicrm_civicrm_post_participant
 * but the desired functionality didn't work due to timing - the post hook was called before
 * the City was attached to the Contribution.
 *
 * So the 3rd argument was changed for convenience, and this function is now called when an
 * Account Invoice is being sent to Xero.
 */
function _cbf_civicrm_civicrm_post_contribution($op, $id, $contact_id) {
  switch ($op) {
    /*
     * Whenever a Contribution is created, ensure the contact has a Ministry
     * Centre tag. If it doesn't, add a tag that corresponds to the City they
     * entered.
     */
    case 'create':
      try {
        if (_cbf_civicrm_civicrm_contact_has_ministry_centre($contact_id)) {
          break;
        }

        $ministry_centre = _cbf_civicrm_civicrm_contribution_ministry_centre($id);

        if ($ministry_centre !== FALSE) {
          $create = civicrm_api3('EntityTag', 'create', array(
            'sequential' => 1,
            'entity_table' => 'civicrm_contact',
            'entity_id' => $contact_id,
            'tag_id' => $ministry_centre,
          ));
        }
      } catch (CiviCRM_API3_Exception $e) {
        ;
      }
      break;
  }
}

function _cbf_civicrm_civicrm_contact_has_ministry_centre($contact_id) {
  $ministry_centre_prefix = 'Ministry centre is ';

  $entity_tags = civicrm_api3('EntityTag', 'get', array(
    'sequential' => 1,
    'entity_table' => 'civicrm_contact',
    'entity_id' => $contact_id,
  ));

  foreach ($entity_tags['values'] as $entity_tag) {
    $tag = civicrm_api3('Tag', 'get', array(
      'sequential' => 1,
      'id' => $entity_tag['tag_id'],
      'return' => 'name',
    ));

    if (stristr($tag['values'][0]['name'], $ministry_centre_prefix) !== false) {
      return TRUE;
    }
  }

  return FALSE;
}

function _cbf_civicrm_civicrm_event_ministry_centre($event_id) {
  $ministry_centre_group_id = 326;
  $ministry_centre_prefix = 'Ministry centre is ';

  try {
    $custom_values = civicrm_api3('CustomValue', 'get', array(
      'sequential' => 1,
      'entity_id' => $event_id,
      'entity_table' => 'civicrm_event',
      'id' => 25,
    ));

    $ministry_centre_id = null;

    foreach ($custom_values['values'] as $custom_value) {
      if (isset($custom_value['latest']) && isset($custom_value['id']) && $custom_value['id'] = '25') {
        $ministry_centre_id = (int) $custom_value['latest'];
        break;
      }
    }

    if ( ! isset($ministry_centre_id) ) {
      return array(FALSE, FALSE);
    }

    $ministry_centre = civicrm_api3('OptionValue', 'getvalue', array(
      'sequential' => 1,
      'option_group_id' => $ministry_centre_group_id,
      'value' => $ministry_centre_id,
      'return' => 'name',
    ));

    $tag = civicrm_api3('Tag', 'getvalue', array(
      'sequential' => 1,
      'name' => $ministry_centre_prefix . $ministry_centre,
      'return' => 'id',
    ));

    return array($tag, $ministry_centre);
 
  } catch (CiviCRM_API3_Exception $e) {
    return array(FALSE, FALSE);
  }
}

function _cbf_civicrm_civicrm_contribution_ministry_centre($contribution_id) {
  $ministry_centre_prefix = 'Ministry centre is ';

  try {
    // Since the City value is publicly visible, no need to use CustomValue API
    $city = civicrm_api3('Contribution', 'getvalue', array(
      'sequential' => 1,
      'return' => 'custom_26',
      'id' => $contribution_id,
    ));

    if (empty($city)) {
      return FALSE;
    }

    $tags = civicrm_api3('Tag', 'get', array(
      'sequential' => 1,
      'return' => 'id,name',
    ));

    foreach ($tags['values'] as $tag) {
      if (stristr($tag['name'], $ministry_centre_prefix . $city) !== FALSE) {
        return $tag['id'];
      }
    }
  } catch (CiviCRM_API3_Exception $e) {
    ;
  }

  return FALSE;
}

/*
 * A hook that gets called by the AccountSync extension, prior to pulling data
 * from Xero.
 *
 * @param string $entity entity - eg. 'contact'
 * @param array $data data from accounts being processing
 * @param bool $save save? - set this to false if it should be skipped
 * @param $params
 *
 * @return mixed
 *   Ignore value.
 */
function cbf_civicrm_civicrm_accountPullPreSave($entity, &$data, &$save, &$params) {
  switch ($entity) {
    case 'contact':
      break;

    case 'invoice':
      // Don't try to pull Invoices when the Contribution Id is not numeric
      if (isset($params['contribution_id']) && !is_numeric($params['contribution_id'])) {
        $save = FALSE;
      }
      break;
  }
}


/*
 * A hook that gets called by the AccountSync extension, prior to pushing data
 * to Xero.
 *
 * @param string $entity entity - eg. 'contact'
 * @param array $data data from accounts being processing
 * @param bool $save save? - set this to false if it should be skipped
 * @param $params
 *
 * @return mixed
 *   Ignore value.
 */
function cbf_civicrm_civicrm_accountPushAlterMapped($entity, &$data, &$save, &$params) {
  switch ($entity) {
    case 'contact':
      // Remove prefixes etc from Contact name
      if ($data['contact_type'] == 'Individual') {
        $params['Name'] = $data['first_name'] . ' ' . $data['last_name'] . ' - ' . $data['contact_id'];
      }
      // Highlight deleted contacts in Xero
      $deletedSuffix = ' (deleted in CiviCRM)';
      if (!empty($data['contact_is_deleted']) && stristr($params['Name'], $deletedSuffix) === false) {
        $params['Name'] .= $deletedSuffix;
      }
      break;

    case 'invoice':
      // Ensure the contact has a Ministry Centre tag
      _cbf_civicrm_civicrm_post_contribution('create', $data['contribution_id'], $data['contact_id']);

      // Baulk if the Suppress Xero Invoice is set
      if (!empty($data['custom_43'])) {
        $save = FALSE;
        break;
      }

      // Include the Transaction Id in the Invoice reference
      if (!empty($data['trxn_id'])) {
        $params['Reference'] = $data['trxn_id'] . ' - ' . $params['Reference'];
      }

      // Ensure there is at least one Line Item in the Invoice
      if (empty($params['LineItems']['LineItem'])) {
        $params['LineItems']['LineItem'][] = array(
          'Description' => 'Amount',
          'Quantity' => '1.00',
          'UnitAmount' => $data['total_amount'],
          'AccountCode' => tapestrymultiaccounts_get_civicrm_account_code($data['financial_type_id']),
        );
        $data['line_items'][] = array('label' => 'Amount');
      }

      // Process each Line Item
      $lineItemKeys = array_keys($data['line_items']);
      foreach ($params['LineItems']['LineItem'] as $key => $lineitem) {
        $local = $data['line_items'][$lineItemKeys[$key]];

        // Remove some gumph from the Description
        $params['LineItems']['LineItem'][$key]['Description'] = $local['label'];

        // Set the Account Code for recurring contributions
        if (!empty($data['contribution_recur_id'])) {
          $params['LineItems']['LineItem'][$key]['AccountCode'] = '40110';
        }

        // Capture the City tracking category. This may be supplied for
        // Contributions, but can be derived from the Event's ministry
        // centre.
        if (!empty($data['custom_26'])) {
          $params['LineItems']['LineItem'][$key]['Tracking']
            = array(
                'TrackingCategory' =>
                  array(
                    array(
                     'Name' => 'City',
                     'Option' => $data['custom_26']
                  )
              )
          );
        } elseif (!empty($data['api.participant_payment.get']) && $data['api.participant_payment.get']['count'] > 0) {
          $event_id = $data['api.participant_payment.get']['values'][0]['api.participant.get']['values'][0]['event_id'];
          list($tagId, $name) = _cbf_civicrm_civicrm_event_ministry_centre($event_id);
          if (isset($name)) {
            $params['LineItems']['LineItem'][$key]['Tracking']
              = array(
                  'TrackingCategory' =>
                    array(
                      array(
                       'Name' => 'City',
                       'Option' => strtoupper(substr($name, 0, 3))
                    )
                )
            );
          }
        }
      }

      // Capture the Purpose if supplied as an extra Line Item
      if (!empty($data['custom_27'])) {
        $params['LineItems']['LineItem'][] = array('Description' => $data['custom_27']);
      }
      break;
  }
}

/**
 * Get the accounting code from the financial type id.
 *
 * @param int $financialTypeID
 * @return mixed
 */
function tapestrymultiaccounts_get_civicrm_account_code($financialTypeID) {
  static $codes = array();
  if (!in_array($financialTypeID, $codes)) {
    $codes[$financialTypeID] = CRM_Financial_BAO_FinancialAccount::getAccountingCode($financialTypeID);
    if (empty($codes[$financialTypeID])) {
      $codes[$financialTypeID] = civicrm_api('setting', 'getvalue', array(
        'group' => 'Xero Settings',
        'name' => 'xero_default_revenue_account',
        'version' => 3,
      ));
    }
  }
  return $codes[$financialTypeID];
}
