<?php

/*
 *  This hook is called when an email is about to be sent by CiviCRM.
 *  It ensures the email contains no relative links.
 *  It adds the closing tags for the BODY and HTML elements, as these are
 *  left off so CiviMail can add a tracking token to the email.
 */
function cbf_civicrm_civicrm_alterMailParams( &$params, $context = null ) {
    /*
     *  Change relative URLs to absolute.
     */
    $htmlMessage = CRM_Utils_Array::value( 'html', $params );
    if ( $htmlMessage ) {
        /*
         *  Links:  Relative URLs start with a '/' and occur in the HREF attribute of an A element
         *  Images: Relative URLs start with a '/' and occur in the SRC attribute of an IMG element
         *  The '/' is replaced by the CiviCRM User Framework Base URL, which terminates with a '/'
         */
        $config = CRM_Core_Config::singleton( );
        $htmlMessage = str_replace(' href="//', ' href="http://', $htmlMessage);
        $htmlMessage = str_replace(' src="//',  ' src="http://',  $htmlMessage);
        $htmlMessage = str_replace(' href="/',  ' href="'.$config->userFrameworkBaseURL, $htmlMessage);
        $htmlMessage = str_replace(' src="/',   ' src="'.$config->userFrameworkBaseURL,  $htmlMessage);
        /*
         *  Remove empty paragraphs inserted by CKeditor
         */
        $htmlMessage = preg_replace('!<p>(\r\n\t)*&nbsp;</p>!i', '', $htmlMessage);
        /*
         * The CKeditor Image Dialog removes width attributes from HTML IMGs. This causes an issue
         * for responsive email templates when the email is viewed in Outlook. As these images have
         * a CSS style setting their width or max-width to 280px, we reinsert the HTML attribute on
         * images that match that pattern.
         */
        $htmlMessage = preg_replace('!<img ([^w/>][^>]+width: 280px[^>]+)/>!i', '<img width="280" $1/>', $htmlMessage);
        /*
         * The HTML IMGs that have been set to 280px wide will not scale properly if the height
         * attribute is set. We remove that.
         */
        $htmlMessage = preg_replace('!<img width="280" ([^>]+)height: [0-9px%]+[;]?([^>]+)/>!i', '<img width="280" $1$2/>', $htmlMessage);
        /*
         * Look for the closing tag for the BODY element, and add it if needed
         */
        if (stripos($htmlMessage, '</body>') === false) {
            $htmlMessage .= '</body></html>';
        }
        $params['html'] = $htmlMessage;
    }
}

/*
 * This hook is called when a form is being built by CiviCRM.
 * It adds the Credit Card Holder to credit card payment forms, and makes the holder
 * field available on confirmation and thank-you pages. This doesn't work for the
 * event forms since they protect their _param variables.
 * It makes the Billing Name and Address not-required, as these are not presented
 * on CBF payment forms.
 */
function cbf_civicrm_civicrm_buildForm( $formName, &$form ) {
    switch ( $formName ) {

        case 'CRM_Contribute_Form_Contribution':
        case 'CRM_Contribute_Form_Contribution_Main':
        case 'CRM_Event_Form_Participant':
        case 'CRM_Event_Form_Registration_Register':

            if (user_is_anonymous() && isset($_SESSION['CiviCRM']['status'][0]['text'])) {
              $status_text = $_SESSION['CiviCRM']['status'][0]['text'];
              if (stristr($status_text, 'Payment Processor Error') !== false) {
                if (stristr($status_text, '9001') !== false) {
                  if (isset($_SESSION['City Bible Forum']['Card issues'])) {
                    $_SESSION['City Bible Forum']['Card issues']++;
                  } else {
                    $_SESSION['City Bible Forum']['Card issues'] = 1;
                  }
                }
              }
            }

            if ($_SESSION['City Bible Forum']['Card issues'] > 5) {
              CRM_Utils_System::redirect(CRM_Utils_System::url('annoying-urls.html'));
            }

            // Add a form element for the credit card holder
            // It is required if the credit card number is required
            if ( $form->elementExists('credit_card_number') && 
                !$form->elementExists('credit_card_holder') ) {
                $form->add (
                    'text', 
                    'credit_card_holder', 
                    ts('Card Holder'),
                    array (
                        'size' => 20, 
                        'maxlength' => 30, 
                        'autocomplete' => 'off' ), 
                    $form->isElementRequired('credit_card_number'),
                    null);
            }

            // Assume the person's first and last name are being captured via a profile
            // Make the address optional so donors have less data to supply
            if (isset($form->_bltID)) {
                $bltID = $form->_bltID;
                $unnecessaryFields = array(
                                         "billing_first_name",
                                         "billing_last_name",
                                         "billing_street_address-{$bltID}",
                                         "billing_city-{$bltID}",
                                         "billing_postal_code-{$bltID}",
                                         "billing_state_province_id-{$bltID}",
                                         "billing_country_id-{$bltID}"
                                     );
                $form->_required = array_diff($form->_required, $unnecessaryFields);
                foreach ($unnecessaryFields as $field) {
                    if ( isset($form->_paymentFields[$field]) ) {
                        $form->_paymentFields[$field]['is_required'] = false;
                    }
                }
            }

            if ($formName == 'CRM_Contribute_Form_Contribution_Main'
                    && $form->elementExists('buttons') ) {
                $buttons = $form->getElement('buttons');
                $submit = $buttons->getElements();
                $submit[0]->setValue('Next >>');
            }

            break;

        case 'CRM_Contribute_Form_Contribution_Confirm':
        case 'CRM_Contribute_Form_Contribution_ThankYou':
        case 'CRM_Event_Form_Registration_Confirm':
        case 'CRM_Event_Form_Registration_ThankYou':

            // Set the Credit Card Holder in the Smarty template
            // Clear the Address in the Smarty template
            $tpl = $form->getTemplate();
            $tpl_credit_card_number = $tpl->get_template_vars('credit_card_number'); 
            if ( isset($tpl_credit_card_number) ) {
                if ( isset($form->_params['credit_card_holder']) ) {
                    $form->assign( 'credit_card_holder', $form->_params['credit_card_holder'] );
                } else if ( isset($form->_params[0]) && 
                            isset($form->_params[0]['credit_card_holder']) ) {
                    $form->assign( 'credit_card_holder', $form->_params[0]['credit_card_holder'] );
                }
            }
            $form->assign( 'address', '' );

            if ($formName == 'CRM_Contribute_Form_Contribution_Confirm'
                    && $form->elementExists('buttons') ) {
                $makePaymentLabel = 'Make payment';

                $buttons = $form->getElement('buttons');
                $submit = $buttons->getElements();
                $submit[0]->setValue($makePaymentLabel);

                $tpl->assign('button', $makePaymentLabel);
            }

            break;

        case 'CRM_Mailing_Form_Upload':

            // For CiviMails, unset the From email address when the Subject is empty.
            // This is a roundabout way of unsetting the CiviMail default, to force
            // the user to enter an From address. 
            if ( $form->getElementValue('subject') == null ) {
                $fromAddress = $form->getElement('from_email_address');
                $fromAddress->setSelected(0);
            }
            break;
    }
    return;
}

/*
 * This function is called when a form is being validated by CiviCRM.
 * In cases where the Credit Card Holder field is not-required, it is mandatory if the
 * Credit Card Number has been entered.
 */
function cbf_civicrm_civicrm_validateForm( $formName, &$fields, &$files, &$form, &$errors ) {
    switch ( $formName ) {

        case 'CRM_Contribute_Form_Contribution':
        case 'CRM_Contribute_Form_Contribution_Main':
        case 'CRM_Event_Form_Participant':
        case 'CRM_Event_Form_Registration_Register':
            
            // The credit card holder is required for CC transactions
            // Assume that a credit card payment is being made if the CC number is supplied
            // This test is only required if the Card Holder field exists and is not a required field
            if ( $form->elementExists('credit_card_holder') &&
                !$form->isElementRequired('credit_card_holder') ) {
                $credit_card_number = CRM_Utils_Array::value( 'credit_card_number', $fields );
                $credit_card_holder = CRM_Utils_Array::value( 'credit_card_holder', $fields );
                if ( $credit_card_number && ! $credit_card_holder ) {
                    $errors['credit_card_holder']
                        = ts( 'Card Holder is required if Card Number is supplied' );
                }
            }
            break;

        case 'CRM_Contact_Import_Form_DataSource':

            // The dedupe rule is needed, except when 'No Duplicate Checking' is selected
            $onDuplicate = CRM_Utils_Array::value( 'onDuplicate', $fields );
            foreach ($form->getElement('onDuplicate')->getElements() as $duplicateOption ) {
            	if ( $duplicateOption->getValue() == $onDuplicate ) {
            		break; // We've found the option that's been selected
            	}
            }
            if ( $duplicateOption->getText() <> 'No Duplicate Checking' ) {
                if ( CRM_Utils_Array::value( 'dedupe', $fields ) == '' ) {
                    $errors['dedupe']
                        = ts( 'Dedupe rule must be set, unless there is no duplicate checking' );
                }
            }
            break;
    }
}

/*
 * This function is called before CiviCRM passes payment details to a Payment Processor.
 * The Credit Card Holder is captured.
 * The Purchaser Address details are cleared, since the Billing Address is not captured.
 */
function cbf_civicrm_civicrm_alterPaymentProcessorParams( $paymentObj, &$rawParams, &$cookedParams ) {
    $is_recur           = CRM_Utils_Array::value( 'is_recur',           $rawParams );
    $credit_card_holder = CRM_Utils_Array::value( 'credit_card_holder', $rawParams );
    if ( isset($is_recur) && $is_recur ) {
        if ( $paymentObj instanceof org_civicrm_ewayrecurring ) {
    	    // Set credit card holder
    	    if ( $credit_card_holder ) {
    	        $cookedParams['CCNameOnCard'] = $credit_card_holder;
    	    }
    	    // Set address
    	    $cookedParams['Address']  = 'c/o Level 3, 13-15 Bridge St';
    	    $cookedParams['Suburb']   = 'Sydney';
    	    $cookedParams['State']    = 'NSW';
    	    $cookedParams['PostCode'] = '2000';
        } else if ( $paymentObj instanceof com_chrischinchilla_ewayrecurring ||
                    $paymentObj instanceof CRM_Core_Payment_Ewayrecurring ) {
    	    // Set credit card holder
    	    if ( $credit_card_holder ) {
    	        $cookedParams['man:CCNameOnCard'] = $credit_card_holder;
    	    }
    	    // Set address
    	    $cookedParams['man:Address']  = 'c/o Level 3, 13-15 Bridge St';
    	    $cookedParams['man:Suburb']   = 'Sydney';
    	    $cookedParams['man:State']    = 'NSW';
    	    $cookedParams['man:PostCode'] = '2000';
    	}
    } else {
        if ( $paymentObj instanceof CRM_Core_Payment_eWAY  ||
             $paymentObj instanceof org_civicrm_ewayrecurring  ||
             $paymentObj instanceof com_chrischinchilla_ewayrecurring ||
             $paymentObj instanceof CRM_Core_Payment_Ewayrecurring ) {
            // Set credit card holder
            if ( $credit_card_holder ) {
                $cookedParams->CardHolderName($credit_card_holder);
            }
            // Clear address information
            $cookedParams->PurchaserAddress('');
            $cookedParams->PurchaserPostalCode('');
        }
    }
}

function cbf_civicrm_civicrm_tokens( &$tokens ) {
	$tokens['cbf'] = array( 'cbf.hostname' );
}

function cbf_civicrm_civicrm_tokenValues( &$details, &$contactIDs ) {
    $config = CRM_Core_Config::singleton( );
    $hostname = preg_replace('!^https?://([^/]+)/$!i', '$1', $config->userFrameworkBaseURL);
	if (is_array($contactIDs)) {
		foreach ($details as $id => $detail) {
			$details[$id]['cbf.hostname'] = $hostname;
		}
	} else {
		$details['cbf.hostname'] = $hostname;
	}
}

/*
 * Add extra variables to help with debugging, then return false so
 * the standard error handling continues.
 */
function cbf_civicrm_fatal_error_handler(&$vars) {
	if ( isset($_SERVER['HTTP_X_FORWARDED_FOR']) ) {
		$vars['ip']  = $_SERVER['HTTP_X_FORWARDED_FOR'];
		$vars['url'] = $_SERVER['HTTP_X_FORWARDED_PROTO'] . '://' . $_SERVER['HTTP_X_HOST'] . $_SERVER['REQUEST_URI'];
	} else {
		$vars['ip']  = $_SERVER['REMOTE_ADDR'];
		$vars['url'] = $_SERVER['REQUEST_SCHEME'] . '://' . $_SERVER['SERVER_NAME'] . $_SERVER['REQUEST_URI'];
	}

	/*
	 * There are a number of annoying errors that get logged. They seem to be due to
	 * robots etc. The $ignore array stores the patterns that should be ignored.
	 * 
	 * The $ignore array consists of a number of pattern sets. Each set is matched
	 * against elements of the $vars array. If all the patterns in a set match, we
	 * simply return 'true'. This tells CiviCRM to abend processing, and nothing
	 * is logged.
	 */
	$ignore = array(
		array(
			'message' => 'Invalid value passed to getPayment function',
			'url' => '/civicrm/event/register.*id=[0-9][0-9][0-9]($|[^0-9])',
		),
		array(
			'message' => 'id .* POST .* GET .* is not of the type Positive',
		),
		array(
			'message' => 'Invalid form parameters',
			'url' => '/civicrm/mailing/forward$',
		),
		array(
			'message' => 'Missing (input )?parameters',
			'url' => '/civicrm/mailing/(optout|unsubscribe)$',
		),
	);

	foreach ($ignore as $patternSet) {
		foreach ($patternSet as $element => $pattern) {
			if (preg_match('#' . $pattern . '#i', $vars[$element]) != 1) {
				continue 2;
			}
		}
		return true;
	}

	$vars['ip-details'] = json_decode(file_get_contents("http://ipinfo.io/" . $vars['ip'] . "/json"));
	if ( isset($_SESSION) ) {
		$vars['session'] = $_SESSION;
		unset($vars['session']['CiviCRM']['qfPrivateKey']);
	}

	return false;
}

/*
 * Implementation of hook_civicrm_pre() to capture changes before they're saved
*/
function cbf_civicrm_civicrm_pre( $op, $objectName, $id, &$params ) {
	/*
	 * Whenever an Archived_team ("Past team") is created or edited, ensure
	 * its name includes 'No longer meets: ' and its relationships are
	 * inactive.
	 */
	if ($objectName == 'Household') {
		switch ($op) {
			case 'create':
			case 'edit':
				foreach ($params['contact_sub_type'] as $sub_type) {
					if ($sub_type == 'Archived_team') {
						$archived_team_prefix = 'No longer meets: ';

						if (strpos($params['household_name'], $archived_team_prefix) === false) {
							$params['household_name'] = $archived_team_prefix . $params['household_name'];
						}

						try {
							$get_a = civicrm_api3('Relationship', 'get', array(
									'sequential' => 1,
									'contact_id_a' => $id,
									'is_active' => 1,
							));
							$get_b = civicrm_api3('Relationship', 'get', array(
									'sequential' => 1,
									'contact_id_b' => $id,
									'is_active' => 1,
							));
							$get = array_merge($get_a['values'], $get_b['values']);

							foreach ($get as $relationship) {
								if (isset($relationship['end_date'])) {
									$end_date = $relationship['end_date'];
								} else {
									$end_date = CRM_Utils_Date::getToday();
								}

								$create = civicrm_api3('Relationship', 'create', array(
										'sequential' => 1,
										'id' => $relationship['id'],
										'is_active' => 0,
										'end_date' => $end_date,
								));
							}
						} catch (CiviCRM_API3_Exception $e) {
							;
						}
					}
				}
				break;
		}
	}
}

/*
 * Implementation of hook_civicrm_post() which is called after a db write on some core objects
*/
function cbf_civicrm_civicrm_post( $op, $objectName, $id, &$params ) {
	$ministry_centre_prefix = 'Ministry centre is ';

	/*
	 * Whenever a Participant is created, ensure the contact has a Ministry
	 * Centre tag. If it doesn't, add a tag that corresponds to the Ministry
	 * Centre of the event.
	*/
	if ($objectName == 'Participant') {
		switch ($op) {
			case 'create':
				try {
					$entity_tags = civicrm_api3('EntityTag', 'get', array(
							'sequential' => 1,
							'entity_table' => 'civicrm_contact',
							'entity_id' => $params->contact_id,
					));

					foreach ($entity_tags['values'] as $entity_tag) {
						$tag = civicrm_api3('Tag', 'get', array(
								'sequential' => 1,
								'id' => $entity_tag['tag_id'],
								'return' => 'name',
						));

						if (stristr($tag['values'][0]['name'], $ministry_centre_prefix) !== false) {
							break 2;
						}
					}

					$ministry_centre = _cbf_civicrm_civicrm_event_ministry_centre($params->event_id);

					if (!isset($ministry_centre)) {
						break;
					}

					$tag = civicrm_api3('Tag', 'get', array(
							'sequential' => 1,
							'name' => $ministry_centre_prefix . $ministry_centre,
							'return' => 'id',
					));

					if ($tag['count'] == 1) {
						$create = civicrm_api3('EntityTag', 'create', array(
								'sequential' => 1,
								'entity_table' => 'civicrm_contact',
								'entity_id' => $params->contact_id,
								'tag_id' => $tag['values'][0]['id'],
						));
					}
				} catch (CiviCRM_API3_Exception $e) {
					;
				}
				break;
		}
	}
}

function _cbf_civicrm_civicrm_event_ministry_centre($event_id) {
  $ministry_centre_group_id = 326;
  try {
    $custom_values = civicrm_api3('CustomValue', 'get', array(
        'sequential' => 1,
        'entity_id' => $event_id,
        'entity_table' => 'civicrm_event',
        'id' => 25,
    ));

    $ministry_centre_id = null;
    foreach ($custom_values['values'] as $custom_value) {
      if (isset($custom_value['latest'])
          && isset($custom_value['id'])
          && $custom_value['id'] = '25') {
        $ministry_centre_id = (int) $custom_value['latest'];
        break;
      }
    }

    if ( ! isset($ministry_centre_id) ) {
      return null;
    }

    $ministry_centre = civicrm_api3('OptionValue', 'get', array(
        'sequential' => 1,
        'option_group_id' => $ministry_centre_group_id,
        'value' => $ministry_centre_id,
    ));

    return $ministry_centre['values'][0]['name'];
 
  } catch (CiviCRM_API3_Exception $e) {
    return null;
  }
}

/*
 * A hook that gets called by the AccountSync extension, prior to pulling data
 * from Xero.
 *
 * @param string $entity entity - eg. 'contact'
 * @param array $data data from accounts being processing
 * @param bool $save save? - set this to false if it should be skipped
 * @param $params
 *
 * @return mixed
 *   Ignore value.
 */
function cbf_civicrm_civicrm_accountPullPreSave($entity, &$data, &$save, &$params) {
  switch ($entity) {
    case 'invoice' :
      if (isset($params['contribution_id'])
          && !is_numeric($params['contribution_id'])) {
        /*
         * This invoice was generated in Xero but not by CiviCRM
         */
        try {
          $result = civicrm_api3('Contribution', 'create', array(
              'sequential' => 1,
              'financial_type_id' => 'Donation',
              'total_amount' => $data['Total'],
              'tax_amount' => $data['TotalTax'],
              'contact_id' => $data['Contact']['ContactNumber'],
              'contribution_status_id' => $data['Status'] == 'PAID' ? 'Completed' : 'Pending',
          ));
          $params['contribution_id'] = $data['InvoiceNumber'] = $result['id'];
        } catch (CiviCRM_API3_Exception $e) {
          ;
        }
      }
      break;
  }
}


/*
 * A hook that gets called by the AccountSync extension, prior to pushing data
 * to Xero.
 *
 * @param string $entity entity - eg. 'contact'
 * @param array $data data from accounts being processing
 * @param bool $save save? - set this to false if it should be skipped
 * @param $params
 *
 * @return mixed
 *   Ignore value.
 */
function cbf_civicrm_civicrm_accountPushAlterMapped($entity, &$data, &$save, &$params) {
  switch ($entity) {
    case 'invoice' :
      /*
       * TODO
       *  - Events
       *  - Sales
       *  - Recurring donations - subsequent payments have no custom data
       *  - Don't push contributions derived from Bank Transactions
       */
      if (!empty($data['trxn_id'])) {
        $params['Reference'] = $data['trxn_id'] . ' - ' . $params['Reference'];
      }
      if (!empty($data['contribution_recur_id'])) {
        $params['LineItems']['LineItem'][0]['AccountCode'] = 260;
      }
      /*
       * TODO
       *  - loop over line items
       *  - Use $data['line_items'][][tax_amount] to determine tax type
       *  - Move recurring contribution logic into this loop
       *  - Move tracking code logic into this loop
       *  - If invoice amounts are tax inclusive then unit price should include tax
       *  - fix description
       */
      $params['LineItems']['LineItem'][0]['TaxType'] = 'EXEMPTOUTPUT';
      if (!empty($data['custom_26'])) {
        $params['LineItems']['LineItem'][0]['Tracking'] = array();
        $params['LineItems']['LineItem'][0]['Tracking']['TrackingCategory'] = array();
        $params['LineItems']['LineItem'][0]['Tracking']['TrackingCategory'][]
          = array(
            'Name' => 'Department',
            'Option' => $data['custom_26'],
          );
      } elseif (!empty($data['api.participant_payment.get'])) {
        $event_id = $data['api.participant_payment.get']['values'][0]['api.participant.get']['values'][0]['event_id'];
        $ministry_centre = _cbf_civicrm_civicrm_event_ministry_centre($event_id);
        if (isset($ministry_centre)) {
          $params['LineItems']['LineItem'][0]['Tracking'] = array();
          $params['LineItems']['LineItem'][0]['Tracking']['TrackingCategory'] = array();
          $params['LineItems']['LineItem'][0]['Tracking']['TrackingCategory'][]
            = array(
                'Name' => 'Department',
                'Option' => strtoupper(substr($ministry_centre, 0, 3)),
            );
        }
      }
      if (!empty($data['custom_27'])) {
        $params['LineItems']['LineItem'][] = array('Description' => $data['custom_27']);
      }
      break;
  }
}
