<?php

/*
 *  This hook is called when an email is about to be sent by CiviCRM.
 *  It ensures the email contains no relative links.
 *  It adds the closing tags for the BODY and HTML elements, as these are
 *  left off so CiviMail can add a tracking token to the email.
 */
function cbf_civicrm_civicrm_alterMailParams( &$params, $context = null ) {
    /*
     *  Change relative URLs to absolute.
     */
    $htmlMessage = CRM_Utils_Array::value( 'html', $params );
    if ( $htmlMessage ) {
        /*
         *  Links:  Relative URLs start with a '/' and occur in the HREF attribute of an A element
         *  Images: Relative URLs start with a '/' and occur in the SRC attribute of an IMG element
         *  The '/' is replaced by the CiviCRM User Framework Base URL, which terminates with a '/'
         */
        $config = CRM_Core_Config::singleton( );
        $htmlMessage = str_replace(' href="//', ' href="http://', $htmlMessage);
        $htmlMessage = str_replace(' src="//',  ' src="http://',  $htmlMessage);
        $htmlMessage = str_replace(' href="/',  ' href="'.$config->userFrameworkBaseURL, $htmlMessage);
        $htmlMessage = str_replace(' src="/',   ' src="'.$config->userFrameworkBaseURL,  $htmlMessage);
        /*
         *  Remove empty paragraphs inserted by CKeditor
         */
        $htmlMessage = preg_replace('!<p>(\r\n\t)*&nbsp;</p>!i', '', $htmlMessage);
        /*
         * The CKeditor Image Dialog removes width attributes from HTML IMGs. This causes an issue
         * for responsive email templates when the email is viewed in Outlook. As these images have
         * a CSS style setting their width or max-width to 280px, we reinsert the HTML attribute on
         * images that match that pattern.
         */
        $htmlMessage = preg_replace('!<img ([^w/>][^>]+width: 280px[^>]+)/>!i', '<img width="280" $1/>', $htmlMessage);
        /*
         * The HTML IMGs that have been set to 280px wide will not scale properly if the height
         * attribute is set. We remove that.
         */
        $htmlMessage = preg_replace('!<img width="280" ([^>]+)height: [0-9px%]+[;]?([^>]+)/>!i', '<img width="280" $1$2/>', $htmlMessage);
        /*
         * Look for the closing tag for the BODY element, and add it if needed
         */
        if (stripos($htmlMessage, '</body>') == false) {
            $htmlMessage .= '</body></html>';
        }
        $params['html'] = $htmlMessage;
    }
}

/*
 * This hook is called when a form is being built by CiviCRM.
 * It adds the Credit Card Holder to credit card payment forms, and makes the holder
 * field available on confirmation and thank-you pages. This doesn't work for the
 * event forms since they protect their _param variables.
 * It makes the Billing Name and Address not-required, as these are not presented
 * on CBF payment forms.
 */
function cbf_civicrm_civicrm_buildForm( $formName, &$form ) {
    switch ( $formName ) {

        case 'CRM_Contribute_Form_Contribution':
        case 'CRM_Contribute_Form_Contribution_Main':
        case 'CRM_Event_Form_Participant':
        case 'CRM_Event_Form_Registration_Register':

            // Add a form element for the credit card holder
            // It is required if the credit card number is required
            if ( $form->elementExists('credit_card_number') && 
                !$form->elementExists('credit_card_holder') ) {
                $form->add (
                    'text', 
                    'credit_card_holder', 
                    ts('Card Holder'),
                    array (
                        'size' => 20, 
                        'maxlength' => 30, 
                        'autocomplete' => 'off' ), 
                    $form->isElementRequired('credit_card_number'),
                    null);
            }

            // Assume the person's first and last name are being captured via a profile
            // Make the address optional so donors have less data to supply
            if (isset($form->_bltID)) {
                $bltID = $form->_bltID;
                $unnecessaryFields = array(
                                         "billing_first_name",
                                         "billing_last_name",
                                         "billing_street_address-{$bltID}",
                                         "billing_city-{$bltID}",
                                         "billing_postal_code-{$bltID}",
                                         "billing_state_province_id-{$bltID}",
                                         "billing_country_id-{$bltID}"
                                     );
                $form->_required = array_diff($form->_required, $unnecessaryFields);
                foreach ($unnecessaryFields as $field) {
                    if ( isset($form->_paymentFields[$field]) ) {
                        $form->_paymentFields[$field]['is_required'] = false;
                    }
                }
            }

            if ($formName == 'CRM_Contribute_Form_Contribution_Main') {
                $buttons = $form->getElement('buttons');
                $submit = $buttons->getElements();
                $submit[0]->setValue('Next >>');
            }

            break;

        case 'CRM_Contribute_Form_Contribution_Confirm':
        case 'CRM_Contribute_Form_Contribution_ThankYou':
        case 'CRM_Event_Form_Registration_Confirm':
        case 'CRM_Event_Form_Registration_ThankYou':

            // Set the Credit Card Holder in the Smarty template
            // Clear the Address in the Smarty template
            $tpl = $form->getTemplate();
            $tpl_credit_card_number = $tpl->get_template_vars('credit_card_number'); 
            if ( isset($tpl_credit_card_number) ) {
                if ( isset($form->_params['credit_card_holder']) ) {
                    $form->assign( 'credit_card_holder', $form->_params['credit_card_holder'] );
                } else if ( isset($form->_params[0]) && 
                            isset($form->_params[0]['credit_card_holder']) ) {
                    $form->assign( 'credit_card_holder', $form->_params[0]['credit_card_holder'] );
                }
            }
            $form->assign( 'address', '' );

            if ($formName == 'CRM_Contribute_Form_Contribution_Confirm') {
                $makePaymentLabel = 'Make payment';

                $buttons = $form->getElement('buttons');
                $submit = $buttons->getElements();
                $submit[0]->setValue($makePaymentLabel);

                $tpl->assign('button', $makePaymentLabel);
            }

            break;

        case 'CRM_Mailing_Form_Upload':

            // For CiviMails, unset the From email address when the Subject is empty.
            // This is a roundabout way of unsetting the CiviMail default, to force
            // the user to enter an From address. 
            if ( $form->getElementValue('subject') == null ) {
                $fromAddress = $form->getElement('from_email_address');
                $fromAddress->setSelected(0);
            }
            break;
    }
    return;
}

/*
 * This function is called when a form is being validated by CiviCRM.
 * In cases where the Credit Card Holder field is not-required, it is mandatory if the
 * Credit Card Number has been entered.
 */
function cbf_civicrm_civicrm_validateForm( $formName, &$fields, &$files, &$form, &$errors ) {
    switch ( $formName ) {

        case 'CRM_Contribute_Form_Contribution':
        case 'CRM_Contribute_Form_Contribution_Main':
        case 'CRM_Event_Form_Participant':
        case 'CRM_Event_Form_Registration_Register':
            
            // The credit card holder is required for CC transactions
            // Assume that a credit card payment is being made if the CC number is supplied
            // This test is only required if the Card Holder field exists and is not a required field
            if ( $form->elementExists('credit_card_holder') &&
                !$form->isElementRequired('credit_card_holder') ) {
                $credit_card_number = CRM_Utils_Array::value( 'credit_card_number', $fields );
                $credit_card_holder = CRM_Utils_Array::value( 'credit_card_holder', $fields );
                if ( $credit_card_number && ! $credit_card_holder ) {
                    $errors['credit_card_holder']
                        = ts( 'Card Holder is required if Card Number is supplied' );
                }
            }
            break;

        case 'CRM_Contact_Import_Form_DataSource':

            // The dedupe rule is needed, except when 'No Duplicate Checking' is selected
            $onDuplicate = CRM_Utils_Array::value( 'onDuplicate', $fields );
            foreach ($form->getElement('onDuplicate')->getElements() as $duplicateOption ) {
            	if ( $duplicateOption->getValue() == $onDuplicate ) {
            		break; // We've found the option that's been selected
            	}
            }
            if ( $duplicateOption->getText() <> 'No Duplicate Checking' ) {
                if ( CRM_Utils_Array::value( 'dedupe', $fields ) == '' ) {
                    $errors['dedupe']
                        = ts( 'Dedupe rule must be set, unless there is no duplicate checking' );
                }
            }
            break;
    }
}

/*
 * This function is called before CiviCRM passes payment details to a Payment Processor.
 * The Credit Card Holder is captured.
 * The Purchaser Address details are cleared, since the Billing Address is not captured.
 */
function cbf_civicrm_civicrm_alterPaymentProcessorParams( $paymentObj, &$rawParams, &$cookedParams ) {
    $is_recur           = CRM_Utils_Array::value( 'is_recur',           $rawParams );
    $credit_card_holder = CRM_Utils_Array::value( 'credit_card_holder', $rawParams );
    if ( isset($is_recur) && $is_recur ) {
        if ( $paymentObj instanceof org_civicrm_ewayrecurring ) {
    	    // Set credit card holder
    	    if ( $credit_card_holder ) {
    	        $cookedParams['CCNameOnCard'] = $credit_card_holder;
    	    }
    	    // Set address
    	    $cookedParams['Address']  = 'c/o Level 3, 13-15 Bridge St';
    	    $cookedParams['Suburb']   = 'Sydney';
    	    $cookedParams['State']    = 'NSW';
    	    $cookedParams['PostCode'] = '2000';
        } else if ( $paymentObj instanceof com_chrischinchilla_ewayrecurring ||
                    $paymentObj instanceof CRM_Core_Payment_Ewayrecurring ) {
    	    // Set credit card holder
    	    if ( $credit_card_holder ) {
    	        $cookedParams['man:CCNameOnCard'] = $credit_card_holder;
    	    }
    	    // Set address
    	    $cookedParams['man:Address']  = 'c/o Level 3, 13-15 Bridge St';
    	    $cookedParams['man:Suburb']   = 'Sydney';
    	    $cookedParams['man:State']    = 'NSW';
    	    $cookedParams['man:PostCode'] = '2000';
    	}
    } else {
        if ( $paymentObj instanceof CRM_Core_Payment_eWAY  ||
             $paymentObj instanceof org_civicrm_ewayrecurring  ||
             $paymentObj instanceof com_chrischinchilla_ewayrecurring ||
             $paymentObj instanceof CRM_Core_Payment_Ewayrecurring ) {
            // Set credit card holder
            if ( $credit_card_holder ) {
                $cookedParams->CardHolderName($credit_card_holder);
            }
            // Clear address information
            $cookedParams->PurchaserAddress('');
            $cookedParams->PurchaserPostalCode('');
        }
    }
}

function cbf_civicrm_civicrm_tokens( &$tokens ) {
	$tokens['cbf'] = array( 'cbf.hostname' );
}

function cbf_civicrm_civicrm_tokenValues( &$details, &$contactIDs ) {
    $config = CRM_Core_Config::singleton( );
    $hostname = preg_replace('!^https?://([^/]+)/$!i', '$1', $config->userFrameworkBaseURL);
	if (is_array($contactIDs)) {
		foreach ($details as $id => $detail) {
			$details[$id]['cbf.hostname'] = $hostname;
		}
	} else {
		$details['cbf.hostname'] = $hostname;
	}
}

/*
 * Add extra variables to help with debugging, then return false so
 * the standard error handling continues.
 */
function cbf_civicrm_fatal_error_handler(&$vars) {
	if ( isset($_SERVER['HTTP_X_FORWARDED_FOR']) ) {
		$vars['ip']  = $_SERVER['HTTP_X_FORWARDED_FOR'];
		$vars['url'] = $_SERVER['HTTP_X_FORWARDED_PROTO'] . '://' . $_SERVER['HTTP_X_HOST'] . $_SERVER['REQUEST_URI'];
	} else {
		$vars['ip']  = $_SERVER['REMOTE_ADDR'];
		$vars['url'] = $_SERVER['REQUEST_SCHEME'] . '://' . $_SERVER['SERVER_NAME'] . $_SERVER['REQUEST_URI'];
	}

	/*
	 * There are a number of annoying errors that get logged. They seem to be due to
	 * robots etc. The $ignore array stores the patterns that should be ignored.
	 * 
	 * The $ignore array consists of a number of pattern sets. Each set is matched
	 * against elements of the $vars array. If all the patterns in a set match, we
	 * simply return 'true'. This tells CiviCRM to abend processing, and nothing
	 * is logged.
	 */
	$ignore = array(
		array(
			'message' => 'Invalid value passed to getPayment function',
			'url' => '/civicrm/event/register.*id=[0-9][0-9][0-9]($|[^0-9])',
		),
		array(
			'message' => 'id .* POST .* GET .* is not of the type Positive',
		),
		array(
			'message' => 'Invalid form parameters',
			'url' => '/civicrm/mailing/forward$',
		),
		array(
			'message' => 'Missing (input )?parameters',
			'url' => '/civicrm/mailing/(optout|unsubscribe)$',
		),
	);

	foreach ($ignore as $patternSet) {
		foreach ($patternSet as $element => $pattern) {
			if (preg_match('#' . $pattern . '#i', $vars[$element]) != 1) {
				continue 2;
			}
		}
		return true;
	}

	$vars['ip-details'] = json_decode(file_get_contents("http://ipinfo.io/" . $vars['ip'] . "/json"));
	if ( isset($_SESSION) ) {
		$vars['session'] = $_SESSION;
		unset($vars['session']['CiviCRM']['qfPrivateKey']);
	}

	return false;
}

/*
 * Implementation of hook_civicrm_pre() to capture changes before they're saved
 */
function cbf_civicrm_pre( $op, $objectName, $id, &$params ) {
	if ($objectName == 'Household') {
		switch ($op) {
			case 'create':
			case 'edit':
				foreach ($params['contact_sub_type'] as $sub_type) {
					if ($sub_type == 'Archived_team') {
						$archived_team_prefix = 'No longer meets: ';

						if (strpos($params['household_name'], $archived_team_prefix) === false) {
							$params['household_name'] = $archived_team_prefix . $params['household_name'];
						}

						try {
							$get_a = civicrm_api3('Relationship', 'get', array(
										'sequential' => 1,
										'contact_id_a' => $id,
										'is_active' => 1,
							));
							$get_b = civicrm_api3('Relationship', 'get', array(
									'sequential' => 1,
									'contact_id_b' => $id,
									'is_active' => 1,
							));
							$get = array_merge($get_a['values'], $get_b['values']);

							foreach ($get as $relationship) {
								if (isset($relationship['end_date'])) {
									$end_date = $relationship['end_date'];
								} else {
									$end_date = CRM_Utils_Date::getToday();
								}

								$create = civicrm_api3('Relationship', 'create', array(
										'sequential' => 1,
										'id' => $relationship['id'],
										'is_active' => 0,
										'end_date' => $end_date,
								));
							}
						} catch (CiviCRM_API3_Exception $e) {
							;
						}
					}
				}
				break;
		}
	}

	return;
}
