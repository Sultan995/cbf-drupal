<?php

/******************************************************************************
 * EXTERNAL FUNCTIONS
 */

function cbf_eventbrite_registration_buttons($field_registration_buttons) {

  $buttons = count($field_registration_buttons['#items']);
  $columnCount = [
    'xs' => min(1, $buttons),
//
// Positioning the buttons in a 'tower' rather than across the screen, but keeping
// the original code in case it's ever needed!
//
//    'sm' => min(2, $buttons),
//    'md' => min(3, $buttons),
//    'lg' => min(4, $buttons),
//
  ];
  $columnWidth = [
    1 => 12,
    2 => 6,
    3 => 4,
    4 => 3,
  ];

  $columnClasses = [];
  foreach ($columnCount as $size => $count) {

    $columnClasses[] = "col-{$size}-{$columnWidth[$count]}";
  }

  $columnClasses = implode(' ', $columnClasses);
  $buttons = [];
  $out = "<div class=\"row\">";

  foreach ($field_registration_buttons['#items'] as $i) {

    $buttons[] = $i['value'];
  }

  $buttons = entity_load('paragraphs_item', $buttons);
  $scripts = [];

  foreach ($buttons as $button) {

    $eventId = cbf_field_get_items('paragraphs_item', $button, 'field_event_id', 'value') ?? '';
    $title = cbf_field_get_items('paragraphs_item', $button, 'field_title', 'safe_value');
    $buttonType = cbf_field_get_items('paragraphs_item', $button, 'field_event_registration_type', 'tid');
    $buttonType = taxonomy_term_load($buttonType);
    $buttonType = $buttonType->name ?? 'Empty';
    $b = _cbf_eventbrite_button_type($buttonType, $button->item_id, $eventId);

    if ($b['supported'] && !$b['template']) {

      $out .= "<div class=\"field-registration-buttons {$columnClasses}\">";
      $out .= "<{$b['html element']} id=\"{$b['html id']}\" {$b['href']} class=\"btn btn-mod btn-border btn-medium btn-round\">{$title}</{$b['html element']}>";
      $out .= "</div>";

      $scripts = array_merge($scripts, $b['scripts']);
    }
  }

  $out .= "</div>";

  foreach ($scripts as $script) {
    drupal_add_js($script['data'], $script['options']);
  }

  return $out;
}

/******************************************************************************
 * HOOK IMPLEMENTATIONS
 */

/*
 * Implements hook_node_validate()
 *
 * "Perform node validation before a node is created or updated. This hook is
 * invoked from node_validate(), after a user has finished editing the node and
 * is previewing or submitting it. It is invoked at the end of all the standard
 * validation steps, and after the type-specific hook_validate() is invoked. To
 * indicate a validation error, use form_set_error(). Note: Changes made to the
 * $node object within your hook implementation will have no effect. The
 * preferred method to change a node's content is to use hook_node_presave()
 * instead. If it is really necessary to change the node at the validate stage,
 * you can use form_set_value()"
 */
function cbf_eventbrite_node_validate($node, $form, &$form_state) {

  if ($node->type == 'brite_event') {

    $buttons = cbf_field_get_items('node', $node, 'field_registration_buttons', 'entity', []);

    foreach ($buttons as $i => $button) {

      if (is_object($button) && ($button->removed ?? 0) != 1) {

        $buttonType = cbf_field_get_items('paragraphs_item', $button, 'field_event_registration_type', 'tid');
        $buttonType = taxonomy_term_load($buttonType);
        $buttonType = $buttonType->name ?? 'Empty';

        $eventId = cbf_field_get_items('paragraphs_item', $button, 'field_event_id', 'value');
        $eventId = trim($eventId);

        $b = _cbf_eventbrite_button_type($buttonType, $button->item_id ?? '', $eventId);

        if ($b['supported'] == false) {

          $element = "field_registration_buttons][und][$i][field_event_registration_type][und][0][tid";
          form_set_error($element, "Button type '$buttonType' not supported");
        }

        $template = cbf_field_get_items('paragraphs_item', $button, 'field_event_template', 'tid');
        $template = taxonomy_term_load($template);
        $template = $template->description ?? '';
        $template = $template + 0;

        $organiser = cbf_field_get_items('paragraphs_item', $button, 'field_event_organiser', 'tid');
        $organiser = taxonomy_term_load($organiser);
        $organiser = $organiser->name ?? '';

        $price = cbf_field_get_items('paragraphs_item', $button, 'field_event_option_price', 'amount');

        if ($b['template']) {

          $storedNode = &drupal_static('cbf_eventbrite_node_validate');
          $storedNode = $node;

          if (empty($template)) {

            $element = "field_registration_buttons][und][$i][field_event_template][und][0][tid";
            form_set_error($element, 'Need to select an event template if registration button is a template');
          }

          if (empty($organiser)) {

            $element = "field_registration_buttons][und][$i][field_event_organiser][und][0][tid";
            form_set_error($element, 'Need to select an event organiser if registration button is a template');
          }

          if (!isset($price)) {

            $element = "field_registration_buttons][und][$i][field_event_option_price][und][0][amount";
            form_set_error($element, 'Need to set a price if registration button is a template');
          }
        }
        else {

          $matches = [];
          preg_match($b['pattern'], $eventId, $matches);

          if (empty($matches) || empty($matches[$b['id match']])) {

            $element = "field_registration_buttons][und][$i][field_event_id][und][0][value";
            form_set_error($element, $b['message']);
          }

          if (!empty($template)) {

            $element = "field_registration_buttons][und][$i][field_event_template][und][0][tid";
            form_set_error($element, 'Do not select an event template if registration button is not a template');
          }

          if (!empty($organiser)) {

            $element = "field_registration_buttons][und][$i][field_event_organiser][und][0][tid";
            form_set_error($element, 'Do not select an event organiser if registration button is not a template');
          }

          if (isset($price)) {

            $element = "field_registration_buttons][und][$i][field_event_option_price][und][0][amount";
            form_set_error($element, 'Do not set a price if registration button is not a template');
          }
        }
      }
    }

    $locationCount = count($node->locations);

    foreach ($node->locations as $i => $location) {

      if (
        $location['delete_location'] ?? false
        ||
        (
          empty($location['name']) &&
          empty($location['street']) &&
          empty($location['city']) &&
          empty($location['province']) &&
          empty($location['postal_code']) &&
          empty($location['locpick']['user_latitude']) &&
          empty($location['locpick']['user_longitude'])
        )
      ) {

        $locationCount--;
      }
    }

    if ($locationCount > 1) {

      $element = "locations][1][street";
      form_set_error($element, 'Multiple locations for an event are not yet supported');
    }
  }
}

/*
 * Implements hook_entity_presave
 *
 * "Act on an entity before it is about to be created or updated."
 *
 */
function cbf_eventbrite_entity_presave($entity, $type) {
  /*
   * If $entity is an event_registration paragraphs_item, then either convert
   * the Eventbrite template to an Event Id, or ensure the Event Id is in the
   * canonical form.
   */
  if ($type == 'paragraphs_item' && $entity->bundle == 'event_registration') {

    $buttonType = cbf_field_get_items($type, $entity, 'field_event_registration_type', 'tid');
    $buttonType = taxonomy_term_load($buttonType);
    $buttonType = $buttonType->name ?? 'Empty';

    if ($buttonType == 'EventBrite template') {

      $storedNode = &drupal_static('cbf_eventbrite_node_validate');
      $eventId = _cbf_eventbrite_create_event_from_template($entity, $storedNode);

      if ($eventId) {

        $eventbriteEvent = taxonomy_get_term_by_name('EventBrite event', 'event_registration_type');

        $entity->field_event_id['und'] = [ 0 => [ 'value' => $eventId ]];
        $entity->field_event_registration_type['und'][0]['tid'] = reset($eventbriteEvent)->tid;
        $entity->field_event_template['und'] = [];
        $entity->field_event_organiser['und'] = [];
        $entity->field_event_option_price['und'] = [];
      }
    }
    else {

      $eventId = cbf_field_get_items($type, $entity, 'field_event_id', 'value');
      $eventId = trim($eventId);
      $canonicalForm = '/^[\d]+$/';
      $matches = [];
      preg_match($canonicalForm, $eventId, $matches);

      if (empty($matches) || $matches[0] != $eventId) {

        $b = _cbf_eventbrite_button_type($buttonType, $entity->item_id ?? '', $eventId);

        preg_match($b['pattern'], $eventId, $matches);

        if (!empty($matches[$b['id match']])) {

          $eventId = $matches[$b['id match']];
        }
      }

      if (isset($entity->field_event_id['und'][0]['value'])) {

        $entity->field_event_id['und'][0]['value'] = $eventId;
      }
    }
  }

  /*
   * If $entity is a brite_event node, set the Location from the EventBrite
   * event venue, unless overridden.
   */
  if ($type == 'node' && $entity->type == 'brite_event') {

    $buttons = cbf_field_get_items($type, $entity, 'field_registration_buttons', 'value', []);
    $buttons = entity_load('paragraphs_item', $buttons);
    $events = [];

    foreach ($buttons as $button) {

      $buttonType = cbf_field_get_items('paragraphs_item', $button, 'field_event_registration_type', 'tid');
      $buttonType = taxonomy_term_load($buttonType);
      $buttonType = $buttonType->name ?? 'Empty';

      if ($buttonType == 'EventBrite event' ||
          $buttonType == 'EventBrite event (new window)')
      {

        $eventId = cbf_field_get_items('paragraphs_item', $button, 'field_event_id', 'value');
        $events[] = _cbf_eventbrite_get_event($eventId);
      }
    }

    $overrideLocation = cbf_field_get_items($type, $entity, 'field_override_location', 'value', false);

    if (!$overrideLocation) {

      foreach ($events as $event) {

        if (!empty($event->venue)) {

          $location = [];
          $location['name'] = $event->venue->name;
          $location['street'] = $event->venue->address->address_1;
          $location['additional'] = $event->venue->address->address_2;
          $location['city'] = $event->venue->address->city;
          $location['province'] = $event->venue->address->region;
          $location['postal_code'] = $event->venue->address->postal_code;
          $location['latitude'] = $event->venue->latitude;
          $location['longitude'] = $event->venue->longitude;

          foreach ($entity->locations[0] as $locationField => $_) {

            if (isset($location[$locationField])) {

              $entity->locations[0][$locationField] = $location[$locationField];
            }
            else if ($locationField == 'locpick') {

              $entity->locations[0]['locpick']['user_latitude'] = $location['latitude'];
              $entity->locations[0]['locpick']['user_longitude'] = $location['longitude'];
            }
          }
          break;
        }
      }
    }
  }
}

/******************************************************************************
 * INTERNAL FUNCTIONS
 */

function _cbf_eventbrite_button_type(string $buttonType, string $buttonId, string $eventId) {

  switch ($buttonType) {

    case 'EventBrite event':
      $supported = true;
      $template = false;
      $pattern = '!^(.+eventbrite.+/e/(.+-)?)?(\d+)(/)?$!i';
      $idMatch = 3;
      $message = 'Must be an EventBrite event URL or an event number';
      $element = 'button';
      $href = '';
      $htmlId = "cbf-eventbrite-event-$buttonId-$eventId";
      $scripts = [
        'EventBrite event' => [
          'data' => 'https://www.eventbrite.com.au/static/widgets/eb_widgets.js',
          'options' => ['type' => 'external'],
        ],
        "$buttonId-$eventId" => [
          'data' =>
            "var callback_{$buttonId}_{$eventId} = function() {
              console.log('Order complete!');
            };

            window.EBWidgets.createWidget({
              widgetType: 'checkout',
              eventId: '$eventId',
              modal: true,
              modalTriggerElementId: '$htmlId',
              onOrderComplete: callback_{$buttonId}_{$eventId}
            });",
          'options' => [
            'type' => 'inline',
            'scope' => 'footer',
          ],
        ],
      ];
      break;

    case 'EventBrite template':
      $supported = true;
      $template = true;
      $pattern = '';
      $idMatch = 0;
      $message = '';
      $element = '';
      $href = '';
      $htmlId = '';
      $scripts = [];
    break;

    case 'EventBrite event (new window)':
      $supported = true;
      $template = false;
      $pattern = '!^(.+eventbrite.+/e/(.+-)?)?(\d+)(/)?$!i';
      $idMatch = 3;
      $message = 'Must be an EventBrite event URL or an event number';
      $element = 'a';
      $href = "href=\"https://www.eventbrite.com/e/$eventId\"";
      $htmlId = "cbf-eventbrite-event-$buttonId-$eventId";
      $scripts = [];
      break;

    case 'CiviCRM event':
      $supported = true;
      $template = false;
      $pattern = '!^(.+/civicrm-event/)?(\d+)$!i';
      $idMatch = 2;
      $message = 'Must be a CiviCRM URL or a CiviEvent number';
      $element = 'a';
      $href = "href=\"/civicrm/event/register?reset=1&id=$eventId\"";
      $htmlId = "cbf-eventbrite-civicrm-event-$buttonId-$eventId";
      $scripts = [];
      break;

    case 'Other':
      $supported = true;
      $template = false;
      $pattern = '!^https?://.+$!i';
      $idMatch = 0;
      $message = 'Must be an URL';
      $element = 'a';
      $href = "href=\"$eventId\"";
      $htmlId = "cbf-eventbrite-other-$buttonId";
      $scripts = [];
      break;

    default:
      $supported = false;
      $template = false;
      $pattern = '!^Cannot check$!i';
      $idMatch = 0;
      $message = "Cannot check Event Id '$eventId' as its type is not supported";
      $element = 'unknown';
      $href = '';
      $htmlId = "cbf-eventbrite-unsupported-$buttonId-$eventId";
      $scripts = [];
      break;
  }

  return [
    'supported' => $supported,  // Is this button type supported?
    'template' => $template,    // Is this button type a template?
    'pattern' => $pattern,      // What is the pattern accepted for Event ID?
    'id match' => $idMatch,     // Which part of the pattern is the Event ID?
    'message' => $message,      // What message if validation fails?
    'html element' => $element, // What HTML element is this?
    'href' => $href,            // What is the registration URL?
    'html id' => $htmlId,       // What is the HTML element's Id?
    'scripts' => $scripts,      // What scripts should be inserted on the page?
  ];
}

function _cbf_eventbrite_get_event(string $id) {
  $steps = [
    "Get event $id" => [
      'method' => 'GET',
      'endpoint' => "events/$id?expand=ticket_availability,venue",
      '200' => 'success',
      '404' => 'failure',
      'result' => 'event',
    ],
  ];

  $result = _cbf_eventbrite_use_api($steps);

  return $result['event'] ?? false;
}

function _cbf_eventbrite_use_api(array $steps) {
  $api = 'https://www.eventbriteapi.com/v3/';
  $headers = [
    'Authorization' => 'Bearer ' . variable_get('cbf_eventbrite_token'),
    'Content-Type' => 'application/json',
  ];
  $result = [
    'progress' => [],
  ];
  $stop = false;
  $status = WATCHDOG_INFO;

  foreach ($steps as $stepName => $step) {
    $httpOptions = [
      'headers' => $headers,
      'method' => $step['method'],
    ];
    if (isset($step['data'])) {
      $httpOptions['data'] = json_encode($step['data']);
    }
    $httpResult = drupal_http_request($api . $step['endpoint'], $httpOptions);
    $httpResponse = json_decode($httpResult->data);

    $result[$step['result']] = $httpResponse;

    switch ($step[$httpResult->code] ?? $httpResult->code) {

      case 'next':
        $result['progress'][] = "$stepName succeeded. Continuing...";
        break;

      case 'success':
        $result['progress'][] = "$stepName succeeded. Stopping.";
        $stop = true;
        break;

      case 'warning':
        $result['progress'][] = "$stepName had an issue. Continuing...";
        break;

      case 'failure':
        $result['progress'][] = "$stepName failed. Stopping.";
        $stop = true;
        $status = WATCHDOG_ERROR;
        break;

      default:  // Unexpected response
        $result['progress'][] = "$stepName had an unexpected result. Stopping.";
        $stop = true;
        $status = WATCHDOG_ERROR;
        break;
    }

    watchdog('CBF', 'EventBrite API: ' . implode(' ', $result['progress']), null, $status);

    if ($stop) {
      break;
    }
  }

  return $result;
}

function _cbf_eventbrite_create_event_from_template($button, $node) {

  $template = cbf_field_get_items('paragraphs_item', $button, 'field_event_template', 'tid');
  $template = taxonomy_term_load($template);
  $template = $template->description ?? '';
  $template = $template + 0;

  $organiser = cbf_field_get_items('paragraphs_item', $button, 'field_event_organiser', 'tid');
  $organiser = taxonomy_term_load($organiser);
  $organiser = $organiser->name ?? '';

  $price = cbf_field_get_items('paragraphs_item', $button, 'field_event_option_price', 'amount');

  $name = cbf_field_get_items('paragraphs_item', $button, 'field_title', 'value');
  $name = "{$node->title} - {$name}";

  $summary = cbf_field_get_items('node', $node, 'field_subtitle', 'value', '');

  $field_event_date = cbf_field_get_items('node', $node, 'field_event_date', false, []);

  $fail = [];
  if (!$organiser) {
    $fail[] = 'Event organiser not set';
  }
  if (!isset($field_event_date[0]) || !is_array($field_event_date[0])) {
    $fail[] = 'Event date not set';
  }
  if (isset($field_event_date[1]) && is_array($field_event_date[1])) {
    $fail[] = 'Event date is repeating';
  }

  if ($fail) {

    $message = 'Not ready to EventBrite Template button to an event: ' . implode('; ', $fail);
    drupal_set_message($message, 'error');
    watchdog('CBF', $message, null, WATCHDOG_ERROR);
    return 0;
  }

  $timezone = $field_event_date[0]['timezone'];

  $time = new DateObject($field_event_date[0]['value'], $timezone);
  $stamp = strtotime($time->format('Y-m-d H:i:s O'));
  $time = new DateObject($stamp, 'UTC');
  $start = $time->format('Y-m-d\TH:i:s\Z');

  $time = new DateObject($field_event_date[0]['value2'], $timezone);
  $stamp = strtotime($time->format('Y-m-d H:i:s O'));
  $time = new DateObject($stamp, 'UTC');
  $end = $time->format('Y-m-d\TH:i:s\Z');

  $result = _cbf_pipedream_invoke_workflow(
    'POST',
    variable_get('cbf_pipedream_event_copy_url'),
    [
      'template' => $template,
      'name' => $name,
      'summary' => $summary,
      'start_date' => $start,
      'end_date' => $end,
      'timezone' => $timezone,
      'organiser' => $organiser,
      'price' => $price,
    ]);

  if ($result['code'] != '200') {
    $fail[] = 'Failed to talk to Pipedream';
  }
  else if ($result['response']->id == 0) {
    $fail[] = "Eventbrite says '{$result['response']->error} - {$result['response']->error_description}'";
  }

  if ($fail) {

    $message = "Failed when converting EventBrite Template button to an event: " . implode('; ', $fail);
    drupal_set_message($message, 'error');
    watchdog('CBF', $message, null, WATCHDOG_ERROR);
    return 0;
  }
  else {

    return $result['response']->id;
  }
}
