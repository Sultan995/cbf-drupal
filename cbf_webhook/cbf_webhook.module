<?php
/*
 * This hook is called at the beginning of a Drupal page request.
 */
function cbf_webhook_init() {

  /*
   * If the site is in maintenance_mode the default Drupal behaviour is to
   * return maintenance_mode content and return a status of 200. The system
   * invoking the webhook will interpret the 200 to mean the webhook has been
   * processed correctly.
   *
   * This hook returns a 503 status code indicating ...
   *
   * "The server is currently unable to handle the request due to a temporary
   * overloading or maintenance of the server. The implication is that this is
   * a temporary condition which will be alleviated after some delay."
   *   -- https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
   */

  if (arg(0) == 'webhook') {
    if (variable_get('maintenance_mode', 0)) {
      drupal_add_http_header('Status', '503 Service Unavailable');
      drupal_exit();
    }
  }
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function cbf_webhook_ctools_plugin_directory($module, $type) {
  if ('webhook' == $module) {
    return "plugins/{$type}";
  }
}

/**
 * Implements hook_webhook_processor().
 */
function cbf_webhook_webhook_processor() {

  $path = drupal_get_path('module', 'cbf_webhook') . '/plugins/processor';
  $plugins = [];

  $plugins['thinkific'] = [
    'title' => t('Thinkific'),
    'processor' => [
      'path' => $path,
      'file' => 'CBF_Webhook_Processor_Thinkific.class.inc',
      'class' => 'CBF_Webhook_Processor_Thinkific',
    ],
  ];

  $plugins['feedback'] = [
    'title' => t('Feedback form'),
    'processor' => [
      'path' => $path,
      'file' => 'CBF_Webhook_Processor_Feedback.class.inc',
      'class' => 'CBF_Webhook_Processor_Feedback',
    ],
  ];

  return $plugins;
}

/**
 * Implements hook_webhook_unserializer().
 */
function cbf_webhook_webhook_unserializer() {

  $path = drupal_get_path('module', 'cbf_webhook') . '/plugins/unserializer';
  $plugins = [];

  $plugins['thinkific_json'] = [
    'title' => t('Thinkific JSON'),
    'unserializer' => [
      'path' => $path,
      'file' => 'CBF_Webhook_Unserializer_Thinkific.class.inc',
      'class' => 'CBF_Webhook_Unserializer_Thinkific',
    ],
  ];

  $plugins['zapier_json'] = [
    'title' => t('Zapier JSON'),
    'unserializer' => [
      'path' => $path,
      'file' => 'CBF_Webhook_Unserializer_Zapier.class.inc',
      'class' => 'CBF_Webhook_Unserializer_Zapier',
    ],
  ];

  return $plugins;
}

/*
 */
function _cbf_webhook_find_existing_contact($id, $firstName, $lastName, $email, $mobile, &$progress) {

  $last9digits = substr(preg_replace('/[^0-9]/', '', $mobile), -9);
  if (!is_numeric($last9digits) || $last9digits < 100000000) {
    $last9digits = '';
  }

  $target = null;

  if ($id) {

    $contacts = \Civi\Api4\Contact::get(false)
    ->addSelect('id')
    ->addWhere('id', '=', $id)
    ->setLimit(1)
    ->execute();
    foreach ($contacts as $contact) {
      $target = $contact;
    }
  }
  else if ($firstName && $lastName && ($email || $last9digits)) {

    $contacts = \Civi\Api4\Contact::get(false)
    ->addSelect('id', 'first_name', 'last_name', 'nick_name', 'email.email', 'phone.phone_numeric')
    ->addJoin('Email AS email', 'LEFT')
    ->addJoin('Phone AS phone', 'LEFT')
    ->addClause('OR', ['first_name', '=', $firstName], ['nick_name', 'CONTAINS', $firstName])
    ->addClause('OR', ['last_name', '=', $lastName], ['nick_name', 'CONTAINS', $lastName]);
    if ($last9digits) {
      if ($email) {
        $contacts = $contacts->addClause('OR', ['email.email', '=', $email], ['phone.phone_numeric', 'CONTAINS', $last9digits]);
      }
      else {
        $contacts = $contacts->addWhere('phone.phone_numeric', 'CONTAINS', $last9digits);
      }
    }
    else {
      $contacts = $contacts->addWhere('email.email', '=', $email);
    }
    $contacts = $contacts->execute();
    $potentials = [];
    foreach ($contacts as $contact) {
      // Tighten the search conditions to avoid false positives due to use of CONTAINS
      if (strtolower($firstName) != strtolower($contact['first_name'])
        && !stristr(' ' . $contact['nick_name'] . ',', ' ' . $firstName . ',')) {
          $progress[] = 'Contact ' . $contact['id'] . ' nickname doesn\'t match first name';
          continue;
      }
      if (strtolower($lastName) != strtolower($contact['last_name'])
        && !stristr(' ' . $contact['nick_name'] . ',', ' ' . $lastName . ',')) {
          $progress[] = 'Contact ' . $contact['id'] . ' nickname doesn\'t match last name';
          continue;
      }
      $found9digits = substr(preg_replace('/[^0-9]/', '', $contact['phone.phone_numeric']), -9);
      if (!is_numeric($found9digits) || $found9digits < 100000000) {
        $found9digits = '';
      }
      if ($last9digits && $last9digits != $found9digits) {
        if (!$email || $email != $contact['email.email']) {
          $progress[] = 'Contact ' . $contact['id'] . ' phone doesn\'t match mobile';
          continue;
        }
      }
      // Record the $potentials in such a way that there is only one $contact per 'id'
      $potentials[$contact['id']] = $contact;
    }
    switch (count($potentials)) {
      case 0:
        break;
      case 1:
        $target = reset($potentials);
        break;
      default:
        $progress[] = 'Found ' . count($potentials) . ' matching contacts so not safe to choose one of them';
        break;
    }
  }

  return $target;
}
