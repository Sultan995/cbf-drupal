<?php
/*
 * This hook is called at the beginning of a Drupal page request.
 */
function cbf_webhook_init() {

  /*
   * If the site is in maintenance_mode the default Drupal behaviour is to
   * return maintenance_mode content and return a status of 200. The system
   * invoking the webhook will interpret the 200 to mean the webhook has been
   * processed correctly.
   *
   * This hook returns a 503 status code indicating ...
   *
   * "The server is currently unable to handle the request due to a temporary
   * overloading or maintenance of the server. The implication is that this is
   * a temporary condition which will be alleviated after some delay."
   *   -- https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
   */

  if (arg(0) == 'webhook') {
    if (variable_get('maintenance_mode', 0)) {
      drupal_add_http_header('Status', '503 Service Unavailable');
      drupal_exit();
    }
  }
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function cbf_webhook_ctools_plugin_directory($module, $type) {
  if ('webhook' == $module) {
    return "plugins/{$type}";
  }
}

/**
 * Implements hook_webhook_processor().
 */
function cbf_webhook_webhook_processor() {

  $path = drupal_get_path('module', 'cbf_webhook') . '/plugins/processor';
  $plugins = [];

  $plugins['thinkific'] = [
    'title' => t('Thinkific'),
    'processor' => [
      'path' => $path,
      'file' => 'CBF_Webhook_Processor_Thinkific.class.inc',
      'class' => 'CBF_Webhook_Processor_Thinkific',
    ],
  ];

  $plugins['feedback'] = [
    'title' => t('Feedback form'),
    'processor' => [
      'path' => $path,
      'file' => 'CBF_Webhook_Processor_Feedback.class.inc',
      'class' => 'CBF_Webhook_Processor_Feedback',
    ],
  ];

  return $plugins;
}

/**
 * Implements hook_webhook_unserializer().
 */
function cbf_webhook_webhook_unserializer() {

  $path = drupal_get_path('module', 'cbf_webhook') . '/plugins/unserializer';
  $plugins = [];

  $plugins['thinkific_json'] = [
    'title' => t('Thinkific JSON'),
    'unserializer' => [
      'path' => $path,
      'file' => 'CBF_Webhook_Unserializer_Thinkific.class.inc',
      'class' => 'CBF_Webhook_Unserializer_Thinkific',
    ],
  ];

  $plugins['zapier_json'] = [
    'title' => t('Zapier JSON'),
    'unserializer' => [
      'path' => $path,
      'file' => 'CBF_Webhook_Unserializer_Zapier.class.inc',
      'class' => 'CBF_Webhook_Unserializer_Zapier',
    ],
  ];

  return $plugins;
}

/*
 * Find an existing contact, either by Id or by First+Last+(EMail|Mobile). The
 * latter emulates the CBF standard dedupe rule for individuals.
 */
function _cbf_webhook_find_existing_contact($id, $firstName, $lastName, $email, $mobile, &$progress) {

  $last9digits = substr(preg_replace('/[^0-9]/', '', $mobile), -9);
  if (!is_numeric($last9digits) || $last9digits < 100000000) {
    $last9digits = '';
  }

  $potentials = null;
  $target = null;

  if ($id) {

    $contacts = \Civi\Api4\Contact::get(false)
    ->addSelect('id')
    ->addWhere('id', '=', $id)
    ->setLimit(1)
    ->execute();
    foreach ($contacts as $contact) {
      $target = $contact;
    }
  }
  else if ($firstName && $lastName && ($email || $last9digits)) {

    $contacts = \Civi\Api4\Contact::get(false)
    ->addSelect('id', 'first_name', 'last_name', 'nick_name', 'email.email', 'phone.phone_numeric')
    ->addJoin('Email AS email', 'LEFT')
    ->addJoin('Phone AS phone', 'LEFT')
    ->addClause('OR', ['first_name', '=', $firstName], ['nick_name', 'CONTAINS', $firstName])
    ->addClause('OR', ['last_name', '=', $lastName], ['nick_name', 'CONTAINS', $lastName]);
    if ($last9digits) {
      if ($email) {
        $contacts = $contacts->addClause('OR', ['email.email', '=', $email], ['phone.phone_numeric', 'CONTAINS', $last9digits]);
        $progress[] = "Searching for contacts with first/nick='$firstName', last/nick='$lastName', and email='$email' or phone digits contain '$last9digits'";
      }
      else {
        $contacts = $contacts->addWhere('phone.phone_numeric', 'CONTAINS', $last9digits);
        $progress[] = "Searching for contacts with first/nick='$firstName', last/nick='$lastName', and phone digits contain '$last9digits'";
      }
    }
    else {
      $contacts = $contacts->addWhere('email.email', '=', $email);
      $progress[] = "Searching for contacts with first/nick='$firstName', last/nick='$lastName', and email='$email'";
    }

    $potentials = [];
    $contacts = $contacts->execute();
    foreach ($contacts as $contact) {
      /*
       * The use of CONTAINS in \Civi\Api4\Contact::get() is not specific
       * enough. Tighten the search conditions to avoid false positives.
       */
      if (strcasecmp($firstName, $contact['first_name'])) {
        if (!stristr(' ' . $contact['nick_name'] . ',', ' ' . $firstName . ',')) {
          $progress[] = "Contact {$contact['id']} firstname and nickname don't match '$firstName'";
          continue;
        }
      }
      if (strcasecmp($lastName, $contact['last_name'])) {
        if (!stristr(' ' . $contact['nick_name'] . ',', ' ' . $lastName . ',')) {
          $progress[] = "Contact {$contact['id']} lastname and nickname don't match '$lastName'";
          continue;
        }
      }
      $found9digits = substr(preg_replace('/[^0-9]/', '', $contact['phone.phone_numeric']), -9);
      if (!is_numeric($found9digits) || $found9digits < 100000000) {
        $found9digits = '';
      }
      if ($last9digits && $last9digits != $found9digits) {
        if (!$email || $email != $contact['email.email']) {
          $progress[] = "Contact {$contact['id']} phone digits don't match '$last9digits'";
          continue;
        }
      }
      /*
       * Record the $potentials in such a way that there is only one $contact
       * per 'id'. This \Civi\Api4\Contact::get() can return multiple $contacts
       * with the same 'id'.
       */
      $potentials[$contact['id']] = $contact;
    }

    switch (count($potentials)) {
      case 0:
        $progress[] = 'No existing contact found';
        break;
      case 1:
        $target = reset($potentials);
        break;
      default:
        $progress[] = 'Found ' . count($potentials) . ' matching contacts but it is not safe to choose one of them';
        break;
    }
  }

  if (!$target && $potentials === null) {
    $progress[] = 'Not enough information provided to find an existing contact';
  }

  return $target;
}
