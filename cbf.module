<?php

/*
 * This hook is called at the beginning of a Drupal page request.
 */
function cbf_init() {
  if (arg(0) == 'node') {
    if (arg(1) == 'add') {
      /*
       * This JavaScript sets some defaults when adding new nodes.
       *  1. Tablefield fields default to plain text
       *  2. The File Field source is ICME to encourage reuse
       */
      $script = 'jQuery(document).ready(function(){
        jQuery(".field-type-tablefield .filter-wrapper select.filter-list option").each(function() {
          this.selected = (this.text == "Plain text");
        });
        jQuery(".filefield-source-imce").click();
      });';
      drupal_add_js($script, 'inline');
    }
    elseif (is_numeric(arg(1)) && arg(2) == 'edit') {
      /*
       * This JavaScript sets some defaults when editing nodes.
       *  1. The File Field source is ICME to encourage reuse
       */
      $script = 'jQuery(document).ready(function(){
        jQuery(".filefield-source-imce").click();
      });';
      drupal_add_js($script, 'inline');
    }
  }
  return array();
}

/*
 * Implements Drupal hook_form_alter().
 *
 * "Perform alterations before a form is rendered"
 */
function cbf_form_alter(&$form, &$form_state, $form_id) {
  /*
   * Make the indenting of topics more obvious on the National Library view's
   * exposed filter form. Replace leading hyphens with em-spaces.
   */
  if ($form['#id'] == 'views-exposed-form-national-library-page-1'
    && $form_id == 'views_exposed_form'
    && isset($form['field_topic_tid']['#options'])) {
    $emsp = json_decode('"\u2003"');
    foreach ($form['field_topic_tid']['#options'] as $i => $v) {
      foreach ($v->option as $j => $s) {
        if (preg_match_all('/^([-]+)([^-].*)/', $s, $matches) == 1) {
          $t = $matches[2][0];
          for ($k = strlen($matches[1][0]); $k > 0; $k--) {
            $t = $emsp . $t;
          }
          $form['field_topic_tid']['#options'][$i]->option[$j] = $t;
        }
      }
    }
  }

  /*
   * Set the text format for CiviCRM Event entity properties
   * which are presented in an HTML editor.
   */
  if ($form['#id'] == 'civicrm-event-form') {
    $formatTextFields = array(
      'Textarea' => array(
        'fields' => array(
          'summary',
        ),
        'actions' => array(
          '#type' => 'textarea',
          '#format' => null,
        ),
      ),
      'Full HTML' => array(
        'fields' => array(
          'description',
          'event_full_text',
          'intro_text',
          'footer_text',
          'confirm_text',
          'confirm_footer_text',
        ),
        'actions' => array(
          'format' => 'full_html',
          '#format' => null,
        ),
      ),
    );
    foreach ($formatTextFields as $step) {
      foreach ($step['fields'] as $field) {
        foreach ($step['actions'] as $key => $value) {
          if ($value === null) {
            unset($form[$field][$key]);
          }
          else {
            $form[$field][$key] = $value;
          }
        }
      }
    }
  }

  /*
   * When editing a CiviCRM Event entity we need to keep the Drupal and CiviCRM
   * staff contact fields in sync. If there is a Drupal field, this takes
   * precedence.
   *
   * The CiviCRM custom field for the staff contact is displayed as the text
   * the text name of the contact, but when the form is saved, the contact
   * Id is expected.
   */
  if ($form['#id'] == 'civicrm-event-form') {
    $id = null;
    $drupalContact = null;
    $civicrmContact = null;
    $matches = null;

    /* Try getting the contact Id from the Drupal field for the staff contact */
    $drupalContact = $form['field_staff_contact']['und'][0]['contact_id']['#default_value'];
    if (preg_match('!(.+) \[cid:([0-9]+)\]!', $drupalContact, $matches) === 1) {
      $id = $matches[2];
    }

    /* Try getting the contact from CiviCRM */
    if (empty($id)) {
      $civicrmContact = _cbf_civicrm_civicrm_event_staff_contact($form_state['civicrm_event']->id);
      if (!empty($civicrmContact)) {
        $id = $civicrmContact['id'];
      }
    }

    if (!empty($id)) {
      $form['custom_62']['#default_value'] = $id;
      if (empty($drupalContact) && !empty($civicrmContact)) {
        $form['field_staff_contact']['und'][0]['contact_id']['#default_value']
          = $civicrmContact['name'] . ' [cid:' . $id . ']';
      }
    }
  }

  /*
   * When editing a CiviCRM Event entity we need to keep the Drupal and CiviCRM
   * ministry centre fields in sync. If there is a Drupal field, this takes
   * precedence.
   */
  if ($form['#id'] == 'civicrm-event-form') {
    $drupalId = null;

    /* Try getting the ministry centre from the Drupal field for the staff contact */
    if (!empty($form['taxonomy_vocabulary_1']['und']['#default_value'][0])) {
      $drupalId = $form['taxonomy_vocabulary_1']['und']['#default_value'][0];
    }

    /* Try getting the ministry centre from CiviCRM */
    if (empty($drupalId)) {
      list($civicrmId, $civicrmCentre) = _cbf_civicrm_civicrm_event_ministry_centre($form_state['civicrm_event']->id);

      if (!empty($civicrmId)) {
        $form['taxonomy_vocabulary_1']['und']['#default_value'][0] = array_flip($form['taxonomy_vocabulary_1']['und']['#options'])[$civicrmCentre];
      }
    }
  }

  /*
   * When editing a CiviCRM Event entity we need to keep the Drupal and CiviCRM
   * event dates in sync. If there is a Drupal field, this takes precedence.
   */
  if ($form['#id'] == 'civicrm-event-form') {
    $drupalDate = null;

    /* Try getting the date from the Drupal date field */
    if (!empty($form['field_event_date']['und'][0]['#default_value'])) {
      $drupalDate = $form['field_event_date']['und'][0]['#default_value'];
    }

    /* Try getting the dates from CiviCRM */
    if (empty($drupalDate)) {
      $form['field_event_date']['und'][0]['#default_value']['value']
        = str_replace(
          ' ',
          'T',
          $form['start_date']['#default_value']);
      $form['field_event_date']['und'][0]['#default_value']['value2']
        = str_replace(
          ' ',
          'T',
          $form['end_date']['#default_value']);
      $form['field_event_date']['und'][0]['timezone']['#default_value']
        = 'Australia/' .
          $form['taxonomy_vocabulary_1']['und']['#options'][
            $form['taxonomy_vocabulary_1']['und']['#default_value'][0]
          ];
    }
  }

  /*
   * Add a callback to ensure when the form is submitted that CiviCRM variables are
   * overwritten by their Drupal equivalent.
   */
  if ($form['#id'] == 'civicrm-event-form') {
    $form['actions']['submit']['#submit'] = array_merge(
      array('cbf__civicrm_entity_form_submit'),
      $form['actions']['submit']['#submit']
    );
  }

  /*
   * The payment_processor field on the civicrm-event-form doesn't support
   * multiselect, but we want people to be able to choose to pay via credit
   * card or PayPal.
   *
   * Until this is resolved, prevent users accessing this field. They would
   * need to use the CiviCRM admin interface to set payment processors.
   */
  if ($form['#id'] == 'civicrm-event-form') {
    $form['payment_processor']['#access'] = false;
  }

  /*
   * The field_domain on the civicrm-event-form is calculated when the form
   * is saved. To avoid the user having to enter a value that is immediately
   * overridden, prevent the #default_value being empty.
   */
  if ($form['#id'] == 'civicrm-event-form') {
    if (empty($form['field_domain']['und']['domain_id']['#default_value'])) {
      $form['field_domain']['und']['domain_id']['#default_value'] = array(1 => 1);
    }
  }

  /*
   * Grab the mailing list default from the arguments
   */
  if (strpos($form['#id'], 'webform-client-form-') === 0) {
    if (
      isset($form['submitted']['mailing_list']['civicrm_1_contact_1_other_group']['#attributes']['class'])
      && in_array(
        'default-via-parameter',
        $form['submitted']['mailing_list']['civicrm_1_contact_1_other_group']['#attributes']['class']
      )
    ) {
      $form['submitted']['mailing_list']['civicrm_1_contact_1_other_group']['#size'] = 10;
      $form['submitted']['mailing_list']['civicrm_1_contact_1_other_group']['#options'] =
        array(
          'National' => array(
            2677 => '40 Rockets 2019 by email',
            2678 => '40 Rockets 2019 by SMS (East coast)',
            2679 => '40 Rockets 2019 by SMS (West coast)',
          ),
          'Sydney' => array(
            1 => 'Newsletter',
            1756 => 'The Edge',
            1658 => 'Bible Shots',
            1671 => 'Tho Luu Foundation',
          ),
          'Melbourne' => array(
            1813 => 'Melbourne Christians - Life@Work Prayer Network',
          ),
        );
      $params = drupal_get_query_parameters();
      if (filter_var($params['gid'], FILTER_VALIDATE_INT, array('options' => array('min_range' => 1)))) {
        $form['submitted']['mailing_list']['civicrm_1_contact_1_other_group']['#default_value'] = array($params['gid']);
      }
    }
  }

  /*
   * If the form has a field_event_date element then validate it
   */
  if (isset($form['field_event_date'])) {
    $form['#validate'][] = 'cbf_field_event_date_validate';
  }
}

/*
 * Callback for Entity form submission.
 *
 * Overwrite CiviCRM variables with their Drupal equivalents
 *  - Staff contact (overwrite custom_62)
 *  - Ministry centre (overwrite custom_25)
 *  - Event date (set the CiviEvent to start on the first date of a repeating
 *    event and to finish on the last date of a repeating event)
 *  - Number of sessions (count of dates overwrites custom_47)
 *
 * Prevent Drupal values overwriting their CiviCRM equivalents
 *  - Payment processor (Drupal form doesn't support multiselect)
 */
function cbf__civicrm_entity_form_submit(&$form, &$form_state) {
  if ($form['#id'] == 'civicrm-event-form') {
    $form_state['values']['custom_62'] = $form_state['values']['field_staff_contact']['und'][0]['contact_id'];
    $form_state['values']['custom_25'] = _cbf_civicrm_civicrm_event_ministry_centre_id(
      $form['taxonomy_vocabulary_1']['und']['#options'][
        $form_state['values']['taxonomy_vocabulary_1']['und'][0]['tid']
      ]
    );

    for ($i = 0; ; $i++) {
      if (!isset($form_state['values']['field_event_date']['und'][$i])) {
        break;
      }
      $last = $form_state['values']['field_event_date']['und'][$i];
      if (!isset($first)) {
        $first = $last;
      }
    }

    $date = new DateObject($first['value'], $first['timezone']);
    $form_state['values']['start_date'] = $date->format('Y-m-d H:i');

    $date = new DateObject($last['value2'], $last['timezone']);
    $form_state['values']['end_date'] = $date->format('Y-m-d H:i');

    $form_state['values']['custom_47'] = $i;

    /*
     * The payment_processor field on the civicrm-event-form doesn't support
     * multiselect, but we want people to be able to choose to pay via credit
     * card or PayPal.
     *
     * Until this is resolved, prevent users changing this field. To do this we
     * send a signal to cbf_civicrm_civicrm_pre() that input from this field on
     * this form should be ignored. We do this by setting the payment_processor
     * to be one that is never used. It's name is 'Hack for CiviCRM Event
     * entities' and its number is 15.
     */
    $dummyPaymentProcessor = '15';
    $form_state['values']['payment_processor'] = $dummyPaymentProcessor;
  }
}

/*
 * This hook is called to alter Drupal comment forms.
 *
 * This change prevents anonymous users accessing the 'homepage' field.
 * Spammers were using this field to get backlinks to their content on
 * this website.
 */
function cbf_form_comment_form_alter(&$form, &$form_state, $form_id) {
  if (user_is_anonymous()) {
    if (isset($form['author']['homepage']['#access'])) {
      $form['author']['homepage']['#access'] = false;
    }
  }
}

/*
 * This hook is called before a comment is saved
 * 
 * Spam comments are being submitted with a certain subject line. This hook prevents
 * those comments being published in the rare case Mollom doesn't stop it.
 */
function cbf_comment_presave($comment) {
  $subjectPatterns = array(
    '^Add new comment \\| ',
  );
  $bodyPatterns = array();
  $patterns = array(
    'viagra',
    '\\bcialis\\b',
    '<(br|p)\\/?>',
  );

  $subject = $comment->subject;
  $body = $comment->comment_body['und'][0]['value'];

  foreach (array_merge($subjectPatterns, $patterns) as $pattern) {
    if (preg_match("/$pattern/i", $subject) == 1) {
      $comment->status = 0;
    }
  }
  foreach (array_merge($bodyPatterns, $patterns) as $pattern) {
    if (preg_match("/$pattern/i", $body) == 1) {
      $comment->status = 0;
    }
  }
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Sort Order.
 * The value is set to the timestamp of the Field Episode Date or the Field Event Date.
 * The Event date takes preference, though no entity should have both being non-empty.
 * The timestamp used is the start time.
 * If the event date is repeating then apply this logic to the first date in the future.
 * If no events are in the future, use the date of the last one in the past.
 */
function computed_field_field_sort_order_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $current_time = strtotime('now');
  $timestamp = 0;

  // Calculate the sort order from the (non-repeating) Episode Date
  $field_episode_date = field_get_items($entity_type, $entity, 'field_episode_date');
  if (!empty($field_episode_date)) {
    $episode = reset($field_episode_date);
    if (!empty($episode['value'])) {
      $start_time = new DateObject($episode['value'], $episode['timezone']);
      $timestamp = strtotime($start_time->format('Y-m-d H:i:s O'));
    }
  }

  // Calculate the sort order from the (repeating) Event Date
  $field_event_date = field_get_items($entity_type, $entity, 'field_event_date');
  if (!empty($field_event_date)) {
    foreach ($field_event_date as $event_occurrence) {
      $start_time = new DateObject($event_occurrence['value'], $event_occurrence['timezone']);
      $timestamp = strtotime($start_time->format('Y-m-d H:i:s O'));

      $end_time = new DateObject($event_occurrence['value2'], $event_occurrence['timezone']);
      $endstamp = strtotime($end_time->format('Y-m-d H:i:s O'));

      if ($endstamp > $current_time) {
        break;
      }
    }
  }

  $entity_field[0]['value'] = $timestamp;
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Sort Order.
 * It returns a string of the form '2011-10-22 22:41:25 +1100'.
 */
function computed_field_field_sort_order_display($field, $entity_field_item) {
  $start_time = new DateObject($entity_field_item['value'], 'UTC');
  return $start_time->format('Y-m-d H:i:s O');
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Next Action.
 * The value is set to the timestamp of the Field Episode Date or the Field Event Date.
 * The Event date takes preference, though no entity should have both being non-empty.
 * The timestamp used is the start time for episodes and the end time for events.
 * If the event date is repeating then apply this logic to the first date in the future.
 * If the timestamp is in the past then next action is zero (there is no next action).
 */
function computed_field_field_next_action_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $current_time = strtotime('now');
  $timestamp = 0;

  // Calculate the next action from the (non-repeating) Episode Date
  $field_episode_date = field_get_items($entity_type, $entity, 'field_episode_date');
  if (!empty($field_episode_date)) {
    $episode = reset($field_episode_date);
    if (!empty($episode['value'])) {
      $start_time = new DateObject($episode['value'], $episode['timezone']);
      $timestamp = strtotime($start_time->format('Y-m-d H:i:s O'));
    }
  }

  // Calculate the next action from the (repeating) Event Date
  $field_event_date = field_get_items($entity_type, $entity, 'field_event_date');
  if (!empty($field_event_date)) {
    foreach ($field_event_date as $event_occurrence) {
      $end_time = new DateObject($event_occurrence['value2'], $event_occurrence['timezone']);
      $timestamp = strtotime($end_time->format('Y-m-d H:i:s O'));

      if ($timestamp > $current_time) {
        break;
      }
    }
  }

  // If the timestamp is in the past, then set the next action to zero (ie, no action)
  if ($timestamp <= $current_time) {
    $timestamp = 0;
  }

  $entity_field[0]['value'] = $timestamp;
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Next Action.
 * It returns a string of the form '2011-10-22 22:41:25 +1100'.
 */
function computed_field_field_next_action_display($field, $entity_field_item) {
  $end_time = new DateObject($entity_field_item['value'], 'UTC');
  return $end_time->format('Y-m-d H:i:s O');
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Date Text.
 *
 * If the entity contains an Episode Date, the text is empty for future dates. Otherwise
 * it is the date.
 * 
 * If all occurrences of the event are in the past, this field is the empty string.
 * Else, show the first future occurrence, along with every other occurrence in the
 *  7 days after that occurrence. 
 * If the first future occurrence is in the next 7 days, show just the weekday, else
 *  show the weekday and date.
 * If there are previous repeats of this event, prefix the date with 'Next on '.
 * If there are no previous repeats, and there are subsequent repeats that are not listed,
 * prefix the date with 'Starts on '.
 * Show the start time, unless it is midnight.
 */
function computed_field_field_date_text_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $current_time = strtotime('now');
  $next_week    = strtotime('now +1 week');
  $startstamp   = 0;
  $endstamp     = 0;
  $upperlimit   = 0;
  $previous     = 0;
  $subsequent   = 0;
  $date_future  = 'D j M';
  $date_past    = 'j M Y';
  $time_format  = 'g.ia';
  $midnight     = '12.00am';
  $date_text    = false;
  $time_text    = false;
  $first_text   = false;
  $last_text    = false;

  // Calculate the date text from the (non-repeating) Episode Date
  $field_episode_date = field_get_items($entity_type, $entity, 'field_episode_date');
  if (!empty($field_episode_date)) {
    $episode = $field_episode_date[0];
    if (!empty($episode['value'])) {
      $start_time = new DateObject($episode['value'], $episode['timezone']);
      $startstamp = strtotime($start_time->format('Y-m-d H:i:s O'));

      if ($startstamp <= $current_time) {
        $first_text = $start_time->format($date_past);
        $last_text = $first_text;
      }
    }
  }

  // Calculate the date text from the (perhaps-repeating) Event Date
  $field_event_date = field_get_items($entity_type, $entity, 'field_event_date');
  if (!empty($field_event_date)) {
    foreach ($field_event_date as $event_occurrence) {
      $start_time = new DateObject($event_occurrence['value'], $event_occurrence['timezone']);
      $startstamp = strtotime($start_time->format('Y-m-d H:i:s O'));

      $end_time = new DateObject($event_occurrence['value2'], $event_occurrence['timezone']);
      $endstamp = strtotime($end_time->format('Y-m-d H:i:s O'));

      if ($time_text === false) {
        $time_text = $start_time->format($time_format);
        if ($time_text != $midnight) {
          $time_text .= '-' . $end_time->format($time_format);
        }
      }

      if ($upperlimit == 0 && $endstamp > $current_time) {
        $upperlimit = $startstamp + ($next_week - $current_time);
      }

      if ($endstamp <= $current_time) {
        $previous++;
        if ($first_text === false) {
          $first_text = $start_time->format($date_past);
        }
        $last_text = $end_time->format($date_past);
      }
      else if ($startstamp >= $upperlimit) {
        $subsequent++;
      }
      else {
        $start_date_text = $start_time->format($date_future);
        $end_date_text = $end_time->format($date_future);

        if ($start_date_text == $end_date_text) {
          $this_date_text = $start_date_text;
        }
        else {
          $this_date_text = $start_date_text . ' to ' . $end_date_text;
          $time_text = $midnight;
        }

        if ($date_text === false) {
          $date_text = $this_date_text;
        }
        else {
          $date_text .= ', ' . $this_date_text;
        }
      }
    }
  }

  if ($date_text === false) {
    if ($first_text <> $last_text) {
      $date_text = 'Finished on ' . $last_text;
    }
    else {
      $date_text = $last_text;
    }
  }
  else {
    if ($previous > 0) {
      $date_text = 'Next on ' . $date_text;
    }
    else if ($subsequent > 0) {
      $date_text = 'Starts on ' . $date_text;
    }
  }

  if ($date_text === false) {
    $entity_field[0]['value'] = '';
  }
  if ($time_text === false || $time_text == $midnight) {
    $entity_field[0]['value'] = $date_text;
  }
  else {
    $entity_field[0]['value'] = $date_text . ', ' . str_replace('.00', '', $time_text);
  }
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Date Text.
 */
function computed_field_field_date_text_display($field, $entity_field_item) {
  return $entity_field_item['value'];
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Is Audio.
 */
function computed_field_field_is_audio_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $field_content = field_get_items($entity_type, $entity, 'field_content');
  if (!empty($field_content)) {
    $entity_field[0]['value'] = 1;
  }
  else {
    $entity_field[0]['value'] = 0;
  }
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Is Audio.
 */
function computed_field_field_is_audio_display($field, $entity_field_item, $entity_lang, $langcode) {
  if ($entity_field_item['value'] != 0) {
    return 'Yes';
  }
  else {
    return 'No';
  }
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Is Video.
 */
function computed_field_field_is_video_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $field_video = field_get_items($entity_type, $entity, 'field_video');
  if (!empty($field_video)) {
    $entity_field[0]['value'] = 1;
  }
  else {
    $entity_field[0]['value'] = 0;
  }
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Is Video.
 */
function computed_field_field_is_video_display($field, $entity_field_item, $entity_lang, $langcode) {
  if ($entity_field_item['value'] != 0) {
    return 'Yes';
  }
  else {
    return 'No';
  }
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Is Text.
 */
function computed_field_field_is_text_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $field_attachment = field_get_items($entity_type, $entity, 'field_attachment');
  if (!empty($field_attachment)) {
    $entity_field[0]['value'] = 1;
  }
  else {
    $entity_field[0]['value'] = 0;
  }
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Resource Type.
 */
function computed_field_field_resource_type_display($field, $entity_field_item, $entity_lang, $langcode) {
  switch ($entity_field_item['value']) {
    case 'video':
      return '<i class="fa fa-fw fa-youtube-play"></i>';
    case 'audio':
      return '<i class="fa fa-fw fa-microphone"></i>';
    case 'text':
      return '<i class="fa fa-fw fa-file-pdf-o"></i>';
    default:
      return '';
  }
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Resource Type.
*/
function computed_field_field_resource_type_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $field_video = field_get_items($entity_type, $entity, 'field_video');
  $field_content = field_get_items($entity_type, $entity, 'field_content');
  $field_attachment = field_get_items($entity_type, $entity, 'field_attachment');
  if (!empty($field_video)) {
    $entity_field[0]['value'] = 'video';
  }
  elseif (!empty($field_content)) {
    $entity_field[0]['value'] = 'audio';
  }
  elseif (!empty($field_attachment)) {
    $entity_field[0]['value'] = 'text';
  }
  else {
    $entity_field[0]['value'] = '';
  }
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Is Text.
*/
function computed_field_field_is_text_display($field, $entity_field_item, $entity_lang, $langcode) {
  if ($entity_field_item['value'] != 0) {
    return 'Yes';
  }
  else {
    return 'No';
  }
}

/*
 * This function is called by CCK Computed Field to compute the value of field Add to Calendar.
*/
function computed_field_field_add_to_calendar_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $field_next_action = field_get_items($entity_type, $entity, 'field_next_action');
  if ($field_next_action !== false && empty($field_next_action[0]['value'])) {
    $entity_field[0]['value'] = null; // The entity is an event and it has passed
    return;
  }
  $field_civievent = field_get_items($entity_type, $entity, 'field_civievent');
  if ($field_civievent !== false && !empty($field_civievent[0]['target_id'])) {
    $entity_field[0]['value'] = null; // There is a CiviEvent
    return;
  }
  $field_publish_calendar = field_get_items($entity_type, $entity, 'field_publish_calendar');
  if ($field_publish_calendar !== false && empty($field_publish_calendar[0]['value'])) {
    $entity_field[0]['value'] = null; // The 'Publish calendar' flag has been unticked
    return;
  }
  $content_type = $entity->type;
  $entity_nid = $entity->nid;
  $field_in_activity = field_get_items($entity_type, $entity, 'field_in_activity');
  if ($field_in_activity !== false && !empty($field_in_activity)) {
    $entity_activity = $field_in_activity[0]['target_id'];
    $activity = node_load($entity_activity);
    $field_publish_calendar = field_get_items('node', $activity, 'field_publish_calendar');
    if ($field_publish_calendar === false || empty($field_publish_calendar[0]['value'])) {
      $entity_activity = 0; // The activity's 'Publish calendar' flag has not been ticked
    }
  }
  else {
    $entity_activity = 0;
  }
  $field_event_date = field_get_items($entity_type, $entity, 'field_event_date');
  if ($field_event_date != false) {
    $event_count = count($field_event_date); // a possibly-repeating event
  }
  else {
    $event_count = 2; // the other cases will have multiple events (at least 2)
  }
  $taxonomy_vocabulary_1 = field_get_items($entity_type, $entity, 'taxonomy_vocabulary_1');
  if ($taxonomy_vocabulary_1 !== false && !empty($taxonomy_vocabulary_1)) {
    $term = taxonomy_term_load($taxonomy_vocabulary_1[0]['tid']);
    $city = $term->name;
  }
  else {
    $city = '';
  }
  if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {
    $host = $_SERVER['HTTP_X_HOST'];
  }
  else {
    $host = $_SERVER['SERVER_NAME'];
  }
  $schemes = array();
  $results = array();
  $types = array();
  $nids = array();
  $title = '';
  $description = '';
  $startDate = '';
  $endDate = '';
  if ($content_type == 'event') {
    if ($event_count == 1) {
      $schemes[] = 'single';
      $types['single'] = $content_type;
      $nids['single'] = $entity_nid;
      $title = $entity->title;
      $body = field_get_items($entity_type, $entity, 'body');
      if ($body !== false && !empty($body)) {
        $description = truncate_utf8($body[0]['value'], 600, TRUE, TRUE);
      }
      $startDate = '';
      $endDate = '';
    }
    else {
      $schemes[] = 'multiple';
      $types['multiple'] = $content_type;
      $nids['multiple'] = $entity_nid;
    }
    if (!empty($entity_activity)) {
      $schemes[] = 'subscribe';
      $types['subscribe'] = 'activity';
      $nids['subscribe'] = $entity_activity;
    }
  }
  elseif ($content_type == 'activity') {
    $schemes[] = 'subscribe';
    $types['subscribe'] = $content_type;
    $nids['subscribe'] = $entity_nid;
  }
  if (!empty($city)) {
    $schemes[] = 'city';
    $types['city'] = strtolower($city);
    $nids['city'] = 0;
  }
  $clients = array(
    'Apple' => array('single' => 'ics', 'multiple' => 'ics', 'subscribe' => 'webcal', 'city' => 'webcal'),
    'Outlook' => array('single' => 'ics', 'multiple' => 'ics', 'subscribe' => 'webcal', 'city' => 'webcal'),
    'Google Calendar' => array('single' => 'google', 'multiple' => '', 'subscribe' => 'google webcal', 'city' => 'google webcal'),
    'Other' => array('single' => 'ics', 'multiple' => 'ics', 'subscribe' => 'ics', 'city' => 'ics'),
  );
  foreach ($schemes as $scheme) {
    $results[$scheme] = '';
    foreach ($clients as $client => $methods) {
      if ($scheme == 'city') {
        $relative_url = "/ical/city/$types[$scheme]/calendar.ics";
      }
      else {
        $relative_url = "/ical/$types[$scheme]/$nids[$scheme]/calendar.ics";
      }
      switch ($methods[$scheme]) {
        case 'ics':
          $target = $relative_url;
          break;
        case 'webcal':
          $target = "webcal://$host$relative_url";
          break;
        case 'google':
          if (empty($title) || empty($startDate) || empty($endDate)) {
            $target = '';
          }
          else {
            $target = url(
              'http://www.google.com/calendar/event',
              array(
                'query' => array(
                  'action' => 'TEMPLATE',
                  'text' => $title,
                  'dates' => $startDate . '/' . $endDate,
                  'sprop' => 'website:' . $host,
//                  'location' => $info['location'],
                  'details' => $description,
                  'website' => url($info['url'], array('absolute' => TRUE)),
              )));
          }
          break;
        case 'google webcal':
          $target = url(
            'https://www.google.com/calendar/render',
            array(
              'query' => array('cid' => "webcal://$host$relative_url")));
          break;
        default:
          $target = '';
          break;
      }
      if (!empty($target)) {
        $results[$scheme] .= '<li><a href="' . $target . '" target="_blank" rel="noopener noreferrer">' . $client . '</a></li>';
      }
    }
  }
  if (count($results) == 0) {
    $entity_field[0]['value'] = null;
    return;
  }
  $schemeLabel = array(
    'single' => 'This event only',
    'multiple' => 'This event only',
    'subscribe' => 'This and future events like it',
    'city' => "This and future events for $city",
  );
  $result = '
    <ul class="nav">
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#">Add to calendar</a>
        <ul class="dropdown-menu">';
  if (count($results) == 1) {
    foreach ($results as $scheme => $target) {
      $result .= $target;
    }
  }
  else {
    foreach ($results as $scheme => $target) {
      $result .= '
          <li class="dropdown dropdown-submenu">
            <a class="dropdown-toggle" data-toggle="dropdown" href="#">';
      $result .= $schemeLabel[$scheme];
      $result .= '</a>
            <ul class="dropdown-menu">';
      $result .= $target;
      $result .= '
            </ul>
          </li>';
    }
  }
  $result .= '
        </ul>
      </li>
    </ul>';
  $result .= (count($results) == 1) ? '' : '
    <script type="text/javascript">
      (function($){
        $(document).ready(function(){
          $(\'ul.dropdown-menu [data-toggle=dropdown]\').on(\'click\', function(event) {
            event.preventDefault();
            event.stopPropagation();
            $(this).parent().siblings().removeClass(\'open\');
            $(this).parent().toggleClass(\'open\');
          });
        });
      })(jQuery);
    </script>';
  $entity_field[0]['value'] = $result;
}

/*
 * This function is called by CCK Computed Field to generate the display text of field Add to Calendar.
*/
function computed_field_field_add_to_calendar_display($field, $entity_field_item, $entity_lang, $langcode) {
  if (empty($entity_field_item['value'])) {
    return '';
  }
  return $entity_field_item['value'];
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Path Alias.
*/
function computed_field_field_source_entity_alias_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $field_source_entity_type = field_get_items($entity_type, $entity, 'field_source_entity_type');
  $field_source_entity_id = field_get_items($entity_type, $entity, 'field_source_entity_id');
  if (!empty($field_source_entity_type) && !empty($field_source_entity_id)) {
    $path = str_replace('_', '-', $field_source_entity_type[0]['value']);
    $path .= "/{$field_source_entity_id[0]['value']}";
    $entity_field[0]['value'] = drupal_get_path_alias($path);
  }
  else {
    $entity_field[0]['value'] = '';
  }
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Path Alias.
*/
function computed_field_field_source_entity_alias_display($field, $entity_field_item, $entity_lang, $langcode) {
  if (empty($entity_field_item['value'])) {
    return '';
  }
  return $entity_field_item['value'];
}

/*
 * Validate field_event_date elements on forms.
 *  - an event can't last longer than 3 days. This prevents staff misusing
 *    Events and CiviCRM Events when they should be using a News Story.
 */
function cbf_field_event_date_validate($form, &$form_state) {
  if (isset($form_state['values']['field_event_date'])) {
    $duration = 0;
    foreach (reset($form_state['values']['field_event_date']) as $event_occurrence) {
      if (is_array($event_occurrence)) {
        $start_time = new DateObject($event_occurrence['value'], $event_occurrence['timezone']);
        $startstamp = strtotime($start_time->format('Y-m-d H:i:s O'));

        $end_time = new DateObject($event_occurrence['value2'], $event_occurrence['timezone']);
        $endstamp = strtotime($end_time->format('Y-m-d H:i:s O'));
        $duration += $endstamp - $startstamp;
      }
    }
    if ($duration > 3 * 24 * 60 * 60) {
      form_set_error(
        'field_event_date',
        'The overall duration of this event is greater than 3 daya. ' .
        'This doesn\'t seem like an event. ' .
        'Try a forward dated News Story instead.');
    }
  }
}

/*
 * Implement the rules that assign entities to domains.
 *
 * Rules are stored in the domain information ...
 *
 *     alias = NNNN.activity.rule
 *
 *         NNNN is the node Id for the Activity that corresponds to this domain.
 *         This rule matches if the node's nid or its Activity is NNNN.
 *
 *     alias = christian.audience.rule |
 *             all.audience.rule
 *
 *         Always matches.
 *
 *     alias = general.audience.rule
 *
 *         Matches content for a General audience.
 *
 * The rules have the following effects on nodes...
 *
 *     domain_site   false (content is not available in all affiliates)
 *     domains       contains an entry for each domain that matches a rule
 *     domain_source DOMAIN_SOURCE_USE_ACTIVE (don't change domain to a cardinal
 *                   domain) EXCEPT when the node appears in only one domain
 *
 * The rules have the following effects on CiviCRM Events...
 *
 *     field_domain  false (content is not available in all affiliates)
 */
function cbf_entity_presave($entity, $type) {
  switch ($type) {
    case 'node':
      $url0 = 'node';
      break;
    case 'civicrm_event':
      $url0 = 'civicrm-event';
      break;
    default:
      return;
  }

  /*
   * If saving an entity after editing it, clear the views data cache so the
   * staff member editing the node can see the refreshed version of the views
   * blocks on the page.
   */
  if (arg(0) == $url0 && arg(2) == 'edit') {
    cache_clear_all('*', 'cache_views_data', true);
  }

  $followDomainRules = true;
  $allDomainContentTypes = array(
    'contact_webform' => true,
    'webform' => true,
  );
  $allDomainNodes = array(
    61 => 'Privacy policy',
  );

  if ($followDomainRules) {
    $domains = domain_list_by_machine_name();

    $matches = [];

    $field_in_activity = field_get_items($type, $entity, 'field_in_activity');
    if ($field_in_activity === false || empty($field_in_activity[0]['target_id'])) {
      $node_activity = 0;
    }
    else {
      $node_activity = $field_in_activity[0]['target_id'];
    }

    $audienceTerm = field_get_items($type, $entity, 'taxonomy_vocabulary_3');
    if ($audienceTerm === false || empty($audienceTerm[0]['tid'])) {
      $entityAudience = '';
    }
    else {
      switch ($audienceTerm[0]['tid']) {
        case '47':
          $entityAudience = 'christian';
          break;
        case '48':
          $entityAudience = 'general';
          break;
        default:
          $entityAudience = '';
          break;
      }
    }

    foreach ($domains as $domain) {
      $match = false;
      if ($type == 'node') {
        if (isset($allDomainContentTypes[$entity->type])) {
          $match = true;
        }
        else if (isset($allDomainNodes[$entity->nid])) {
          $match = true;
        }
      }
      foreach ($domain['aliases'] as $alias) {
        $activity = stristr($alias['pattern'], '.activity.rule', true);
        if ($activity !== false) {
          $activity = (int) $activity;
          if ($node_activity == $activity || ($type == 'node' && $entity->nid == $activity)) {
            $match = true;
            break;
          }
        }
        $audience = stristr($alias['pattern'], '.audience.rule', true);
        if ($audience !== false) {
          if (
            $audience == 'all' ||
            $audience == 'christian' ||
            strcasecmp($audience, $entityAudience) == 0
          ) {
            $match = true;
            break;
          }
        }
      }

      if ($match) {
        $matches[] = ['domain_id' => $domain['domain_id']];
      }
    }

    switch ($type) {
      case 'node':
        $entity->domain_site = false;
        $entity->domains = [];
        foreach ($matches as $domain) {
          $entity->domains[$domain['domain_id']] = $domain['domain_id'];
        }
        if (count($entity->domains) == 1) {
          $entity->domain_source = reset($entity->domains);
        }
        else {
          $entity->domain_source = DOMAIN_SOURCE_USE_ACTIVE;
        }
        break;
      case 'civicrm_event':
        $entity->field_domain[field_language($type, $entity, 'field_domain')] = $matches;
        break;
    }
  }
}

/*
 * CKEditor introduces some unpleasant artifacts into HTML text fields. This
 * function handles them ...
 *
 *   - Empty paragraphs are removed
 *   - Non-breaking spaces are replaced with plain spaces
 *   - Ensure target="_blank" attributes have a rel="noopener noreferrer"
 *     attribute https://medium.com/@jitbit/target-blank-the-most-underestimated-vulnerability-ever-96e328301f4c#.dzwczm21q
 *
 * The order of these actions is important as the patterns have overlapping content.
 */
function cbf_field_attach_presave($entity_type, $entity) {
  if ($entity_type == 'node') {
    $html_fields = array('body', 'field_short_form', 'field_sidebar_content');
    $attributes = array('summary','value');
    $replacements = array(
      '!<p>(\r\n\t)*&nbsp;</p>!i' => '',
      '!&nbsp;!i'                 => ' ',
      '!target="_blank" rel="noopener noreferrer"!i'           => 'target="_blank"',
      '!target="_blank"!i'                                     => 'rel="noopener noreferrer" target="_blank"',
      '!rel="noopener noreferrer" rel="noopener noreferrer"!i' => 'rel="noopener noreferrer"',
    );
    $from = array_keys($replacements);
    $to = array_values($replacements);
    foreach ($html_fields as $html_field) {
      if (isset($entity->$html_field)) {
        $field = & $entity->$html_field;
        $languages = array_keys($field);
        foreach ($languages as $language) {
          $instances = count($field[$language]);
          for ($instance = 0; $instance < $instances; $instance++) {
            foreach ($attributes as $attribute) {
              if (isset($field[$language][$instance][$attribute])) {
                $field[$language][$instance][$attribute]
                  = preg_replace($from, $to, $field[$language][$instance][$attribute]);
              }
            }
          }
        }
      }
    }
  }
}

/*
 * This function is called by Drupal cron.
 *
 * Re-save entities that have a field_next_action which is set to a time between
 * the previous invocation of cron and this one. This enacts time-sensitive
 * calculations of computed field values.
 *
 * Prevent nodes that were posted to Twitter from being automatically re-posted if
 * they are edited.
 *
 * The time that cron was run is updated for next time.
 */
function cbf_cron() {
  $current_time = strtotime('now');
  $last_run     = variable_get('cbf_cron_last_run', 0);

  /* Set operator and values for filtering field_next_action */
  if ($last_run == 0) {
    $operator = '>';
    $values = array($last_run);
  }
  else {
    $operator = 'BETWEEN';
    $values = array($last_run, $current_time);
  }

  /* Update entities with actions due */
  $query = new EntityFieldQuery();
  $result = $query->fieldCondition('field_next_action', 'value', $values, $operator)
    ->execute();
  foreach ($result as $entityType => $entities) {
    $entities = entity_load($entityType, array_keys($entities));
    foreach ($entities as $entity) {
      switch ($entityType) {
        case 'node':
          node_save($entity);
          break;
        case 'civicrm_event':
          $entity->custom_62 = $entity->custom_62_id;
          entity_save($entityType, $entity);
          break;
      }
    }
  }

  /*
   * Find nodes that were Tweeted using Post to Twitter. Set their status so
   * they are not tweeted again if any calls are made to node_save().
   */
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
    ->fieldCondition('field_post_to_twitter', 'status', 0, '<>')
    ->execute();
  if (isset($result['node'])) {
    $nodes = entity_load('node', array_keys($result['node']));
    foreach ($nodes as $node) {
      // Prevent a post being made again to Twitter
      $langcode = field_language('node', $node, 'field_post_to_twitter');
      if (isset($node->field_post_to_twitter[$langcode][0])) {
        $node->field_post_to_twitter[$langcode][0]['status'] = 0;
      }
      node_save($node);
    }
  }

  variable_set('cbf_cron_last_run', $current_time);
}

/*
 * When a comment is made in reply to a comment, and email is sent
 * to the author of the original comment. If there is no original
 * comment, the comment is being made directly on the article, but
 * Drupal still attempts to send an email. The "To" header will in
 * this case be an unresolved token and will fail to be delivered.
 * Don't send emails in this case.
 *
 * The Contact module sends emails using the To: address supplied
 * by the visitor to a citybibleforum.org address. When this is
 * redirected to a gmail.com address Gmail rightly complains
 * (Unauthenticated email from yahoo.com is not accepted due to
 * domain's 550-5.7.1 DMARC policy)
 *
 * Change the message headers so the email is sent From the Sender
 * address (doulos@citybibleforum.org), but the original address
 * is in the Reply-To header.
 */
function cbf_mail_alter(&$message) {
  if (strpos($message['to'], '[') !== false) {
    $message['send'] = false;
  }
  else {
    $message['headers']['Reply-To'] = $message['headers']['From'];
    $message['headers']['From'] = $message['headers']['Sender'];
  }
}

/*
 * Derive the city name from the Drupal arguments or the URL
 */
function cbf_city_string() {
  /*
   * The city name is initially unknown, but only needs to be calculated
   * once per request
   */
  static $cbf_city = null;

  if ( !isset($cbf_city) ) {
    /*
     * There is no $city unless specified in the Drupal args or URL
     */
    $city = false;

    if (arg(0) == 'city' && arg(1) != '') {
      $city = arg(1);
    } else {
      $uri = explode('/', $_SERVER['REQUEST_URI']);
      if($uri[1] == 'city' && isset($uri[2]) ){
        $city = $uri[2];
      }
    }

    switch ($city) {
      // The cities
      case 'sydney':
      case 'canberra':
      case 'melbourne':
      case 'brisbane':
      case 'perth':
      case 'adelaide':
      case 'hobart':
        $cbf_city = $city;
        break;

      // Deprecated: the areas in Sydney
      case 'sydney-cbd':
      case 'sydney-cbd-north':
      case 'sydney-cbd-south':
      case 'sydney-legal':
      case 'sydneys-north-shore':
      case 'north-sydney':
      case 'st-leonards':
      case 'chatswood':
      case 'macquarie-park':
      case 'parramatta':
        $cbf_city = 'sydney';
        break;

      // Anything else is not a city
      default:
        $cbf_city = false;
        break;
    }
  }

  return $cbf_city;
}

/*
 * The visitor city name is initially unknown, but only needs to be calculated
 * once per request
 */
function cbf_visitor_city_string() {
  static $cbf_visitor_city = null;

  if (!isset($cbf_visitor_city)) {
    $cbf_visitor_city = false;

    if (!function_exists('ip_geoloc_get_visitor_location')) {
      return $cbf_visitor_city;
    }

    $result = ip_geoloc_get_visitor_location();

    if (isset($result['country']) && isset($result['administrative_area_level_1'])) {
      switch ($result['country']) {
        case 'Australia':
          switch ($result['administrative_area_level_1']) {
            case 'New South Wales':
              $cbf_visitor_city = 'sydney';
              break;
            case 'Victoria':
              $cbf_visitor_city = 'melbourne';
              break;
            case 'Queensland':
              $cbf_visitor_city = 'brisbane';
              break;
            case 'South Australia':
              $cbf_visitor_city = 'adelaide';
              break;
            case 'Western Australia':
              $cbf_visitor_city = 'perth';
              break;
            case 'Australian Capital Territory':
              $cbf_visitor_city = 'canberra';
              break;
            case 'Tasmania':
              $cbf_visitor_city = 'hobart';
              break;
          }
          break;
      }
    }
  }

  return $cbf_visitor_city;
}

/*
 * Populate the metatags for a node's Twitter Card and Facebook Open Graph.
 *
 * The Twitter Card preferences are ...
 *
 * #  Twitter card type              Source image     Condition
 * -  -----------------------------  ---------------  ------------------------
 * 1  Summary card with large image  Highlight        Image >= 280px x 150px
 *                                   Series image
 *                                   Image
 * 2  Summary card                   Thumbnail image  Image >= 120px x 120px
 * 3  Summary card                   Logo             No matching image fields
 *
 * The Facebook Open Graph preferences are ...
 *
 * #  Source image  Condition
 * -  ------------  ------------------------
 * 4  Highlight     Image >= 600px x 316px
 *    Series Image
 *    Image
 * 5  Highlight     Image >= 280px wide
 *    Series Image
 *    Image
 * 6  Logo          No matching image fields
 */
function cbf_metatag_pattern_alter(&$pattern, &$types, $tag_name) {
  if (isset($types['node'])) {
    $node = $types['node'];
    $largeImages = array('field_highlight', 'field_image', 'field_series_image');
    switch ($tag_name) {
      case 'twitter:card':
      case 'twitter:image':
        /* Option 3 is the default */
        $card = 'summary';
        $src = '';
        /* Try Option 1 */
        foreach ($largeImages as $largeImage) {
          $image = field_get_items('node', $node, $largeImage);
          if ($image !== false && !empty($image)) {
            if (isset($image[0]['width']) && $image[0]['width'] >= 280 &&
                isset($image[0]['height']) && $image[0]['height'] >= 150) {
              $card = 'summary_large_image';
              $src = "[node:$largeImage]";
              break;
            }
          }
        }
        /* Try Option 2 */
        if ($src == '') {
          $image = field_get_items('node', $node, 'field_thumbnail_image');
          if ($image !== false && !empty($image)) {
            if (isset($image[0]['width']) && $image[0]['width'] >= 120 &&
                isset($image[0]['height']) && $image[0]['height'] >= 120) {
              $src = "[node:field_thumbnail_image]";
            }
          }
        }
        /* Update the tag pattern if changed from the default */
        if ($src != '') {
          switch ($tag_name) {
            case 'twitter:card':
              $pattern = $card;
              break;
            case 'twitter:image':
              $pattern = $src;
              break;
          }
        }
        break;

      case 'og:image':
        /* Option 6 is the default */
        $src = '';
        /* Try Option 4 */
        foreach ($largeImages as $largeImage) {
          $image = field_get_items('node', $node, $largeImage);
          if ($image !== false && !empty($image)) {
            if (isset($image[0]['width']) && $image[0]['width'] >= 600 &&
                isset($image[0]['height']) && $image[0]['height'] >= 316) {
              $src = "[node:$largeImage]";
              break;
            }
          }
        }
        /* Try Option 5 */
        if ($src == '') {
          foreach ($largeImages as $largeImage) {
            $image = field_get_items('node', $node, $largeImage);
            if ($image !== false && !empty($image)) {
              if (isset($image[0]['width']) && $image[0]['width'] >= 280) {
                $src = "[node:$largeImage]";
                break;
              }
            }
          }
        }
        if ($src != '') {
          $pattern = $src;
        }
        break;
    }
  }
}

/*
 * A function to parse the exposed filters on the National Library view,
 * to extract the topics, and return a string containing them.
 *
 * This function is invoked by the contextual filter 'Header topics string'
 * in the page display 'Library' in the view 'National Library'.
 */
function cbf_library_view_topics_string(&$view) {
  if ( ! isset($view->exposed_input['field_topic_tid']) ) {
    return ' ';
  }

  $result = array();

  foreach ($view->exposed_input['field_topic_tid'] as $tid) {
    $queryResult = db_query(
      'select name from {taxonomy_term_data} where tid = :tid',
      array(':tid' => $tid));
    foreach ($queryResult as $row) {
      $result[] = $row->name;
    }
  }

  return implode(' | ', $result);
}

function cbf_views_api() {
  return [ 'api' => 3 ];
}


/*
 * Implementation of hook_views_pre_render
 *   - Centres the GMap in GMap views
 *   - Formats the Description in the RSS feed of the prayer_points view
 *   - Counts the number of rows and adds classes to the view as appropriate
 *       - views-1-row
 *       - views-2-rows
 *       - views-3-rows
 *       - views-n-rows
 */
function cbf_views_pre_render(&$view) {
  $watch = array('city_to_address');
  $displays = array('block_address');

  if ( in_array($view->name, $watch) ) {

    // Modifies the GMap Macro to ensure that the map gets properly centered.
    if ( in_array($view->current_display, $displays)
       && isset($view->result[0]->gmap_lat)
       && isset($view->result[0]->gmap_lon) ) {

      $macro = $view->display[$view->current_display]->handler->view->style_plugin->options['macro'];
      if ( !strstr('|center=', $macro) ) {
        $latlong = "{$view->result[0]->gmap_lat},{$view->result[0]->gmap_lon}";

        $macro  = str_replace(']', ' |center=' . $latlong . ']', $macro);
        $view->display[$view->current_display]->handler->view->style_plugin->options['macro'] = $macro;
      }
    }
  }

  $watch = array('reaching_city_civicrm_event_gmap');
  $displays = array('block_address');

  if ( in_array($view->name, $watch) ) {

    // Modifies the GMap Macro to ensure that the map gets properly centered.
    if ( in_array($view->current_display, $displays)
       && isset($view->result[0]->civicrm_address_geo_code_1)
       && isset($view->result[0]->civicrm_address_geo_code_2) ) {

      $macro = $view->display[$view->current_display]->handler->view->style_plugin->options['macro'];
      if ( !strstr('|center=', $macro) ) {
        $latlong = "{$view->result[0]->civicrm_address_geo_code_1},{$view->result[0]->civicrm_address_geo_code_2}";

        $macro  = str_replace(']', ' |center=' . $latlong . ']', $macro);
        $view->display[$view->current_display]->handler->view->style_plugin->options['macro'] = $macro;
      }
    }
  }

  $watch = array('prayer_points');
  $displays = array('feed');

  if (in_array($view->name, $watch)) {
    // Sets the Description in the RSS feeds.
    if (in_array($view->current_display, $displays)) {
      $lookup = array(
        'event' => array(
          'title' => 'An event',
          'preposition' => ' in ',
        ),
        'story' => array(
          'title' => 'News',
          'preposition' => ' for ',
        ),
        'blog' => array(
          'title' => 'A blog article',
          'preposition' => ' for ',
        ),
        'episode' => array(
          'title' => 'A new item in the library',
          'preposition' => ' for ',
        ),
      );
      foreach ($view->result as $i => $result) {
        if (isset($lookup[$result->node_type])) {
          $title = $lookup[$result->node_type]['title'];
          $city = $result->field_taxonomy_vocabulary_1[0]['rendered']['#markup'];
          $activity = $result->field_field_in_activity[0]['rendered']['#markup'];
          $datetext = $result->field_field_date_text[0]['rendered']['#markup'];
          $prayer = $result->field_field_prayer_point[0]['rendered']['#markup'];
          if (!empty($city)) {
            $title .= $lookup[$result->node_type]['preposition'] . $city;
          }
          if (!empty($activity)) {
            if (!empty($city)) {
              $activity = str_replace(' in ' . $city, '', $activity);
            }
            $title .= ' | ' . $activity;
          }
          $description = "<p><strong>$title </strong></p>";
          if (!empty($datetext)) {
            $description .= "<p><em>$datetext </em></p>";
          }
          $description .= "<p>$prayer</p>";
          $result->field_field_prayer_point[0]['rendered']['#markup'] = $description;
        }
      }
    }
  }

  $class = $view->display_handler->get_option('css_class');
  switch (count($view->result)) {
    case 0:
      $c = '';
      break;

    case 1:
      $c = 'views-1-row';
      break;

    case 2:
    case 3:
      $c = 'views-' . count($view->result) . '-rows';
      break;

    default:
      $c = 'views-n-rows';
      break;
  }
  $view->display_handler->set_option('css_class', trim($class . ' ' . $c));
}

/*
 * Implements hook_views_post_execute.
 *
 * https://api.drupal.org/api/views/views.api.php/function/hook_views_post_execute/7.x-3.x
 *
 *  "This hook is called right after the execute process. The query has been executed,
 *   but the pre_render() phase has not yet happened for handlers.
 *
 *  "Adding output to the view can be accomplished by placing text on $view->attachment_before
 *   and $view->attachment_after. Altering the content can be achieved by editing the items of
 *   $view->result"
 */
function cbf_views_post_execute(&$view) {
  /*
   * This function prevents block displays being crowded out by Events of a single Activity
   * (eg Bible Shots runs 3 events each week). These block displays are indicated by either
   *  1. The view is tagged with 'merge-events'
   *  2. The display is marked with a CSS class 'cbf-merge-events'
   *
   * The display is set to not limit the number of items
   *  1. By default this is limited by this function to 5
   *  2. If the display has the CSS class 'show-N-items' then this function limits the number
   *     to N, where N is an integer
   *
   * To prevent this crowding out, we check if there are multiple Events sharing the same
   * name and Activity. If that's the case, we 'summarise' those Events: we keep the first
   * and the rest are removed from the results. The Date Text of that first Event is altered
   * to include a link to a page of events for the Event's Activity.
   */
  if (
    (
      preg_match(
        '/(^| )merge-events(,|$)/i',
        $view->tag) == 1
      ||
      preg_match(
        '/(^| )cbf-merge-events($| )/i',
        $view->display_handler->get_option('css_class')) == 1
    ) &&
    $view->display_handler->plugin_name == 'block') {
    /*
     * $eventsByActivity is an array of arrays. It maps from Activity Id to Event name to
     * index of the first element of $view->result that has that Activity Id and name.
     *
     * $summarised is an array that maps from the Event that will be summarised to the
     * Event that summarises it. The keys and values are indexes in $view->result.
     */
    $eventsByActivity = array();
    $summarised = array();
    foreach ($view->result as $r => $result) {
      /*
       * Do not summarise Events that aren't part of an Activity
       */
      if (!isset($result->field_field_in_activity[0]['raw']['target_id'])) {
        continue;
      }
      $activity = $result->field_field_in_activity[0]['raw']['target_id'];

      /*
       * Get the title
       */
      if (isset($result->node_title)) {
        $name = $result->node_title;
      } elseif (isset($result->civicrm_event_title)) {
        $name = $result->civicrm_event_title;
      } elseif (isset($result->field_field_title)) {
        $name = $result->field_field_title[0]['rendered']['#markup'];
      } else {
        continue;
      }

      /*
       * Find the event which can summarise this one
       */
      $summaryEvent = false;
      if (!isset($eventsByActivity[$activity])) {
        $eventsByActivity[$activity] = [];
      }
      foreach ($eventsByActivity[$activity] as $n => $i) {
        if ($n == $name) {
          $summaryEvent = $i;
          break;
        }
      }
      if ($summaryEvent !== false) {
        $summarised[$r] = $summaryEvent;
      }
      else {
        $eventsByActivity[$activity][$name] = $r;
      }
    }

    /*
     * If any events are summarised, remove them from the results and update the Date
     * Text of the summary event
     */
    if (!empty($summarised)) {
      $alteredResults = [];
      foreach ($view->result as $r => $result) {
        if (!isset($summarised[$r])) {
          if (in_array($r, $summarised)) {
            $result->__cbf_merge_events = drupal_get_path_alias("node/" . $result->field_field_in_activity[0]['raw']['target_id']);
          }
          $alteredResults[] = $result;
        }
      }
      $view->result = $alteredResults;
    }

    /*
     * Since we may have summarised multiple events into one, we can't
     * rely on the view to limit the number of events displayed.
     */
    $maximumDisplayed = 5;
    $matches = [];
    if (
      preg_match(
        '/(^| )show-([0-9]+)-items($| )/i',
        $view->display_handler->get_option('css_class'),
        $matches
      ) == 1) {
      $maximumDisplayed = intval($matches[2]);
    }
    if (count($view->result) > $maximumDisplayed) {
      $alteredResults = [];
      $i = 0;
      foreach ($view->result as $r => $result) {
        if ($i++ == $maximumDisplayed) {
          break;
        }
        $alteredResults[] = $result;
      }
      $view->result = $alteredResults;
    }
  }

  /*
   * If a view returns no results, and the 'no results' behaviour is to return
   * the results of a second view, we want the title of this view to equal that
   * of the second.
   */
  if (
     empty($view->result) &&
    !empty($view->empty['view']->options['view_to_insert'])
  ) {
    list($view_name, $display_id) = explode(':', $view->empty['view']->options['view_to_insert']);
    $noResults = views_get_view($view_name);
    if (
      !empty($noResults) &&
      $noResults->access($display_id)
    ) {
      $noResults->set_display($display_id);
      $title = $noResults->get_title();
      $view->set_title($title);
    }
  }

  /*
   * If a field_field_source_entity_type is (say) 'civicrm_event' then any
   * URL built from it needs to contain 'civicrm-event'.
   */
  foreach ($view->result as $r => $result) {
    if (isset($result->field_field_source_entity_type)) {
      $result->field_field_source_entity_type[0]['rendered']['#markup']
        = str_replace('_', '-', $result->field_field_source_entity_type[0]['rendered']['#markup']);
    }
  }
}

/*
 * An implementation of hook_contextual_links_view_alter
 *
 * Alter a contextual links element before it is rendered.
 *
 * This hook is invoked by contextual_pre_render_links(). The renderable array
 * of #type 'contextual_links', containing the entire contextual links data
 * that is passed in by reference. Further links may be added or existing
 * links can be altered.
 */
function cbf_contextual_links_view_alter(&$element, $items) {
  /*
   * With nodes it doesn't make sense for the destination of the contextual
   * link to be the same node. Eg, 'delete' and 'clone content'. Remove the
   * destination by removing the query from the link URL.
   */
  if (isset($element['#element']['#node'])) {
    foreach (array('node-delete', 'node-clone-') as $i) {
      if (!empty($element['#links'][$i]['query'])) {
        $element['#links'][$i]['query'] = array();
      }
    }
  }
}

/*
 * An implementation of theme_entity_property()
 *
 * Some properties include HTML and the default behaviour is that the entities
 * are encoded. In these cases, decode them.
 */
function cbf_entity_property($variables) {
  switch ($variables['elements']['#entity_type']) {
    case 'civicrm_event':
      switch ($variables['elements']['#property_name']) {
        case 'description':
          $variables['content'] = decode_entities($variables['content']);
          break;
      }
      break;
  }
  $variables['label_hidden'] = true;

  return theme_entity_property($variables);
}

/*
 * If the $output string is being displayed on a page associated with a
 * particular $city, then remove strings of the form ' in $city'.
 *
 * Purpose:
 *    To avoid blocks having repeating references to ' in $city' when
 *    the page context tells us we are ' in $city'.
 *
 * Examples:
 *  - On the page /city/sydney remove the string ' in Sydney' from
 *    the 'node'/'title' of Activities listed in views.
 *  - On the page /city/activity/public-forum don't change the titles
 *    of sub-activities, which are ' in Sydney', ' in Perth' etc.
 *
 * Potential issues:
 *  - May need to restrict logic to blocks.
 *  - $output is HTML so may contain ' in $city' as part of the markup.
 *    This is unlikely given the current conventions for URLs, CSS class
 *    names etc.
 */
function cbf_trim_in_city_string($output) {
  $city = cbf_city_string();
  if ($city !== false) {
    $output = str_replace(' in ' . ucwords($city), '', $output);
  }
  return $output;
}

function cbf_preprocess_html(&$variables) {
  // Is this page associated with a city? Add a CSS class accordingly.
  $city = cbf_city_string();
  if ($city !== false) {
    $variables['classes_array'][] = 'city-' . $city;
  }
}

/*
 * Returns HTML for a breadcrumb trail
 */
function cbf_breadcrumb($variables, $structure) {
  $breadcrumb = array();
  $city = cbf_city_string();
  if (!empty($city)) {
    $prefix = "/city/$city";
  }
  else {
    $prefix = '/city';
  }

  foreach ($structure as $context => $components) {
    switch ($context) {
      case 'front';
        if (drupal_is_front_page()) {
          break 2;
        }
        break;

        case 'node';
        $node = menu_get_object();
        if (!empty($node)) {
          $type = $node->type;
          break 2;
        }
        break;

      case 'default';
        break 2;
    }
  }

  foreach ($components as $component => $default) {
    $new = null;
    switch ($component) {
      case 'home';
        $new = array($component, 'Home', '/');
        break;

      case 'city';
        if (!empty($city)) {
          $new = array($component, ucwords($city), $prefix);
        }
        break;

      case 'type';
        if (!empty($type)) {
          switch ($type) {
            case 'event':
              $new = array($component, 'events', "$prefix/events");
              break;
            case 'story':
              $new = array($component, 'news', "$prefix/news");
              break;
            case 'episode':
              $new = array($component, 'library', '/library');
              break;
            case 'blog':
              $new = array($component, 'blog', '/articles');
              break;
            case 'activity':
              $new = array($component, 'activities', "$prefix/activities");
              break;
          }
        }
        break;
    }

    if (!empty($new)) {
      $breadcrumb[] = $new;
    }
    elseif (!empty($default)) {
      $breadcrumb[] = array($component, $default, null);
    }
  }

  $output = '';
  if (!empty($breadcrumb)) {
    $output = '<div class="breadcrumb">';
    foreach ($breadcrumb as $crumb) {
      $output .= '<span class="crumb ' . $crumb[0] . '">';
      if (!empty($crumb[2])) {
        $output .= '<a href="' . $crumb[2] . '">' . $crumb[1] . '</a>';
      }
      else {
        $output .= $crumb[1];
      }
      $output .= '</span>';
    }
    $output .= '</div>';
  }

  return $output;
}

/**
 * Implements hook_webform_validation_validators()
 */
function cbf_webform_validation_validators() {
  return array(
    'existing_contact_id' => array(
      'name' => 'Existing Contact Id',
      'description' => "Validate the Contact already exists",
      'component_types' => array(
        'civicrm_contact',
      ),
    )
  );
}

/**
 * Implements hook_webform_validation_validate()
 *
 * Validates that Webform CiviCRM components of type 'civicrm_contact' already exist.
 * If an existing contact is chosen the value captured is a string containing a
 * positive integer. If the component is empty the value captured is empty. Otherwise
 * the value captured is a hyphen followed by the content typed by the user.
 */
function cbf_webform_validation_validate($validator_name, $items, $components, $rule) {
  if ($items) {
    switch ($validator_name) {
      case 'existing_contact_id':
        $errors = array();
        $filterOptions = array(
          'options' => array(
            'min_range' => 1,
          ),
        );
        foreach ($items as $key => $value) {
          if (filter_var($value, FILTER_VALIDATE_INT, $filterOptions) === false) {
            $errors[$key] = t('%item is not a valid contact', array('%item' => $components[$key]['name']));
          }
        }
        return $errors;
        break;
    }
  }
}

/**
 * Modify an iCal event's raw data. If the event is derived from a viewable
 * EntityForm which has a field_field_source_entity_alias then use that field
 * for the iCal event's URL.
 *
 * This hook is invoked after Date iCal has gathered all the data it will use
 * to build an event object.
 *
 * @param array $event
 *   A reference to an associative array containing the event's raw data.
 * @param object $view
 *   The view object that is being executed to render the iCal feed.
 * @param array $context
 *   Depending on whether this event is being constructed using the Fields or
 *   Entity plugins, this context array will have different keys and values.
 *
 *   Entity Plugin:
 *   - 'entity_type': The type of entity being rendered (e.g. 'node').
 *   - 'entity': The fully loaded entity being rendered.
 *   - 'language': The language code that indicates which translation of field
 *     data should be used.
 *
 *   Fields Plugin:
 *   - 'row': The full Views row object being converted to an event.
 *   - 'row_index': The index into the query results for this view.
 *   - 'language': The language code that indicates which translation of field
 *     data should be used.
 *   - 'options': The Fields plugin options.
 */
function cbf_date_ical_export_raw_event_alter(&$event, $view, $context) {
  global $base_url;

  if (!empty($context['row'])) {
    $row = $context['row'];
    if (!empty($row->field_field_source_entity_alias[0]['raw']['value'])) {
      $event['url'] = $base_url . '/' . $row->field_field_source_entity_alias[0]['raw']['value'];
    }
  }
}

function cbf_entity_insert($entity, $type) {
  cbf_entity_viewable($entity, $type, 'insert');
}

function cbf_entity_update($entity, $type) {
  cbf_entity_viewable($entity, $type, 'update');
}

function cbf_entity_delete($entity, $type) {
  cbf_entity_viewable($entity, $type, 'delete');
}

function cbf_entity_viewable($entity, $type, $operation) {
  $entityTypes = [
    'node' => [
      'id' => 'nid',
      'type' => 'type',
      'status' => 'status',
      'bundles' => [
        'activity' => [
          'highlightable',
        ],
        'blog' => [
          'highlightable',
        ],
        'episode' => [
          'highlightable',
        ],
        'event' => [
          'dateable',
          'highlightable',
        ],
        'page' => [
          'highlightable',
        ],
        'story' => [
          'dateable',
          'highlightable',
        ],
      ],
    ],
    'civicrm_event' => [
      'id' => 'id',
      'status' => 'is_public',
      'viewables' => [
        'dateable',
        'highlightable',
      ],
    ],
  ];

  /*
   * Look up entity $type to determine what viewable entities are supported
   * Some entity $type's have bundles
   */
  $viewables = [ ];
  if (isset($entityTypes[$type])) {
    if (
      isset($entityTypes[$type]['bundles']) &&
      isset($entityTypes[$type]['bundles'][$entity->{$entityTypes[$type]['type']}])
    ) {
      $viewables = $entityTypes[$type]['bundles'][$entity->{$entityTypes[$type]['type']}];
    }
    elseif (isset($entityTypes[$type]['viewables'])) {
      $viewables = $entityTypes[$type]['viewables'];
    }

    /*
     * The $sourceEntityId is the Id of the source $entity.
     * Internally it is used with source entity $type as a 'unique' key to look
     * up the viewable entity that corresponds to the source entity.
     */
    $sourceEntityId = $entity->{$entityTypes[$type]['id']};

    /*
     * Check the status of the entity. The fields of the viewable entity will
     * only be retrieved if($status) succeeds.
     */
    if (isset($entityTypes[$type]['status'])) {
      $status = !empty($entity->{$entityTypes[$type]['status']});
    }
    else {
      $status = true;
    }
  }

  /*
   * Process each viewable entity that may be associated with the source $entity
   */
  foreach ($viewables as $viewable) {
    /*
     * Look for the 'unique' viewable entity that corresponds to the source entity
     * Warn if it is not unique
     */
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'entityform')
      ->entityCondition('bundle', $viewable)
      ->fieldCondition('field_source_entity_type', 'value', $type, '=')
      ->fieldCondition('field_source_entity_id', 'value', $sourceEntityId, '=')
      // Run the query as user 1.
      ->addMetaData('account', user_load(1));

    $result = $query->execute();
    if (!isset($result['entityform'])) {
      $entityForm = null;
    }
    else {
      $entityForm = entity_load('entityform', array_keys($result['entityform']));
      if (count($entityForm) > 1) {
        watchdog(
          'CBF',
          "Source entity $type/$sourceEntityId has multiple $viewable entities",
          null,
          WATCHDOG_ERROR
        );
      }
      $entityForm = reset($entityForm);
    }

    /*
     * Get the fields from the source $entity
     */
    if ($status && $operation != 'delete') {
      $viewableFunction = "cbf_entity_$viewable";
      $viewableEntity = $viewableFunction($entity, $type);
    }
    else {
      $viewableEntity = [ ];
    }

    if (!empty($viewableEntity)) {
      /*
       * This entity has fields that need to be reproduced in a viewable entity
       */

      /*
       * If the viewable entity wasn't found, create it
       */
      if (empty($entityForm)) {
        global $user;

        $entityForm = entity_create(
          'entityform',
          [
            'type' => $viewable,
            'created' => time(),
            'changed' => time(),
            'language' => LANGUAGE_NONE,
            'uid' => $user->uid,
          ]
        );
      }

      /*
       * Set the fields
       */
      try {
        $wrapper = entity_metadata_wrapper('entityform', $entityForm);
        $wrapper->field_source_entity_type = $type;
        $wrapper->field_source_entity_id = $sourceEntityId;
        foreach ($viewableEntity as $name => $value) {
          $wrapper->$name = $value;
        }

        $wrapper->save();
      }
      catch (EntityMetadataWrapperException $e) {
        watchdog(
          'CBF',
          "Source entity $type/$sourceEntityId caused exception: " . $e->getMessage(),
          null,
          WATCHDOG_ERROR
        );
      }
    }
    else {
      /*
       * This entity has no content that needs to be reproduced in a viewable entity
       * Delete the viewable entity
       */
      if (!empty($entityForm)) {
        entity_delete('entityform', $entityForm->entityform_id);
      }
    }
  }
}

/*
 * cbf_entity_viewable_fields() gets the named $fields from the source $entity
 */
function cbf_entity_viewable_fields($entity, $type, $fields) {
  /*
   * Metadata for the fields in the source $entity. Each of the $fields in
   * the viewable entity is matched against one of these $fromFields in
   * the source $entity. The metadata is ...
   *  - field    - the name of the field in the source $entity
   *  - value    - controls how the field value is obtained (see below)
   *  - required - if the retrieved field value is null, and 'required' is
   *               true, then return a failure (empty result array) so the
   *               viewable entity will not be created
   *  - default  - if the retrieved field value is null, and 'required' is
   *               false, then use the default value
   */
  $fromFields = [
    'field_title' => [
      'field' => 'field_title',
      'value' => 'value',
      'default' => $entity->title,
    ],
    'field_subtitle' => [
      'field' => 'field_subtitle',
      'value' => 'value',
      'default' => '',
    ],
    'taxonomy_vocabulary_1' => [
      'field' => 'taxonomy_vocabulary_1',
      'value' => 'tid',
      'default' => null,
    ],
    'taxonomy_vocabulary_3' => [
      'field' => 'taxonomy_vocabulary_3',
      'value' => 'tid',
      'required' => true,
    ],
    'field_activity_category' => [
      'field' => 'field_activity_category',
      'value' => 'tid',
      'default' => null,
    ],
    'field_in_activity' => [
      'field' => 'field_in_activity',
      'value' => 'target_id',
      'default' => null,
    ],
    'field_event_date' => [
      'field' => 'field_event_date',
      'value' => 'array',
      'default' => null,
    ],
    'field_episode_date' => [
      'field' => 'field_episode_date',
      'value' => 'get timestamp',
      'default' => null,
    ],
    'field_highlight_dates' => [
      'field' => 'field_highlight_dates',
      'value' => 'array',
      'default' => null,
    ],
    'field_thumbnail_image' => [
      'field' => 'field_thumbnail_image',
      'value' => 'reset array',
      'default' => null,
    ],
    'field_highlight' => [
      'field' => 'field_highlight',
      'value' => 'reset array',
      'default' => null,
    ],
    'field_highlight_location' => [
      'field' => 'field_highlight_location',
      'value' => 'array',
      'default' => null,
    ],
    'domain_entityform' => [
      'field' => 'field_domain',
      'value' => 'array',
      'default' => null,
    ],
  ];

  $result = [ ];

  foreach ($fields as $to) {
    $from = $fromFields[$to];
    $field = field_get_items($type, $entity, $from['field']);

    /*
     * If the $field in $entity is empty, either fail if the field is required,
     * or use the default value.
     */
    if (empty($field)) {
      if (isset($from['required'])) {
        return [ ];
      }
      $result[$to] = $from['default'];
    }
    else switch ($from['value']) {
      /*
       * The 'value' metadata controls how the $field value is extracted ...
       *  - 'array'         - all values in the field
       *  - 'reset array'   - the first element in the value array
       *  - 'get timestamp' - treat the first element as a date array
       *  - otherwise the 'value' is interpreted as the name of an element
       *    in the first element of the value array
       */
      case 'array':
        $result[$to] = $field;
        break;

      case 'reset array':
        $result[$to] = reset($field);
        break;

      case 'get timestamp':
        $field = reset($field);
        $time = new DateObject($field['value'], $field['timezone']);
        $result[$to] = strtotime($time->format('Y-m-d H:i:s O'));
        break;

      default:
        $result[$to] = reset($field)[$from['value']];
        break;
    }
  }

  /*
   * Special case - the thumbnail image is sourced from the available images in
   * the following order of preference ...
   *  - field_thumbnail_image
   *  - field_series_image
   *  - field_image
   *  - field_highlight
   */
  if (in_array('field_thumbnail_image', $fields) && empty($result['field_thumbnail_image'])) {
    $field = field_get_items($type, $entity, 'field_series_image');
    if (!empty($field)) {
      $result['field_thumbnail_image'] = reset($field);
    }
    else {
      $field = field_get_items($type, $entity, 'field_image');
      if (!empty($field)) {
        $result['field_thumbnail_image'] = reset($field);
      }
      else {
        $field = field_get_items($type, $entity, 'field_highlight');
        if (!empty($field)) {
          $result['field_thumbnail_image'] = reset($field);
        }
      }
    }
  }

  /*
   * Special case - if the source $entity is a civicrm_event its subtitle will
   * be found in the 'summary' attribute.
   */
  if (in_array('field_subtitle', $fields) && !empty($entity->summary)) {
    $result['field_subtitle'] = $entity->summary;
  }

  /*
   * Special case - if the source $entity is a node the 'domains' attribute
   * hold the domain values
   */
  if (in_array('domain_entityform', $fields) && !empty($entity->domains)) {
    $result['domain_entityform'] = [ ];
    foreach ($entity->domains as $domain) {
      $result['domain_entityform'][] = [ 'domain_id' => $domain ];
    }
  }

  return $result;
}

/*
 * cbf_entity_dateable() gets the needed $fields from the source $entity
 */
function cbf_entity_dateable($entity, $type) {
  return cbf_entity_viewable_fields(
    $entity,
    $type,
    [
      "field_title",
      "field_subtitle",
      "taxonomy_vocabulary_1",
      "taxonomy_vocabulary_3",
      "field_in_activity",
      "field_event_date",
      "field_episode_date",
      "field_thumbnail_image",
      "field_highlight_location",
      "domain_entityform",
    ]
  );
}

/*
 * cbf_entity_dateable() gets the needed $fields from the source $entity
 */
function cbf_entity_highlightable($entity, $type) {
  return cbf_entity_viewable_fields(
    $entity,
    $type,
    [
      "field_title",
      "field_subtitle",
      "taxonomy_vocabulary_1",
      "taxonomy_vocabulary_3",
      "field_in_activity",
      "field_highlight",
      "field_highlight_location",
      "field_activity_category",
      "field_highlight_dates",
      "domain_entityform",
    ]
  );
}
