<?php

/*
 * This hook is called at the beginning of a Drupal page request.
 */
function cbf_init() {
  if (arg(0) == 'node') {
    if (arg(1) == 'add') {
      /*
       * This JavaScript sets some defaults when adding new nodes.
       *  1. The Summary for the Body displays to encourage entry
       *  2. Tablefield fields default to plain text
       *  3. The File Field source is ICME to encourage reuse
       *
       * See "How to display summary field on node edit form by default?"
       * http://drupal.org/node/1395422#comment-6450618
       */
      $script = 'jQuery(document).ready(function(){
        jQuery(".link-edit-summary").click();
        jQuery(".field-type-tablefield .filter-wrapper select.filter-list option").each(function() {
          this.selected = (this.text == "Plain text");
        });
        jQuery(".filefield-source-imce").click();
      });';
      drupal_add_js($script, 'inline');
    }
    elseif (is_numeric(arg(1)) && arg(2) == 'edit') {
      /*
       * This JavaScript sets some defaults when editing nodes.
       *  1. The File Field source is ICME to encourage reuse
       */
      $script = 'jQuery(document).ready(function(){
        jQuery(".filefield-source-imce").click();
      });';
      drupal_add_js($script, 'inline');
    }
  }
  return array();
}

/*
 * This hook is called to alter Drupal comment forms.
 *
 * This change prevents anonymous users accessing the 'homepage' field.
 * Spammers were using this field to get backlinks to their content on
 * this website.
 */
function cbf_form_comment_form_alter(&$form, &$form_state, $form_id) {
  if (user_is_anonymous()) {
    if (isset($form['author']['homepage']['#access'])) {
      $form['author']['homepage']['#access'] = false;
    }
  }
}

/*
 * This hook is called before a comment is saved
 * 
 * Spam comments are being submitted with a certain subject line. This hook prevents
 * those comments being published in the rare case Mollom doesn't stop it.
 */
function cbf_comment_presave($comment) {
  if ($comment->subject == 'Add new comment | City Bible Forum') {
    $comment->status = 0;
  }
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Sort Order.
 * The value is set to the timestamp of the start date for the Field Event Date.
 * If the event is a repeating event then apply this logic to the first date in the future.
 */
function computed_field_field_sort_order_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $current_time = strtotime('now');
  $timestamp = 0;
  $field_event_date = field_get_items($entity_type, $entity, 'field_event_date');
  if ($field_event_date !== false && !empty($field_event_date)) {
    foreach ($field_event_date as $event_occurrence) {
      $utc_start_time = new DateObject($event_occurrence['value'], 'UTC');
      $utc_start_time_string = date_format_date($utc_start_time, 'custom', 'Y-m-d H:i:s O');
      $timestamp = strtotime($utc_start_time_string);

      $utc_end_time = new DateObject($event_occurrence['value2'], 'UTC');
      $utc_end_time_string = date_format_date($utc_end_time, 'custom', 'Y-m-d H:i:s O');
      $endstamp = strtotime($utc_end_time_string);

      if ($endstamp > $current_time) {
        break;
      }
    }
  }

  $entity_field[0]['value'] = $timestamp;
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Sort Order.
 * It returns a string of the form '2011-10-22 22:41:25 +1100'.
 */
function computed_field_field_sort_order_display($field, $entity_field_item) {
  $utc_start_time = new DateObject($entity_field_item['value'], 'UTC');
  return date_format_date($utc_start_time, 'custom', 'Y-m-d H:i:s O');
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Next Action.
 * The value is set to the timestamp of the end date for the Field Event Date.
 * If the event is a repeating event then apply this logic to the first date in the future.
 */
function computed_field_field_next_action_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $current_time = strtotime('now');
  $timestamp = 0;
  $field_event_date = field_get_items($entity_type, $entity, 'field_event_date');
  if ($field_event_date !== false && !empty($field_event_date)) {
    foreach ($field_event_date as $event_occurrence) {
      $utc_end_time = new DateObject($event_occurrence['value2'], 'UTC');
      $utc_end_time_string = date_format_date($utc_end_time, 'custom', 'Y-m-d H:i:s O');
      $timestamp = strtotime($utc_end_time_string);

      if ($timestamp > $current_time) {
        break;
      }
    }
  }

  $entity_field[0]['value'] = $timestamp;
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Next Action.
 * It returns a string of the form '2011-10-22 22:41:25 +1100'.
 */
function computed_field_field_next_action_display($field, $entity_field_item) {
  $utc_end_time = new DateObject($entity_field_item['value'], 'UTC');
  return date_format_date($utc_end_time, 'custom', 'Y-m-d H:i:s O');
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Date Text.
 *
 * If the entity contains an Episode Date, the text is empty for future dates. Otherwise
 * it is the date.
 * 
 * If all occurrences of the event are in the past, this field is the empty string.
 * Else, show the first future occurrence, along with every other occurrence in the
 *  7 days after that occurrence. 
 * If the first future occurrence is in the next 7 days, show just the weekday, else
 *  show the weekday and date.
 * If there are previous repeats of this event, prefix the date with 'Next on '.
 * If there are no previous repeats, and there are subsequent repeats that are not listed,
 * prefix the date with 'Starts on '.
 * Show the start time, unless it is midnight.
 */
function computed_field_field_date_text_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $current_time = strtotime('now');
  $next_week    = strtotime('now +1 week');
  $startstamp   = 0;
  $endstamp     = 0;
  $upperlimit   = 0;
  $previous     = 0;
  $subsequent   = 0;
  $date_future  = 'D M jS';
  $date_past    = 'M jS, Y';
  $time_format  = 'g.ia';
  $midnight     = '12.00am';
  $date_text    = '';
  $time_text    = '';

  // Calculate the date text from the (non-repeating) Episode Date
  $field_episode_date = field_get_items($entity_type, $entity, 'field_episode_date');
  if ($field_episode_date !== false && !empty($field_episode_date)) {
    $episode = $field_episode_date[0];
    $local_start_time = new DateObject($episode['value'], $episode['timezone']);
    $local_start_time_string = date_format_date($local_start_time, 'custom', 'Y-m-d H:i:s O');
    $startstamp = strtotime($local_start_time_string);

    if ($startstamp <= $current_time) {
      $date_text = date_format_date($local_start_time, 'custom', $date_past);
      $time_text = $midnight;
    }
  }

  // Calculate the date text from the (perhaps-repeating) Event Date
  $field_event_date = field_get_items($entity_type, $entity, 'field_event_date');
  if ($field_event_date !== false && !empty($field_event_date)) {
    foreach ($field_event_date as $event_occurrence) {
      $utc_start_time = new DateObject($event_occurrence['value'], 'UTC');
      $utc_start_time->setTimezone(new DateTimeZone($event_occurrence['timezone']));
      $utc_start_time_string = date_format_date($utc_start_time, 'custom', 'Y-m-d H:i:s O');
      $startstamp = strtotime($utc_start_time_string);

      $utc_end_time = new DateObject($event_occurrence['value2'], 'UTC');
      $utc_end_time->setTimezone(new DateTimeZone($event_occurrence['timezone']));
      $utc_end_time_string = date_format_date($utc_end_time, 'custom', 'Y-m-d H:i:s O');
      $endstamp = strtotime($utc_end_time_string);

      if ($time_text == '') {
        $time_text = date_format_date($utc_start_time, 'custom', $time_format);
        if ($time_text != $midnight) {
          $time_text .= '-' . date_format_date($utc_end_time, 'custom', $time_format);
        }
        $time_text = str_replace('.00', '', $time_text);
      }

      if ($upperlimit == 0 && $endstamp > $current_time) {
        $upperlimit = $startstamp + ($next_week - $current_time);
      }

      if ($endstamp <= $current_time) {
        $previous++;
      }
      else if ($startstamp >= $upperlimit) {
        $subsequent++;
      }
      else {
        $start_date_text = date_format_date($utc_start_time, 'custom', $date_future);
        $end_date_text = date_format_date($utc_end_time, 'custom', $date_future);

        if ($start_date_text == $end_date_text) {
          $this_date_text = $start_date_text;
        }
        else {
          $this_date_text = $start_date_text . ' to ' . $end_date_text;
          $time_text = $midnight;
        }

        if ($date_text == '') {
          $date_text = $this_date_text;
        }
        else {
          $date_text .= ', ' . $this_date_text;
        }
      }
    }
  }

  if ($date_text == '') {
    $entity_field[0]['value'] = '';
  }
  else {
    if ($previous > 0) {
      $date_text = 'Next on ' . $date_text;
    }
    else if ($subsequent > 0) {
      $date_text = 'Starts on ' . $date_text;
    }
    if ($time_text == $midnight) {
      $entity_field[0]['value'] = $date_text;
    } else {
      $entity_field[0]['value'] = $date_text . ', ' . $time_text;
    }
  }
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Date Text.
 */
function computed_field_field_date_text_display($field, $entity_field_item) {
  return $entity_field_item['value'];
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Is Audio.
 */
function computed_field_field_is_audio_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $field_content = field_get_items($entity_type, $entity, 'field_content');
  if ($field_content !== false && !empty($field_content)) {
    $entity_field[0]['value'] = 1;
  }
  else {
    $entity_field[0]['value'] = 0;
  }
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Is Audio.
 */
function computed_field_field_is_audio_display($field, $entity_field_item, $entity_lang, $langcode) {
  if ($entity_field_item['value'] != 0) {
    return 'Yes';
  }
  else {
    return 'No';
  }
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Is Video.
 */
function computed_field_field_is_video_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $field_video = field_get_items($entity_type, $entity, 'field_video');
  if ($field_video !== false && !empty($field_video)) {
    $entity_field[0]['value'] = 1;
  }
  else {
    $entity_field[0]['value'] = 0;
  }
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Is Video.
 */
function computed_field_field_is_video_display($field, $entity_field_item, $entity_lang, $langcode) {
  if ($entity_field_item['value'] != 0) {
    return 'Yes';
  }
  else {
    return 'No';
  }
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Is Text.
*/
function computed_field_field_is_text_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $field_attachment = field_get_items($entity_type, $entity, 'field_attachment');
  if ($field_attachment !== false && !empty($field_attachment)) {
    $entity_field[0]['value'] = 1;
  }
  else {
    $entity_field[0]['value'] = 0;
  }
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Is Text.
*/
function computed_field_field_is_text_display($field, $entity_field_item, $entity_lang, $langcode) {
  if ($entity_field_item['value'] != 0) {
    return 'Yes';
  }
  else {
    return 'No';
  }
}

/*
 * This function is called by CCK Computed Field to compute the value of field Add to Calendar.
*/
function computed_field_field_add_to_calendar_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $field_date_text = field_get_items($entity_type, $entity, 'field_date_text');
  if ($field_date_text !== false && empty($field_date_text[0]['value'])) {
    $entity_field[0]['value'] = null; // The entity is an event and it has passed
    return;
  }
  $field_civievent = field_get_items($entity_type, $entity, 'field_civievent');
  if ($field_civievent !== false && !empty($field_civievent[0]['target_id'])) {
    $entity_field[0]['value'] = null; // There is a CiviEvent
    return;
  }
  $field_publish_calendar = field_get_items($entity_type, $entity, 'field_publish_calendar');
  if ($field_publish_calendar !== false && empty($field_publish_calendar[0]['value'])) {
    $entity_field[0]['value'] = null; // The 'Publish calendar' flag has been unticked
    return;
  }
  $content_type = $entity->type;
  $entity_nid = $entity->nid;
  $field_in_activity = field_get_items($entity_type, $entity, 'field_in_activity');
  if ($field_in_activity !== false && !empty($field_in_activity)) {
    $entity_activity = $field_in_activity[0]['target_id'];
    $activity = node_load($entity_activity);
    $field_publish_calendar = field_get_items('node', $activity, 'field_publish_calendar');
    if ($field_publish_calendar === false || empty($field_publish_calendar[0]['value'])) {
      $entity_activity = 0; // The activity's 'Publish calendar' flag has not been ticked
    }
  }
  else {
    $entity_activity = 0;
  }
  $field_event_date = field_get_items($entity_type, $entity, 'field_event_date');
  if ($field_event_date != false) {
    $event_count = count($field_event_date); // a possibly-repeating event
  }
  else {
    $event_count = 2; // the other cases will have multiple events (at least 2)
  }
  $taxonomy_vocabulary_1 = field_get_items($entity_type, $entity, 'taxonomy_vocabulary_1');
  if ($taxonomy_vocabulary_1 !== false && !empty($taxonomy_vocabulary_1)) {
    $term = taxonomy_term_load($taxonomy_vocabulary_1[0]['tid']);
    $city = $term->name;
  }
  else {
    $city = '';
  }
  if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {
    $host = $_SERVER['HTTP_X_HOST'];
  }
  else {
    $host = $_SERVER['SERVER_NAME'];
  }
  $schemes = array();
  $results = array();
  $types = array();
  $nids = array();
  $title = '';
  $description = '';
  $startDate = '';
  $endDate = '';
  if ($content_type == 'event') {
    if ($event_count == 1) {
      $schemes[] = 'single';
      $types['single'] = $content_type;
      $nids['single'] = $entity_nid;
      $title = $entity->title;
      $body = field_get_items($entity_type, $entity, 'body');
      if ($body !== false && !empty($body)) {
        $description = truncate_utf8($body[0]['value'], 600, TRUE, TRUE);
      }
      $startDate = '';
      $endDate = '';
    }
    else {
      $schemes[] = 'multiple';
      $types['multiple'] = $content_type;
      $nids['multiple'] = $entity_nid;
    }
    if (!empty($entity_activity)) {
      $schemes[] = 'subscribe';
      $types['subscribe'] = 'activity';
      $nids['subscribe'] = $entity_activity;
    }
  }
  elseif ($content_type == 'activity') {
    $schemes[] = 'subscribe';
    $types['subscribe'] = $content_type;
    $nids['subscribe'] = $entity_nid;
  }
  if (!empty($city)) {
    $schemes[] = 'city';
    $types['city'] = strtolower($city);
    $nids['city'] = 0;
  }
  $clients = array(
    'Apple' => array('single' => 'ics', 'multiple' => 'ics', 'subscribe' => 'webcal', 'city' => 'webcal'),
    'Outlook' => array('single' => 'ics', 'multiple' => 'ics', 'subscribe' => 'webcal', 'city' => 'webcal'),
    'Google Calendar' => array('single' => 'google', 'multiple' => '', 'subscribe' => 'google webcal', 'city' => 'google webcal'),
    'Other' => array('single' => 'ics', 'multiple' => 'ics', 'subscribe' => 'ics', 'city' => 'ics'),
  );
  foreach ($schemes as $scheme) {
    $results[$scheme] = '';
    foreach ($clients as $client => $methods) {
      if ($scheme == 'city') {
        $relative_url = "/ical/city/$types[$scheme]/calendar.ics";
      }
      else {
        $relative_url = "/ical/$types[$scheme]/$nids[$scheme]/calendar.ics";
      }
      switch ($methods[$scheme]) {
        case 'ics':
          $target = $relative_url;
          break;
        case 'webcal':
          $target = "webcal://$host$relative_url";
          break;
        case 'google':
          if (empty($title) || empty($startDate) || empty($endDate)) {
            $target = '';
          }
          else {
            $target = url(
              'http://www.google.com/calendar/event',
              array(
                'query' => array(
                  'action' => 'TEMPLATE',
                  'text' => $title,
                  'dates' => $startDate . '/' . $endDate,
                  'sprop' => 'website:' . $host,
//                  'location' => $info['location'],
                  'details' => $description,
                  'website' => url($info['url'], array('absolute' => TRUE)),
              )));
          }
          break;
        case 'google webcal':
          $target = url(
            'https://www.google.com/calendar/render',
            array(
              'query' => array('cid' => "webcal://$host$relative_url")));
          break;
        default:
          $target = '';
          break;
      }
      if (!empty($target)) {
        $results[$scheme] .= '<li><a href="' . $target . '" target="_blank" rel="noopener noreferrer">' . $client . '</a></li>';
      }
    }
  }
  if (count($results) == 0) {
    $entity_field[0]['value'] = null;
    return;
  }
  $schemeLabel = array(
    'single' => 'This event only',
    'multiple' => 'This event only',
    'subscribe' => 'This and future events like it',
    'city' => "This and future events for $city",
  );
  $result = '
    <ul class="nav">
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#">Add to calendar</a>
        <ul class="dropdown-menu">';
  if (count($results) == 1) {
    foreach ($results as $scheme => $target) {
      $result .= $target;
    }
  }
  else {
    foreach ($results as $scheme => $target) {
      $result .= '
          <li class="dropdown dropdown-submenu">
            <a class="dropdown-toggle" data-toggle="dropdown" href="#">';
      $result .= $schemeLabel[$scheme];
      $result .= '</a>
            <ul class="dropdown-menu">';
      $result .= $target;
      $result .= '
            </ul>
          </li>';
    }
  }
  $result .= '
        </ul>
      </li>
    </ul>';
  $result .= (count($results) == 1) ? '' : '
    <script type="text/javascript">
      (function($){
        $(document).ready(function(){
          $(\'ul.dropdown-menu [data-toggle=dropdown]\').on(\'click\', function(event) {
            event.preventDefault();
            event.stopPropagation();
            $(this).parent().siblings().removeClass(\'open\');
            $(this).parent().toggleClass(\'open\');
          });
        });
      })(jQuery);
    </script>';
  $entity_field[0]['value'] = $result;
}

/*
 * This function is called by CCK Computed Field to generate the display text of field Add to Calendar.
*/
function computed_field_field_add_to_calendar_display($field, $entity_field_item, $entity_lang, $langcode) {
  if (empty($entity_field_item['value'])) {
    return '';
  }
  return $entity_field_item['value'];
}

/*
 * Implement the rules that assign nodes to domains.
 *
 * Rules are stored in the domain information ...
 *
 *     is_default
 *
 *         This rule matches if this is the default domain
 *
 *     alias = NNNN.activity.rule
 *
 *         NNNN is the node Id for the Activity that corresponds to this domain.
 *         This rule matches if the node's nid or its Activity is NNNN.
 *
 * The rules have the following effects ...
 *
 *     domain_site   false (content is not available in all affiliates)
 *
 *     domains       contains an entry for each domain that matches a rule
 *
 *     domain_source DOMAIN_SOURCE_USE_ACTIVE (don't change domain to a cardinal
 *                   domain)
 */
function cbf_node_presave($node) {
  /*
   * If saving a node after editing it, clear the block cache so the staff
   * member editing the node can see the refreshed version of the views
   * blocks on the page.
   */
  if (arg(0) == 'node' && arg(2) == 'edit') {
    cache_clear_all('*', 'cache_views_data', true);
  }

  $followDomainRules = true;

  if ($followDomainRules) {
    $domains = domain_list_by_machine_name();

    $node->domain_site = false;
    $node->domains = array();
    $node->domain_source = DOMAIN_SOURCE_USE_ACTIVE;

    $field_in_activity = field_get_items('node', $node, 'field_in_activity');
    if ($field_in_activity === false || empty($field_in_activity[0]['target_id'])) {
      $node_activity = 0;
    }
    else {
      $node_activity = $field_in_activity[0]['target_id'];
    }

    foreach ($domains as $domain) {
      $match = false;
      if ($domain['is_default']) {
        $match = true;
      }
      else {
        foreach ($domain['aliases'] as $alias) {
          $activity = stristr($alias['pattern'], '.activity.rule', true);
          if ($activity !== false) {
            $activity = (int) $activity;
            if ($node->nid == $activity || $node_activity == $activity) {
              $match = true;
              break;
            }
          }
          $audience = stristr($alias['pattern'], '.audience.rule', true);
          if ($audience !== false) {
            $match = true;
            break;
          }
        }
      }

      if ($match) {
        $node->domains[$domain['domain_id']] = $domain['domain_id'];
      }
    }

    if (count($node->domains) == 1) {
      $node->domain_source = reset($node->domains);
    }
  }
}

/*
 * CKEditor introduces some unpleasant artifacts into HTML text fields. This
 * function handles them ...
 *
 *   - Empty paragraphs are removed
 *   - Non-breaking spaces are replaced with plain spaces
 *   - Ensure target="_blank" attributes have a rel="noopener noreferrer"
 *     attribute https://medium.com/@jitbit/target-blank-the-most-underestimated-vulnerability-ever-96e328301f4c#.dzwczm21q
 *
 * The order of these actions is important as the patterns have overlapping content.
 */
function cbf_field_attach_presave($entity_type, $entity) {
  if ($entity_type == 'node') {
    $html_fields = array('body', 'field_short_form', 'field_sidebar_content');
    $attributes = array('summary','value');
    $replacements = array(
      '!<p>(\r\n\t)*&nbsp;</p>!i' => '',
      '!&nbsp;!i'                 => ' ',
      '!target="_blank" rel="noopener noreferrer"!i'           => 'target="_blank"',
      '!target="_blank"!i'                                     => 'rel="noopener noreferrer" target="_blank"',
      '!rel="noopener noreferrer" rel="noopener noreferrer"!i' => 'rel="noopener noreferrer"',
    );
    $from = array_keys($replacements);
    $to = array_values($replacements);
    foreach ($html_fields as $html_field) {
      if (isset($entity->$html_field)) {
        $field = & $entity->$html_field;
        $languages = array_keys($field);
        foreach ($languages as $language) {
          $instances = count($field[$language]);
          for ($instance = 0; $instance < $instances; $instance++) {
            foreach ($attributes as $attribute) {
              if (isset($field[$language][$instance][$attribute])) {
                $field[$language][$instance][$attribute]
                  = preg_replace($from, $to, $field[$language][$instance][$attribute]);
              }
            }
          }
        }
      }
    }
  }
}

/*
 * This function is called by cron to update the Field Sort Order and Field Date Text:
 *   field_sort_order   - process all nodes that have a Field Sort Order with a value
 *                        between the last time the cron was called and 1 week from now. 
 *   field_episode_date - process all nodes that have a Field Episode Date with a value
 *                        between the last time the cron was called and now. 
 * The Date Text field changes as follows...
 *    - For events...
 *        - if the event is more than 1 week away, the text is weekday day month
 *        - // if the event is less than 1 week away, the text is weekday //
 *        - if the event is in the past, the text is empty
 *    - For episodes, news, blogs...
 *        - if
 * These nodes are simply opened and saved.
 * The cron time is updated.
 */
function cbf_cron() {
  $current_time = strtotime('now');
  $next_week    = strtotime('now +1 week');
  $last_run     = variable_get('cbf_cron_last_run', 0);

  if ($last_run == 0) {
    $query = new EntityFieldQuery();
    $result = $query->entityCondition('entity_type', 'node')
        ->fieldCondition('field_next_action', 'value', array($last_run), '>')
        ->execute();
    if (isset($result['node'])) {
      $nodes = entity_load('node', array_keys($result['node']));
      foreach ($nodes as $node) {
        node_save($node);
      }
    }
  }
  else {
    /* Clear the date text for past events */
    $query = new EntityFieldQuery();
    $result = $query->entityCondition('entity_type', 'node')
        ->fieldCondition('field_next_action', 'value', array($last_run, $current_time), 'BETWEEN')
        ->execute();
    if (isset($result['node'])) {
      $nodes = entity_load('node', array_keys($result['node']));
      foreach ($nodes as $node) {
        node_save($node);
      }
    }

    /* For events that are 1 week out, change the display
    $query = new EntityFieldQuery();
    $result = $query->entityCondition('entity_type', 'node')
        ->fieldCondition('field_next_action', 'value', array($last_run + ($next_week - $current_time), $next_week), 'BETWEEN')
        ->execute();
    if (isset($result['node'])) {
      $nodes = entity_load('node', array_keys($result['node']));
      foreach ($nodes as $node) {
        node_save($node);
      }
    } */

    /*
     * Set the date text for past episodes. Note that the 'field_episode_date'
     * field has 'value' attribute in the DATE_FORMAT_ISO format. The timezone
     * is the system default.
     */
    $last_run_formatted = format_date($last_run, 'custom', DATE_FORMAT_ISO);
    $current_time_formatted = format_date($current_time, 'custom', DATE_FORMAT_ISO);
    $query = new EntityFieldQuery();
    $result = $query->entityCondition('entity_type', 'node')
        ->fieldCondition(
            'field_episode_date',
            'value',
            array(
                $last_run_formatted,
                $current_time_formatted),
            'BETWEEN')
        ->execute();
    if (isset($result['node'])) {
      $nodes = entity_load('node', array_keys($result['node']));
      foreach ($nodes as $node) {
        node_save($node);
      }
    }

    /*
     * Find nodes that were Tweeted using Post to Twitter. Set their status so
     * they are not tweeted again if any calls are made to node_save().
     */
    $query = new EntityFieldQuery();
    $result = $query->entityCondition('entity_type', 'node')
        ->fieldCondition('field_post_to_twitter', 'status', 0, '<>')
        ->execute();
    if (isset($result['node'])) {
      $nodes = entity_load('node', array_keys($result['node']));
      foreach ($nodes as $node) {
        // Prevent a post being made again to Twitter
        $langcode = field_language('node', $node, 'field_post_to_twitter');
        if (isset($node->field_post_to_twitter[$langcode][0])) {
          $node->field_post_to_twitter[$langcode][0]['status'] = 0;
        }
        node_save($node);
      }
    }
  }

  variable_set('cbf_cron_last_run', $current_time);
}

/*
 * The Contact module sends emails using the To: address supplied
 * by the visitor to a citybibleforum.org address. When this is
 * redirected to a gmail.com address Gmail rightly complains
 * (Unauthenticated email from yahoo.com is not accepted due to
 * domain's 550-5.7.1 DMARC policy)
 *
 * Change the message headers so the email is sent From the Sender
 * address (doulos@citybibleforum.org), but the original address
 * is in the Reply-To header.
 */
function cbf_mail_alter(&$message) {
  $message['headers']['Reply-To'] = $message['headers']['From'];
  $message['headers']['From'] = $message['headers']['Sender'];
}

/*
 * The visitor city name is initially unknown, but only needs to be calculated
 * once per request
 */
function cbf_visitor_city_string() {
  static $cbf_visitor_city = null;

  if (!isset($cbf_visitor_city)) {
    $cbf_visitor_city = false;

    if (!function_exists('ip_geoloc_get_visitor_location')) {
      return $cbf_visitor_city;
    }

    $result = ip_geoloc_get_visitor_location();

    if (isset($result['country']) && isset($result['administrative_area_level_1'])) {
      switch ($result['country']) {
        case 'Australia':
          switch ($result['administrative_area_level_1']) {
            case 'New South Wales':
              $cbf_visitor_city = 'sydney';
              break;
            case 'Victoria':
              $cbf_visitor_city = 'melbourne';
              break;
            case 'Queensland':
              $cbf_visitor_city = 'brisbane';
              break;
            case 'South Australia':
              $cbf_visitor_city = 'adelaide';
              break;
            case 'Western Australia':
              $cbf_visitor_city = 'perth';
              break;
            case 'Australian Capital Territory':
              $cbf_visitor_city = 'canberra';
              break;
          }
          break;
      }
    }
  }

  return $cbf_visitor_city;
}

/*
 * Populate the metatags for a node's Twitter Card and Facebook Open Graph.
 *
 * The Twitter Card preferences are ...
 *
 * #  Twitter card type              Source image     Condition
 * -  -----------------------------  ---------------  ------------------------
 * 1  Summary card with large image  Highlight        Image >= 280px x 150px
 *                                   Series image
 *                                   Image
 * 2  Summary card                   Thumbnail image  Image >= 120px x 120px
 * 3  Summary card                   Logo             No matching image fields
 *
 * The Facebook Open Graph preferences are ...
 *
 * #  Source image  Condition
 * -  ------------  ------------------------
 * 4  Highlight     Image >= 600px x 316px
 *    Series Image
 *    Image
 * 5  Highlight     Image >= 280px wide
 *    Series Image
 *    Image
 * 6  Logo          No matching image fields
 */
function cbf_metatag_pattern_alter(&$pattern, &$types, $tag_name) {
  if (isset($types['node'])) {
    $node = $types['node'];
    $largeImages = array('field_highlight', 'field_image', 'field_series_image');
    switch ($tag_name) {
      case 'twitter:card':
      case 'twitter:image':
        /* Option 3 is the default */
        $card = 'summary';
        $src = '';
        /* Try Option 1 */
        foreach ($largeImages as $largeImage) {
          $image = field_get_items('node', $node, $largeImage);
          if ($image !== false && !empty($image)) {
            if (isset($image[0]['width']) && $image[0]['width'] >= 280 &&
                isset($image[0]['height']) && $image[0]['height'] >= 150) {
              $card = 'summary_large_image';
              $src = "[node:$largeImage]";
              break;
            }
          }
        }
        /* Try Option 2 */
        if ($src == '') {
          $image = field_get_items('node', $node, 'field_thumbnail_image');
          if ($image !== false && !empty($image)) {
            if (isset($image[0]['width']) && $image[0]['width'] >= 120 &&
                isset($image[0]['height']) && $image[0]['height'] >= 120) {
              $src = "[node:field_thumbnail_image]";
            }
          }
        }
        /* Update the tag pattern if changed from the default */
        if ($src != '') {
          switch ($tag_name) {
            case 'twitter:card':
              $pattern = $card;
              break;
            case 'twitter:image':
              $pattern = $src;
              break;
          }
        }
        break;

      case 'og:image':
        /* Option 6 is the default */
        $src = '';
        /* Try Option 4 */
        foreach ($largeImages as $largeImage) {
          $image = field_get_items('node', $node, $largeImage);
          if ($image !== false && !empty($image)) {
            if (isset($image[0]['width']) && $image[0]['width'] >= 600 &&
                isset($image[0]['height']) && $image[0]['height'] >= 316) {
              $src = "[node:$largeImage]";
              break;
            }
          }
        }
        /* Try Option 5 */
        if ($src == '') {
          foreach ($largeImages as $largeImage) {
            $image = field_get_items('node', $node, $largeImage);
            if ($image !== false && !empty($image)) {
              if (isset($image[0]['width']) && $image[0]['width'] >= 280) {
                $src = "[node:$largeImage]";
                break;
              }
            }
          }
        }
        if ($src != '') {
          $pattern = $src;
        }
        break;
    }
  }
}

/*
 * A function to parse the exposed filters on the National Library view,
 * to extract the topics, and return a string containing them.
 */
function cbf_library_view_topics_string(&$view) {
  if ( ! isset($view->exposed_input['field_topic_tid']) ) {
    return ' ';
  }

  $result = array();

  foreach ($view->exposed_input['field_topic_tid'] as $tid) {
    $queryResult = db_query(
      'select name from {taxonomy_term_data} where tid = :tid',
      array(':tid' => $tid));
    foreach ($queryResult as $row) {
      $result[] = $row->name;
    }
  }

  return implode(' | ', $result);
}
