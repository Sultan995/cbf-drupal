<?php

/*
 * This hook is called at the beginning of a Drupal page request.
 */
function cbf_init() {
    if (arg(0) == 'node' && arg(1) == 'add') {
        switch (arg(2)) {
            case 'story':
            case 'blog':
            case 'episode':
            case 'event':
            case 'activity':
                /*
                 * This JavaScript sets some defaults when adding new nodes.
                 *  1. The Summary for the Body displays to encourage entry
                 *  2. By default a tweet is not sent when the node is created
                 *  3. Tablefield fields default to plain text
                 *
                 * See "How to display summary field on node edit form by default?"
                 * http://drupal.org/node/1395422#comment-6450618
                 */
                $script = 'jQuery(document).ready(function(){
                    jQuery(".link-edit-summary").click();
                    jQuery(".field-type-tablefield .filter-wrapper select.filter-list option").each(function() {
                        this.selected = (this.text == "Plain text");
                    });
                });';
                drupal_add_js($script, 'inline');
                break;
        }
    }
    return array();
}

/*
 * This hook is called to alter Drupal comment forms.
 *
 * This change prevents anonymous users accessing the 'homepage' field.
 * Spammers were using this field to get backlinks to their content on
 * this website.
 */
function cbf_form_comment_form_alter(&$form, &$form_state, $form_id) {
    if (user_is_anonymous()) {
        if (isset($form['author']['homepage']['#access'])) {
            $form['author']['homepage']['#access'] = false;
        }
    }
}

/*
 * This hook is called before a comment is saved
 * 
 * Spam comments are being submitted with a certain subject line. This hook prevents
 * those comments being published in the rare case Mollom doesn't stop it.
 */
function cbf_comment_presave($comment) {
    if ($comment->subject == 'Add new comment | City Bible Forum') {
        $comment->status = 0;
    }
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Sort Order.
 * The value is set to the timestamp of the start date for the Field Event Date.
 * If the event is a repeating event then apply this logic to the first date in the future.
 */
function computed_field_field_sort_order_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
    $current_time = strtotime('now');
    $timestamp = 0;
    foreach ($entity->field_event_date[LANGUAGE_NONE] as $event_occurrence) {
        $utc_start_time = new DateObject(
                                $event_occurrence['value'],
                                'UTC' );
        $utc_start_time_string = date_format_date(
                                $utc_start_time,
                                'custom',
                               'Y-m-d H:i:s O');
        $timestamp = strtotime( $utc_start_time_string );

        $utc_end_time = new DateObject(
                                $event_occurrence['value2'],
                                'UTC' );
        $utc_end_time_string = date_format_date(
                                $utc_end_time,
        		                'custom',
        		                'Y-m-d H:i:s O');
        $endstamp = strtotime( $utc_end_time_string );

        if ($endstamp > $current_time) {
            break;
        }
    }

    $entity_field[0]['value'] = $timestamp;
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Sort Order.
 * It returns a string of the form '2011-10-22 22:41:25 +1100'.
 */
function computed_field_field_sort_order_display($field, $entity_field_item) {
    $utc_start_time = new DateObject(
                         $entity_field_item['value'],
                         'UTC' );
    return date_format_date($utc_start_time, 'custom', 'Y-m-d H:i:s O');
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Next Action.
 * The value is set to the timestamp of the end date for the Field Event Date.
 * If the event is a repeating event then apply this logic to the first date in the future.
 */
function computed_field_field_next_action_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
    $current_time = strtotime('now');
    $timestamp = 0;
    foreach ($entity->field_event_date[LANGUAGE_NONE] as $event_occurrence) {
        $utc_end_time = new DateObject(
                                $event_occurrence['value2'],
                                'UTC' );
        $utc_end_time_string = date_format_date(
                                $utc_end_time,
                                'custom',
                               'Y-m-d H:i:s O');
        $timestamp = strtotime( $utc_end_time_string );

        if ($timestamp > $current_time) {
            break;
        }
    }

    $entity_field[0]['value'] = $timestamp;
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Next Action.
 * It returns a string of the form '2011-10-22 22:41:25 +1100'.
 */
function computed_field_field_next_action_display($field, $entity_field_item) {
    $utc_end_time = new DateObject(
                         $entity_field_item['value'],
                         'UTC' );
    return date_format_date($utc_end_time, 'custom', 'Y-m-d H:i:s O');
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Date Text.
 *
 * If the entity contains an Episode Date, the text is empty for future dates. Otherwise
 * it is the date.
 * 
 * If all occurrences of the event are in the past, this field is the empty string.
 * Else, show the first future occurrence, along with every other occurrence in the
 *  7 days after that occurrence. 
 * If the first future occurrence is in the next 7 days, show just the weekday, else
 *  show the weekday and date.
 * If there are previous repeats of this event, prefix the date with 'Next on '.
 * If there are no previous repeats, and there are subsequent repeats that are not listed,
 * prefix the date with 'Starts on '.
 * Show the start time, unless it is midnight.
 */
function computed_field_field_date_text_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
	$current_time = strtotime('now');
	$next_week    = strtotime('now +1 week');
	$startstamp   = 0;
	$endstamp     = 0;
	$upperlimit   = 0;
	$previous     = 0;
	$subsequent   = 0;
	$date_future  = 'D M jS';
	$date_past    = 'M jS, Y';
	$time_format  = 'g.ia';
	$midnight     = '12.00am';
	$date_text    = '';
	$time_text    = '';

	// Calculate the date text from the (non-repeating) Episode Date
	if ( isset($entity->field_episode_date[LANGUAGE_NONE]) ) {
		foreach ($entity->field_episode_date[LANGUAGE_NONE] as $episode) {
			$local_start_time = new DateObject(
			                        $episode['value'],
			                        $episode['timezone'] );                        
			$local_start_time_string = date_format_date(
			                        $local_start_time,
			                        'custom',
		    	                    'Y-m-d H:i:s O');
			$startstamp = strtotime( $local_start_time_string );

			if ($startstamp <= $current_time) {
				$date_text = date_format_date(
				                    $local_start_time,
				                    'custom',
			    	                $date_past);
				$time_text = $midnight;
			}

			break;
		}
	}

	// Calculate the date text from the (perhaps-repeating) Event Date
	if ( isset($entity->field_event_date[LANGUAGE_NONE]) ) {
		foreach ($entity->field_event_date[LANGUAGE_NONE] as $event_occurrence) {
			$utc_start_time = new DateObject(
			                        $event_occurrence['value'],
		    	                    'UTC' );
			$utc_start_time->setTimezone(new DateTimeZone($event_occurrence['timezone']));                        
			$utc_start_time_string = date_format_date(
			                        $utc_start_time,
		    	                    'custom',
		        	                'Y-m-d H:i:s O');
			$startstamp = strtotime( $utc_start_time_string );

			$utc_end_time = new DateObject(
			                        $event_occurrence['value2'],
		    	                    'UTC' );
			$utc_end_time->setTimezone(new DateTimeZone($event_occurrence['timezone']));                        
			$utc_end_time_string = date_format_date(
			                        $utc_end_time,
		    	                    'custom',
		        	                'Y-m-d H:i:s O');
			$endstamp = strtotime( $utc_end_time_string );

			if ($time_text == '') {
				$time_text = date_format_date(
						$utc_start_time,
						'custom',
						$time_format);

				if ($time_text != $midnight) {
					$time_text .= '-' . date_format_date(
					                        $utc_end_time,
					                        'custom',
					                        $time_format);
				}

				$time_text = str_replace('.00', '', $time_text);
			}

			if ($upperlimit == 0 && $endstamp > $current_time) {
				$upperlimit = $startstamp + ($next_week - $current_time);
			}

			if ($endstamp <= $current_time) {
				$previous++;
			}
			else if ($startstamp >= $upperlimit) {
				$subsequent++;
			}
			else {
				$start_date_text = date_format_date(
				                $utc_start_time,
				                'custom',
			    	            $date_future);

				$end_date_text = date_format_date(
				                $utc_end_time,
				                'custom',
				                $date_future);

				if ($start_date_text == $end_date_text) {
					$this_date_text = $start_date_text;
				}
				else {
					$this_date_text = $start_date_text . ' to ' . $end_date_text;
					$time_text = $midnight;
				}

				if ($date_text == '') {
					$date_text = $this_date_text;
				}
				else {
					$date_text .= ', ' . $this_date_text;
				}
			}
		}
	}

	if ($date_text == '') {
		$entity_field[0]['value'] = '';
	}
	else {
		if ($previous > 0) {
			$date_text = 'Next on ' . $date_text;
		}
		else if ($subsequent > 0) {
			$date_text = 'Starts on ' . $date_text;
		}
		if ($time_text == $midnight) {
			$entity_field[0]['value'] = $date_text;
		} else {
			$entity_field[0]['value'] = $date_text . ', ' . $time_text;
		}
	}
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Date Text.
 */
function computed_field_field_date_text_display($field, $entity_field_item) {
    return $entity_field_item['value'];
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Is Audio.
 */
function computed_field_field_is_audio_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
    if (count($entity->field_content[LANGUAGE_NONE]) > 0) {
    	$entity_field[0]['value'] = 1;
    }
    else {
    	$entity_field[0]['value'] = 0;
    }
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Is Audio.
 */
function computed_field_field_is_audio_display($field, $entity_field_item, $entity_lang, $langcode) {
    if ($entity_field_item['value'] != 0) {
    	return 'Yes';
    }
    else {
    	return 'No';
    }
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Is Video.
 */
function computed_field_field_is_video_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
    if (count($entity->field_video[LANGUAGE_NONE]) > 0) {
    	$entity_field[0]['value'] = 1;
    }
    else {
    	$entity_field[0]['value'] = 0;
    }
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Is Video.
 */
function computed_field_field_is_video_display($field, $entity_field_item, $entity_lang, $langcode) {
    if ($entity_field_item['value'] != 0) {
    	return 'Yes';
    }
    else {
    	return 'No';
    }
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Is Text.
*/
function computed_field_field_is_text_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  if (count($entity->field_attachment[LANGUAGE_NONE]) > 0) {
    $entity_field[0]['value'] = 1;
  }
  else {
    $entity_field[0]['value'] = 0;
  }
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Is Text.
*/
function computed_field_field_is_text_display($field, $entity_field_item, $entity_lang, $langcode) {
  if ($entity_field_item['value'] != 0) {
    return 'Yes';
  }
  else {
    return 'No';
  }
}

/*
 * This function is called by CCK Computed Field to compute the value of field Add to Calendar.
*/
function computed_field_field_add_to_calendar_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  if (isset($entity->field_date_text[LANGUAGE_NONE]) && empty($entity->field_date_text[LANGUAGE_NONE][0]['value'])) {
    $entity_field[0]['value'] = null; // The event has passed
    return;
  }
  elseif (isset($entity->field_civievent[LANGUAGE_NONE]) && !empty($entity->field_civievent[LANGUAGE_NONE][0])) {
    $entity_field[0]['value'] = null; // There is a CiviEvent
    return;
  }
  elseif (isset($entity->field_publish_calendar[LANGUAGE_NONE]) && empty($entity->field_publish_calendar[LANGUAGE_NONE][0]['value'])) {
    $entity_field[0]['value'] = null; // The 'Publish calendar' flag has not been ticked
    return;
  }
  $entity_type = $entity->type;
  $entity_nid = $entity->nid;
  if (isset($entity->field_in_activity[LANGUAGE_NONE]) && !empty($entity->field_in_activity[LANGUAGE_NONE][0])) {
    $entity_activity = $entity->field_in_activity[LANGUAGE_NONE][0]['target_id'];
    $activity = node_load($entity_activity);
    if (isset($activity->field_publish_calendar[LANGUAGE_NONE]) && empty($activity->field_publish_calendar[LANGUAGE_NONE][0]['value'])) {
      $entity_activity = 0; // The activity's 'Publish calendar' flag has not been ticked
    }
  }
  else {
    $entity_activity = 0;
  }
  if (isset($entity->field_event_date[LANGUAGE_NONE])) {
    $event_count = count($entity->field_event_date[LANGUAGE_NONE]); // a possibly-repeating event
  }
  else {
    $event_count = 2; // the other cases will have multiple events (at least 2)
  }
  if (isset($entity->taxonomy_vocabulary_1[LANGUAGE_NONE]) && !empty($entity->taxonomy_vocabulary_1[LANGUAGE_NONE][0])) {
    $term = taxonomy_term_load($entity->taxonomy_vocabulary_1[LANGUAGE_NONE][0]['tid']);
    $city = $term->name;
  }
  else {
    $city = '';
  }
  if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {
    $host = $_SERVER['HTTP_X_HOST'];
  }
  else {
    $host = $_SERVER['SERVER_NAME'];
  }
  $schemes = array();
  $results = array();
  $types = array();
  $nids = array();
  $title = '';
  $description = '';
  $startDate = '';
  $endDate = '';
  if ($entity_type == 'event') {
    if ($event_count == 1) {
      $schemes[] = 'single';
      $types['single'] = $entity_type;
      $nids['single'] = $entity_nid;
      $title = $entity->title;
      $description = truncate_utf8($entity->body[LANGUAGE_NONE][0]['value'], 600, TRUE, TRUE);
      $startDate = '';
      $endDate = '';
    }
    else {
      $schemes[] = 'multiple';
      $types['multiple'] = $entity_type;
      $nids['multiple'] = $entity_nid;
    }
    if (!empty($entity_activity)) {
      $schemes[] = 'subscribe';
      $types['subscribe'] = 'activity';
      $nids['subscribe'] = $entity_activity;
    }
  }
  elseif ($entity_type == 'activity') {
    $schemes[] = 'subscribe';
    $types['subscribe'] = $entity_type;
    $nids['subscribe'] = $entity_nid;
  }
  if (!empty($city)) {
    $schemes[] = 'city';
    $types['city'] = strtolower($city);
    $nids['city'] = 0;
  }
  $clients = array(
    'Apple' => array('single' => 'ics', 'multiple' => 'ics', 'subscribe' => 'webcal', 'city' => 'webcal'),
    'Outlook' => array('single' => 'ics', 'multiple' => 'ics', 'subscribe' => 'webcal', 'city' => 'webcal'),
    'Google Calendar' => array('single' => 'google', 'multiple' => '', 'subscribe' => 'google webcal', 'city' => 'google webcal'),
    'Other' => array('single' => 'ics', 'multiple' => 'ics', 'subscribe' => 'ics', 'city' => 'ics'),
  );
  foreach ($schemes as $scheme) {
    $results[$scheme] = '';
    foreach ($clients as $client => $methods) {
      if ($scheme == 'city') {
        $relative_url = "/ical/city/$types[$scheme]/calendar.ics";
      }
      else {
        $relative_url = "/ical/$types[$scheme]/$nids[$scheme]/calendar.ics";
      }
      switch ($methods[$scheme]) {
        case 'ics':
          $target = $relative_url;
          break;
        case 'webcal':
          $target = "webcal://$host$relative_url";
          break;
        case 'google':
          if (empty($title) || empty($startDate) || empty($endDate)) {
            $target = '';
          }
          else {
            $target = url(
              'http://www.google.com/calendar/event',
              array(
                'query' => array(
                  'action' => 'TEMPLATE',
                  'text' => $title,
                  'dates' => $startDate . '/' . $endDate,
                  'sprop' => 'website:' . $host,
//                  'location' => $info['location'],
                  'details' => $description,
                  'website' => url($info['url'], array('absolute' => TRUE)),
              )));
          }
          break;
        case 'google webcal':
          $target = url(
            'https://www.google.com/calendar/render',
            array(
              'query' => array('cid' => "webcal://$host$relative_url")));
          break;
        default:
          $target = '';
          break;
      }
      if (!empty($target)) {
        $results[$scheme] .= '<li><a href="' . $target . '" target="_blank">' . $client . '</a></li>';
      }
    }
  }
  if (count($results) == 0) {
    $entity_field[0]['value'] = null;
    return;
  }
  $schemeLabel = array(
    'single' => 'This event only',
    'multiple' => 'This event only',
    'subscribe' => 'This and future events like it',
    'city' => "This and future events for $city",
  );
  $result .= '
    <ul class="nav">
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#">Add to calendar</a>
        <ul class="dropdown-menu">';
  if (count($results) == 1) {
    foreach ($results as $scheme => $target) {
      $result .= $target;
    }
  }
  else {
    foreach ($results as $scheme => $target) {
      $result .= '
          <li class="dropdown dropdown-submenu">
            <a class="dropdown-toggle" data-toggle="dropdown" href="#">';
      $result .= $schemeLabel[$scheme];
      $result .= '</a>
            <ul class="dropdown-menu">';
      $result .= $target;
      $result .= '
            </ul>
          </li>';
    }
  }
  $result .= '
        </ul>
      </li>
    </ul>';
  $result .= (count($results) == 1) ? '' : '
    <script type="text/javascript">
      (function($){
        $(document).ready(function(){
          $(\'ul.dropdown-menu [data-toggle=dropdown]\').on(\'click\', function(event) {
            event.preventDefault();
            event.stopPropagation();
            $(this).parent().siblings().removeClass(\'open\');
            $(this).parent().toggleClass(\'open\');
          });
        });
      })(jQuery);
    </script>';
  $entity_field[0]['value'] = $result;
}

/*
 * This function is called by CCK Computed Field to generate the display text of field Add to Calendar.
*/
function computed_field_field_add_to_calendar_display($field, $entity_field_item, $entity_lang, $langcode) {
  if (empty($entity_field_item['value'])) {
    return '';
  }
  return $entity_field_item['value'];
}

function cbf_field_attach_presave($entity_type, $entity)
{
	if ($entity_type == 'node') {
		$html_fields = array('body','field_short_form');
		$attributes = array('summary','value');
		foreach ($html_fields as $html_field) {
			if (isset($entity->$html_field)) {
				$field = & $entity->$html_field;
				$languages = array_keys($field);
				foreach ($languages as $language) {
					$instances = count($field[$language]);
					for ($instance = 0; $instance < $instances; $instance++) {
						foreach ($attributes as $attribute) {
							if (isset($field[$language][$instance][$attribute])) {
								/*
								 *  Remove empty paragraphs inserted by CKeditor
								*/
								$field[$language][$instance][$attribute]
										= preg_replace(
												'!<p>(\r\n\t)*&nbsp;</p>!i',
												'',
												$field[$language][$instance][$attribute]);
							}
						}
					}
				}
			}
		}
	}
}

/*
 * This function is called by cron to update the Field Sort Order and Field Date Text:
 *   field_sort_order   - process all nodes that have a Field Sort Order with a value
 *                        between the last time the cron was called and 1 week from now. 
 *   field_episode_date - process all nodes that have a Field Episode Date with a value
 *                        between the last time the cron was called and now. 
 * The Date Text field changes as follows...
 *    - For events...
 *        - if the event is more than 1 week away, the text is weekday day month
 *        - // if the event is less than 1 week away, the text is weekday //
 *        - if the event is in the past, the text is empty
 *    - For episodes, news, blogs...
 *        - if
 * These nodes are simply opened and saved.
 * The cron time is updated.
 */
function cbf_cron() {
	$current_time = strtotime('now');
	$next_week    = strtotime('now +1 week');
	$last_run     = variable_get('cbf_cron_last_run', 0);

	if ($last_run == 0) {
		$query = new EntityFieldQuery();
		$result = $query->entityCondition('entity_type', 'node')
				->fieldCondition('field_next_action', 'value', array($last_run), '>')
				->execute();
		if (isset($result['node'])) {
			$nodes = entity_load('node', array_keys($result['node']));
			foreach ($nodes as $node) {
				node_save($node);
			}
		}
	}
	else {
		/* Clear the date text for past events */
		$query = new EntityFieldQuery();
		$result = $query->entityCondition('entity_type', 'node')
				->fieldCondition('field_next_action', 'value', array($last_run, $current_time), 'BETWEEN')
				->execute();
		if (isset($result['node'])) {
			$nodes = entity_load('node', array_keys($result['node']));
			foreach ($nodes as $node) {
				node_save($node);
			}
		}

		/* For events that are 1 week out, change the display
		$query = new EntityFieldQuery();
		$result = $query->entityCondition('entity_type', 'node')
				->fieldCondition('field_next_action', 'value', array($last_run + ($next_week - $current_time), $next_week), 'BETWEEN')
				->execute();
		if (isset($result['node'])) {
			$nodes = entity_load('node', array_keys($result['node']));
			foreach ($nodes as $node) {
				node_save($node);
			}
		} */

		/*
		 * Set the date text for past episodes. Note that the 'field_episode_date'
		 * field has 'value' attribute in the DATE_FORMAT_ISO format. The timezone
		 * is the system default.
		 */
		$last_run_formatted = format_date($last_run, 'custom', DATE_FORMAT_ISO);
		$current_time_formatted = format_date($current_time, 'custom', DATE_FORMAT_ISO);
		$query = new EntityFieldQuery();
		$result = $query->entityCondition('entity_type', 'node')
				->fieldCondition(
						'field_episode_date',
						'value',
						array(
								$last_run_formatted,
								$current_time_formatted),
						'BETWEEN')
				->execute();
		if (isset($result['node'])) {
			$nodes = entity_load('node', array_keys($result['node']));
			foreach ($nodes as $node) {
				node_save($node);
			}
		}
	}

	variable_set('cbf_cron_last_run', $current_time);
}

function cbf_mail_alter(&$message) {
	/*
	 * The Contact module sends emails using the To: address supplied
	 * by the visitor to a citybibleforum.org address. When this is
	 * redirected to a gmail.com address Gmail rightly complains
	 * (Unauthenticated email from yahoo.com is not accepted due to
	 * domain's 550-5.7.1 DMARC policy)
	 *
	 * Change the message headers so the email is sent From the Sender
	 * address (doulos@citybibleforum.org), but the original address
	 * is in the Reply-To header.
	 */
	$message['headers']['Reply-To'] = $message['headers']['From'];
	$message['headers']['From'] = $message['headers']['Sender'];
}
