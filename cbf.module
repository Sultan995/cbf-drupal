<?php

/*
 * This hook is called at the beginning of a Drupal page request.
 */
function cbf_init() {

  /*
   * The City Bible Forum sites use the current Domain's machine_name
   * for various purposes. Ensure that the Domain is loaded with it's
   * machine name. This hacks a bug where some Domain code assumes the
   * machine_name is stored globally.
   */
  domain_set_domain(domain_get_domain()['domain_id']);

  /*
   * Only staff can see 'civicrm/event/info' pages. For laffs.
   */
  if (user_is_anonymous()) {
    $q = $_GET['q'] ?? '';
    $id = $_GET['id'] ?? '';
    if ($q == 'civicrm/event/info' && is_numeric($id)) {
      drupal_not_found();
      drupal_exit();
    }
  }

  /*
   * The 2024 SPB is the last civicrm_event. A URL Redirect exists that points
   * to the corresponding brite_event. All other civicrm_events are not found.
   */
  if (arg(0) == 'civicrm-event' && (empty(arg(1)) || arg(1) != '3046')) {
    drupal_not_found();
    drupal_exit();
  }

  /*
   * Redirect people away from pages that cause SEO problems
   */
  if (user_is_anonymous()) {
    switch (arg(0)) {
      case 'category':
        drupal_goto('', [], 301);
        break;

      case 'taxonomy':
        switch (arg(1)) {
          case 'term':
            drupal_goto('', [], 301);
            break;
        }
        break;

      case 'blog':
      case 'blogs':
        drupal_goto('articles', [], 301);
        break;
    }
  }

  /*
   * Redirect people away from old forms
   */
  $isOldForm = false;
  switch (arg(0)) {

    case 'user':
      switch (arg(2)) {

        case 'contact':
          $isOldForm = true;
          break;
      }
      break;

    case 'contact':
    case 'contact-us':
      $isOldForm = true;
      break;

    case 'node':
      switch (arg(1)) {

        case '3755': // Contact Us
          $isOldForm = true;
          break;
      }
      break;
  }
  if ($isOldForm) {

    $currentDomainId = domain_get_domain()['domain_id'];
    $christianDomainId = domain_load_domain_id('christian');
    if ($currentDomainId == $christianDomainId) {

      drupal_goto('domain/christian/chat', [], 301);
    }
    else {

      drupal_goto('domain/general/chat', [], 301);
    }
  }

  if (arg(0) == 'node') {
    if (arg(1) == 'add') {
      /*
       * This JavaScript sets some defaults when adding new nodes.
       *  1. Tablefield fields default to plain text
       *  2. The File Field source is ICME to encourage reuse
       */
      $script = 'jQuery(document).ready(function(){
        jQuery(".field-type-tablefield .filter-wrapper select.filter-list option").each(function() {
          this.selected = (this.text == "Plain text");
        });
        jQuery(".filefield-source-imce").click();
      });';
      drupal_add_js($script, 'inline');
    }
    elseif (is_numeric(arg(1)) && arg(2) == 'edit') {
      /*
       * This JavaScript sets some defaults when editing nodes.
       *  1. The File Field source is ICME to encourage reuse
       */
      $script = 'jQuery(document).ready(function(){
        jQuery(".filefield-source-imce").click();
      });';
      drupal_add_js($script, 'inline');
    }
  }

  return [];
}

/*
 * Implements Drupal hook_form_alter().
 *
 * "Perform alterations before a form is rendered"
 */
function cbf_form_alter(&$form, &$form_state, $form_id) {
  $alterations = &drupal_static(__FUNCTION__, []);

  /*
   * Limit the views_exposed_form on the displays of the
   * cbf2019_activity_components view. It should only list locations where this
   * Activity is active, and there is either an Upcoming Event or a Staff member.
   */
  if (
      $form_id == 'views_exposed_form' &&
      !empty($form_state['view']) &&
      $form_state['view']->name == 'cbf2019_activity_components'
    ) {
    $node = menu_get_object();
    if (!empty($node) && $node->type == 'activity') {

      if (!isset($alterations['activity'])) {
        $alterations['activity'] = [];
      }

      if (!isset($alterations['activity']['cities'])) {

        $cities = [];

        // Find the Cities where there are upcoming Events
        // If the event has no City, then it is visible in all cities
        $current_time = strtotime('now');
        $query = new EntityFieldQuery();
        $result = $query
        ->entityCondition('entity_type', 'node')
        ->entityCondition('bundle', 'brite_event')
        ->fieldCondition('field_in_activity', 'target_id', (int) $node->nid, '=')
        ->fieldCondition('field_next_action', 'value', $current_time, '>')
        ->execute();
        foreach ($result as $entityType => $entityKeys) {
          $entities = entity_load($entityType, array_keys($entityKeys));
          foreach ($entities as $entityKey => $entity) {
            $city = null;
            $ministryCentres = field_get_items('node', $entity, 'taxonomy_vocabulary_1');
            if ($ministryCentres === false) $ministryCentres = [];
            foreach ($ministryCentres as $city) {
              $i = (int) $city['tid'];
              $cities[$i] = $i;
            }
            if ($city === null) {
              $cities['All'] = 'All';
            }
          }
        }

        // Find the Cities where there are staff
        // If the staff member has no City, then they are visible in all cities
        $query = new EntityFieldQuery();
        $result = $query
          ->entityCondition('entity_type', 'entityform')
          ->entityCondition('bundle', 'staff')
          ->fieldCondition('field_activities', 'target_id', (int) $node->nid, '=')
          ->execute();
        foreach ($result as $entityType => $entityKeys) {
          $entities = entity_load($entityType, array_keys($entityKeys));
          foreach ($entities as $entityKey => $entity) {
            $city = null;
            $ministryCentres = field_get_items('entityform', $entity, 'taxonomy_vocabulary_1');
            if ($ministryCentres === false) $ministryCentres = [];
            foreach ($ministryCentres as $city) {
              $i = (int) $city['tid'];
              $cities[$i] = $i;
            }
            if ($city === null) {
              $cities['All'] = 'All';
            }
          }
        }

        $alterations['activity']['cities'] = $cities;
      }

      /*
       * Find the valid options for this filter
       */
      if (!isset($alterations['activity']['field_highlight_location_tid'])) {
        /*
         * Find the possible options for this filter
         */
        $exposedLocations = [];
        $locations = cbf_field_get_items('node', $node, 'field_highlight_location', 'tid', []);
        foreach ($locations as $location) {
          $i = (int) $location;
          $exposedLocations[$i] = $i;
        }

        /*
         * The valid options for this filter are those where the corresponding
         * city has an entity as calculated above. The 'All' option is valid.
         * All options are valid if any of the upcoming events are not city-based.
         */
        $alterations['activity']['field_highlight_location_tid'] = [];
        foreach ($form['field_highlight_location_tid']['#options'] as $tid => $city) {
          if (is_numeric($tid)) {
            if (isset($exposedLocations[$tid])) {
              if (
                isset($alterations['activity']['cities']['All']) ||
                isset($alterations['activity']['cities'][_cbf_convert_banner_to_city_tid($tid)])
              ) {
                $alterations['activity']['field_highlight_location_tid'][$tid] = $city;
              }
            }
          }
          else {
            $alterations['activity']['field_highlight_location_tid'][$tid] = $city;
          }
        }
      }

      /*
       * There is no need to show the form if the only valid options are 'All'
       * or 'All' plus one city. Otherwise, only show the valid options.
       */
      if (
        (
          count($alterations['activity']['cities']) == 1 &&
          isset($alterations['activity']['cities']['All'])
        ) ||
        count($alterations['activity']['field_highlight_location_tid']) <= 2
      ) {

        $form['#access'] = false;
      }
      else {

        $form['field_highlight_location_tid']['#options']
          = $alterations['activity']['field_highlight_location_tid'];
      }
    }
  }

  /*
   * The domain_entityform on an -entityform-event-form is calculated when the
   * form is saved. Avoid the user having to enter a value that is immediately
   * overridden, by setting the #default_value to not be empty.
   */
  if (stripos($form['#id'], '-entityform-edit-form') !== false) {
    if (empty($form['domain_entityform']['und']['domain_id']['#default_value'])) {
      $form['domain_entityform']['und']['domain_id']['#default_value'] = array(1 => 1);
    }
  }

  /*
   * If the form has a field_event_date element then validate it
   */
  if (isset($form['field_event_date'])) {
    $form['#validate'][] = 'cbf_field_event_date_validate';
  }

  /*
   * If the form has a field_title_image element then validate it
   */
  if (isset($form['field_title_image'])) {
    $form['#validate'][] = 'cbf_field_title_image_validate';
  }

  /*
   * If the form has a field_highlight element then validate it
   */
  if (isset($form['field_highlight'])) {
    $form['#validate'][] = 'cbf_field_highlight_validate';
  }

  /*
   * If the form has a field_with element then validate it
   */
  if (isset($form['field_with'])) {
    $form['#validate'][] = 'cbf_field_with_validate';
  }

  /*
   * If we are editing a node, then check whether we need to enforce creating a
   * revision
   */
  if (isset($form['#node_edit_form'])) {
    $form['#validate'][] = 'cbf_form_revision_validate';
  }

  /*
   * If we're editing an entity that has both a field_speakers and a field_with
   * then make the field_speakers read-only
   */
  $entity = $form['#node'] ?? ($form['#entity'] ?? false);
  if ($entity) {
    $speakers = $entity->field_speakers ?? false;
    $with = $entity->field_with ?? false;
    $field = $form['field_speakers'] ?? false;
    if ($speakers && $with && $field) {
      if ($form['field_speakers']['und']['#attributes'] ?? false) {
        $form['field_speakers']['und']['#attributes']['disabled'] = true;
      }
      else {
        $form['field_speakers']['und']['#attributes'] = ['disabled' => true];
      }
    }
  }
}

/*
 * This hook is called to alter Drupal comment forms.
 *
 * This change prevents anonymous users accessing the 'homepage' field.
 * Spammers were using this field to get backlinks to their content on
 * this website.
 */
function cbf_form_comment_form_alter(&$form, &$form_state, $form_id) {
  if (user_is_anonymous()) {
    if (isset($form['author']['homepage']['#access'])) {
      $form['author']['homepage']['#access'] = false;
    }
  }
}

/*
 * Validate field_event_date elements on forms.
 *  - an event can't last longer than 5 days. This prevents staff misusing
 *    Events when they should be using a News Story.
 */
function cbf_field_event_date_validate($form, &$form_state) {
  if (isset($form_state['values']['field_event_date'])) {
    $duration = 0;
    foreach (reset($form_state['values']['field_event_date']) as $event_occurrence) {
      if (is_array($event_occurrence)) {
        $start_time = new DateObject($event_occurrence['value'], $event_occurrence['timezone']);
        $startstamp = strtotime($start_time->format('Y-m-d H:i:s O'));

        $end_time = new DateObject($event_occurrence['value2'], $event_occurrence['timezone']);
        $endstamp = strtotime($end_time->format('Y-m-d H:i:s O'));
        $duration += $endstamp - $startstamp;
      }
    }
    if ($duration > 5 * 24 * 60 * 60) {
      form_set_error(
        'field_event_date',
        'The overall duration of this event is greater than 5 days. ' .
        'This doesn\'t seem like an event.');
    }
  }
}

/*
 * Validate field_title_image elements on forms.
 *  - Title images are mandatory for non-Unlisted activities
 */
function cbf_field_title_image_validate($form, &$form_state) {
  if (isset($form_state['node'])
    && $form_state['node']->type == 'activity') {
          $unlisted = '1957';
          $fid = reset($form_state['values']['field_title_image']);
          $fid = is_array($fid) ? reset($fid)['fid'] ?? '0' : '0';
          $audience = reset($form_state['values']['taxonomy_vocabulary_3']);
          $audience = is_array($audience) ? reset($audience)['tid'] ?? '0' : '0';
          if ($audience != $unlisted && $fid == '0') {
            form_set_error(
              'field_highlight',
              'The Title image must be supplied unless the Activity is Unlisted.');
          }
        }
}

/*
 * Validate field_highlight elements on forms.
 *  - Highlight images are mandatory for non-Unlisted episodes & blogs
 *  - only apply this rule to modern articles
 * Highlight images are required for brite_events so no special processing is
 * required for those.  
 */
function cbf_field_highlight_validate($form, &$form_state) {
  if (
    (isset($form_state['node'])
      && ($form_state['node']->type == 'episode'
        || $form_state['node']->type == 'blog')
      && (!isset($form_state['node']->nid)
        || $form_state['node']->nid > 5898))
  ) {
    $unlisted = '1957';
    $fid = reset($form_state['values']['field_highlight']);
    $fid = is_array($fid) ? reset($fid)['fid'] ?? '0' : '0';
    $audience = reset($form_state['values']['taxonomy_vocabulary_3']);
    $audience = is_array($audience) ? reset($audience)['tid'] ?? '0' : '0';
    if ($audience != $unlisted && $fid == '0') {
      form_set_error(
        'field_highlight',
        'The Highlight image must be supplied unless the article is Unlisted.');
    }
  }
}

/*
 * Validate field_with elements on forms.
 *  - Check that the nominated Person has an existing Speaker record which
 *    has both a bio/description and an image
 *  - If this is a new person then require both a bio/description and an image
 *  - Warn if the bio/description of the existing Speaker record is longer than
 *    500 characters
 *  - Warn if the bio/description is longer than 500 characters
 */
function cbf_field_with_validate($form, &$form_state) {

  $people = reset($form_state['values']['field_with']);
  $maxDescription = 500;

  foreach ($people as $key => $person) {
    if (is_numeric($key)) { // Ignore people who are in the process of being added
      $tid = reset($person['field_speaker']);
      $name = is_array($tid) ? reset($tid)['name'] ?? '' : '';
      $tid = is_array($tid) ? reset($tid)['tid'] ?? 0 : 0;

      if (is_numeric($tid)) { // Existing speaker
        if ($tid > 0) {
          $speaker = taxonomy_term_load($tid);
          if (!$person['field_description']['und'][0]['value']) {
            if ($speaker->description) {
              if (strlen($speaker->description) > $maxDescription) {
                drupal_set_message(
                  "The existing Speaker record for '{$speaker->name}' has a description that is longer than $maxDescription characters (it will overflow the display area)",
                  'warning');
              }
            }
            else {
              form_set_error(
                "field_with][und][$key][field_description][und][0][value",
                "The existing Speaker record for '{$speaker->name}' doesn't have a description. Need to add one here or on the Speaker record.");
            }
          }
          if (!$person['field_highlight']['und'][0]['fid'] && !$speaker->field_highlight
              && !$person['field_image']['und'][0]['fid'] && !$speaker->field_image) {
            form_set_error(
              "field_with][und][$key][field_highlight][und][0][value",
              "The existing Speaker record for '{$speaker->name}' doesn't have an image. Need to add one here or on the Speaker record.");
          }
        }
      }
      else { // New speaker
        if (!$person['field_description']['und'][0]['value']) {
          form_set_error(
            "field_with][und][$key][field_description][und][0][value",
            "'$name' needs a description as there is no existing Speaker record");
        }
        if (!$person['field_highlight']['und'][0]['fid']
            && !$person['field_image']['und'][0]['fid']) {
          form_set_error(
            "field_with][und][$key][field_highlight][und][0][value",
            "'$name' needs an image as there is no existing Speaker record");
            }
      }

      $description = $person['field_description']['und'][0]['value'] ?? '';
      if (strlen($description) > $maxDescription) {
        drupal_set_message(
          "The description supplied for '$name' is longer than $maxDescription characters (it will overflow the display area)",
          'warning');
      }
    }
  }
}

/*
 * If we are editing a node, then check whether we need to enforce creating a
 * revision.
 *
 * Note that cbf_form_alter() attaches cbf_form_revision_validate() to the form
 * when $form['#node_edit_form'] is set.
 */
function cbf_form_revision_validate($form, &$form_state) {

  /*
   * The node lifecycle is assumed to be ...
   *
   *  - development - during the first month the node is rapidly developed, so
   *                  creating revisions is not needed
   *  - use         - during the next 5 months there are occasional changes,
   *                  and only certain changes require a revision
   *  - reuse       - thereafter changes require a revision so we can preserve
   *                  the original content
   */
  $developmentMilestone = strtotime('1 month ago');
  $reuseMilestone = strtotime('1 year ago');

  /*
   * When was the node created?
   */
  if (isset($form_state['node']->nid)) {
    $created = $form_state['node']->created;
  }
  else {
    $created = time();
  }

  /*
   * Are there any reasons to enforce a revision?
   */
  $reason = [];

  $revision = $form_state['input']['revision'] ?? false;
  $log = $form_state['input']['log'] ?? '';

  global $user;

  if ($user->uid == 1) {
    // The super-user doesn't need to make revisions
  }
  else if ($revision && $log) {
    // There is already a valid revision
  }
  else if ($created < $reuseMilestone) {
    $reason[] = 'This node is more than 1 year old so the original content should be preserved';
  }
  else if ($created < $developmentMilestone) {
    /*
     * After development there are some cases when a revision is required
     */
    if ($form_state['node']->type == 'activity') {
      $reason[] = 'This node is an Activity';
    }

    foreach ($form_state['input'] as $input) {
      if (is_array($input)) {
        $input = reset($input);
        if (is_array($input)) {
          $input = reset($input);
          $input = $input['format'] ?? '';
          if (strpos($input, 'shortcodes') !== false) {
            $reason[] = 'This node uses Dynamic Shortcodes';
            break;
          }
        }
      }
    }
  }

  $warning = false;
  if (!empty($reason)) {
    if ($warning) {
      drupal_set_message(
        'Soon you will be required to create a revision since: '
          . implode(', ', $reason)
          . '. The revision will be required to have a log message.',
        'warning');
    }
    else {
      form_set_error('revision', 'Need to create a revision: ' . implode(', ', $reason));
      form_set_error('log', 'Need a revision log message: see the <em>Revision information</em> tab just above the <em>Save</em> button at the bottom of the screen');
    }
  }
}

/*
 * Implement the rules that assign entities to domains.
 *
 * Rules are stored in the domain information ...
 *
 *     machine_name = christian
 *     alias = christian.audience.rule |
 *             all.audience.rule
 *
 *         Always matches.
 *
 *     machine_name = general
 *     alias = general.audience.rule
 *
 *         Matches content for a General audience.
 *
 * The rules have the following effects on nodes...
 *
 *     domain_site   false (content is not available in all affiliates)
 *     domains       contains an entry for each domain that matches a rule
 *     domain_source DOMAIN_SOURCE_USE_ACTIVE (don't change domain to a cardinal
 *                   domain) EXCEPT when the node appears in only one domain
 */
function cbf_entity_presave($entity, $type) {
  switch ($type) {
    case 'node':
      $url0 = 'node';
      $allDomainBundles = [
        'contact_webform' => true,
        'webform' => true,
        'office' => true,
      ];
      $skipDomainBundles = [ ];
      $allDomainIds = [
        61 => 'Privacy policy',
      ];
      $entityId = $entity->nid;
      $entityBundle = $entity->type;
      break;
    case 'entityform':
      $url0 = 'entityform';
      $allDomainBundles = [
        'staff' => true,
        'home_page_slider' => true,
      ];
      $skipDomainBundles = [
        'title_header' => true,
      ];
      $allDomainIds = [ ];
      $entityId = $entity->entityform_id;
      $entityBundle = $entity->type;
      break;
    default:
      return;
  }

  /*
   * If saving an entity after editing it, clear the views data cache so the
   * staff member editing the node can see the refreshed version of the views
   * blocks on the page.
   */
  if (arg(0) == $url0 && arg(2) == 'edit') {
    cache_clear_all('*', 'cache_views_data', true);
  }

  $followDomainRules = empty($skipDomainBundles[$entityBundle]);

  if ($followDomainRules) {
    $domains = domain_list_by_machine_name();

    $matches = [];

    $audienceTerm = cbf_field_get_items($type, $entity, 'taxonomy_vocabulary_3', 'tid', '');
    switch ($audienceTerm) {
      case '47':
        $entityAudience = 'christian';
        break;
      case '48':
        $entityAudience = 'general';
        break;
      case '1957':
        $entityAudience = 'unlisted';
        break;
      default:
        $entityAudience = '';
        break;
    }

    foreach ($domains as $domain) {
      $match = false;
      if (isset($allDomainBundles[$entityBundle])) {
        $match = true;
      }
      else if (isset($allDomainIds[$entityId])) {
        $match = true;
      }
      else {
        $ruleAudience = $domain['machine_name'];
        if (
          $ruleAudience == 'christian' ||
          $ruleAudience == 'general' && (
            $entityAudience == 'general' ||
            $entityAudience == 'unlisted'
          )
        ) {
          $match = true;
        }
      }

      if ($match) {
        $matches[$domain['machine_name']] = [ 'domain_id' => $domain['domain_id'] ];
      }
    }

    switch ($type) {
      case 'node':
        $entity->domain_site = false;
        $entity->domains = [ ];
        foreach ($matches as $domain) {
          $entity->domains[$domain['domain_id']] = $domain['domain_id'];
        }
        if (count($entity->domains) == 1) {
          $entity->domain_source = reset($entity->domains);
        }
        else if ($entityAudience == 'unlisted') {
          $entity->domain_source = DOMAIN_SOURCE_USE_ACTIVE;
        }
        else {
          $sources = [ ];
          foreach ($matches as $name => $domainId) {
            switch ($name) {
              case 'general':
              case 'christian':
                $sources[$name] = $domainId['domain_id'];
                break;
              default:
                $sources['other'] = DOMAIN_SOURCE_USE_ACTIVE;
                break;
            }
          }
          /*
           * The domain source is DOMAIN_SOURCE_USE_ACTIVE for Bigger
           * Questions etc, the 'general' domain for content visible on
           * the general and christian domains, the 'christian' domain
           * for content visible on the Christian domain, and
           * DOMAIN_SOURCE_USE_ACTIVE as a final fallback.
           */
          $entity->domain_source = $sources['other']
            ?? $sources['general']
            ?? $sources['christian']
            ?? DOMAIN_SOURCE_USE_ACTIVE;
        }
        break;

      case 'entityform':
        $lang = field_language($type, $entity, 'domain_entityform');
        $entity->domain_entityform[$lang] = [ ];
        foreach ($matches as $value) {
          $entity->domain_entityform[$lang][] = $value;
        }
        break;
    }
  }

  /*
   * When saving an entity with field_with items, update field_speakers to
   * match. Update the description and images in the $speaker term if not
   * yet set.
   */
  if ($entity->field_with['und'] ?? false) {

    $personnel = cbf_field_get_items($type, $entity, 'field_with', 'value', []);
    $personnel = entity_load('paragraphs_item', $personnel);

    $first = true;
    foreach ($personnel as $person) {
      $tid = cbf_field_get_items('paragraphs_item', $person, 'field_speaker', 'tid');

      // Update the field_speakers
      if (isset($entity->field_speakers)) {
        if ($first) {
          $entity->field_speakers = ['und' => []];
        }
        $entity->field_speakers['und'][] = ['tid' => $tid,];
      }

      // Update the $speaker term if needed
      $speaker = taxonomy_term_load($tid);
      $changed = false;
      $description = cbf_field_get_items('paragraphs_item', $person, 'field_description', 'value');
      if ($description && !$speaker->description) {
        $speaker->description = $description;
        $changed = true;
      }
      if ($person->field_highlight && !$speaker->field_highlight) {
        $speaker->field_highlight = $person->field_highlight;
        $changed = true;
      }
      if ($person->field_image && !$speaker->field_image) {
        $speaker->field_image = $person->field_image;
        $changed = true;
      }
      if ($changed) {
        taxonomy_term_save($speaker);
      }

      $first = false;
    }
  }
}

/*
 * CKEditor introduces some unpleasant artifacts into HTML text fields. This
 * function handles them ...
 *
 *   - Empty paragraphs are removed
 *   - Non-breaking spaces are replaced with plain spaces
 *   - Ensure target="_blank" attributes have a rel="noopener noreferrer"
 *     attribute https://medium.com/@jitbit/target-blank-the-most-underestimated-vulnerability-ever-96e328301f4c#.dzwczm21q
 *
 * The order of these actions is important as the patterns have overlapping content.
 */
function cbf_field_attach_presave($entity_type, $entity) {
  if ($entity_type == 'node') {
    $html_fields = array('body', 'field_short_form', 'field_sidebar_content');
    $attributes = array('summary','value');
    $replacements = array(
      '!<p>(\r\n\t)*&nbsp;</p>!i' => '',
      '!&nbsp;!i'                 => ' ',
      '!target="_blank" rel="noopener noreferrer"!i'           => 'target="_blank"',
      '!target="_blank"!i'                                     => 'rel="noopener noreferrer" target="_blank"',
      '!rel="noopener noreferrer" rel="noopener noreferrer"!i' => 'rel="noopener noreferrer"',
    );
    $from = array_keys($replacements);
    $to = array_values($replacements);
    foreach ($html_fields as $html_field) {
      if (isset($entity->$html_field)) {
        $field = & $entity->$html_field;
        $languages = array_keys($field);
        foreach ($languages as $language) {
          $instances = count($field[$language]);
          for ($instance = 0; $instance < $instances; $instance++) {
            foreach ($attributes as $attribute) {
              if (isset($field[$language][$instance][$attribute])) {
                $field[$language][$instance][$attribute]
                  = preg_replace($from, $to, $field[$language][$instance][$attribute]);
              }
            }
          }
        }
      }
    }
  }
}

/*
 * This function is called by Drupal cron.
 *
 * Re-save entities that have a field_next_action which is set to a time between
 * the previous invocation of cron and this one. This enacts time-sensitive
 * calculations of computed field values.
 *
 * Prevent nodes that were posted to Twitter from being automatically re-posted if
 * they are edited.
 *
 * The time that cron was run is updated for next time.
 */
function cbf_cron() {
  $current_time = strtotime('now');

  /*
   * Run this cron function as the super-user to avoid access restrictions
   * with Domain Entity.
   *
   * Following the pattern in https://www.drupal.org/node/1793862
   */
  global $user;

  try {
    // Switch to the super-user
    $originalUser = $user;
    $originalState = drupal_save_session(false);
    $user = user_load(1);

    /*
     * Find entities with field_next_action due. Order them so the most recent
     * are processed first, so entities that get stuck don't mask later ones.
     */
    $query = new EntityFieldQuery();
    $result = $query
      ->fieldCondition('field_next_action', 'value', [1, $current_time], 'BETWEEN')
      ->fieldOrderBy('field_next_action', 'value', 'DESC')
      ->range(0, 50)
      ->execute();
    foreach ($result as $entityType => $entityKeys) {
      $entities = entity_load($entityType, array_keys($entityKeys));
      foreach ($entities as $entityKey => $entity) {
        switch ($entityType) {
          case 'node':
            node_save($entity);
            break;
        }
        unset($entityKeys[$entityKey]);
      }
      if (!empty($entityKeys)) {
        watchdog(
          'CBF',
          "Couldn't process $entityType entities with a field_next_action set: ". implode(', ',array_keys($entityKeys)),
          null,
          WATCHDOG_ERROR
        );
      }
    }

  } catch (Exception $e) {
    // Do nothing
  }

  // Switch back to the original user
  $user = $originalUser;
  drupal_save_session($originalState);

  variable_set('cbf_cron_last_run', $current_time);
}

/*
 * When a comment is made in reply to a comment, and email is sent
 * to the author of the original comment. If there is no original
 * comment, the comment is being made directly on the article, but
 * Drupal still attempts to send an email. The "To" header will in
 * this case be an unresolved token and will fail to be delivered.
 * Don't send emails in this case.
 *
 * The Contact module sends emails using the To: address supplied
 * by the visitor to a citybibleforum.org address. When this is
 * redirected to a gmail.com address Gmail rightly complains
 * (Unauthenticated email from yahoo.com is not accepted due to
 * domain's 550-5.7.1 DMARC policy)
 *
 * Change the message headers so the email is sent From the Sender
 * address (doulos@citybibleforum.org), but the original address
 * is in the Reply-To header.
 */
function cbf_mail_alter(&$message) {
  if (strpos($message['to'], '[') !== false) {
    $message['send'] = false;
  }
  else {
    $message['headers']['Reply-To'] = $message['headers']['From'];
    $message['headers']['From'] = $message['headers']['Sender'];
  }
}

/*
 * The visitor city name is initially unknown, but only needs to be calculated
 * once per request
 */
function cbf_visitor_city_string() {
  static $cbf_visitor_city = null;

  if (!isset($cbf_visitor_city)) {
    $cbf_visitor_city = false;

    foreach (['ip_geoloc', 'geoip'] as $locator) {
      $country = null;
      $state = null;

      switch ($locator) {
        case 'ip_geoloc':
          if (function_exists('ip_geoloc_get_visitor_location')) {
            $result = ip_geoloc_get_visitor_location();
            $country = $result['country'] ?? '';
            $state = $result['administrative_area_level_1'] ?? '';
          }
          break;

        case 'geoip':
          if (function_exists('geoip_country_name')) {
            $country = geoip_country_name();
            $state = geoip_region_name();
          }
          break;
      }

      switch ($country) {
        case 'Australia':
          switch ($state) {
            case 'New South Wales':
              $cbf_visitor_city = 'sydney';
              break;
            case 'Victoria':
              $cbf_visitor_city = 'melbourne';
              break;
            case 'Queensland':
              $cbf_visitor_city = 'brisbane';
              break;
            case 'South Australia':
              $cbf_visitor_city = 'adelaide';
              break;
            case 'Western Australia':
              $cbf_visitor_city = 'perth';
              break;
            case 'Australian Capital Territory':
              $cbf_visitor_city = 'canberra';
              break;
            case 'Tasmania':
              $cbf_visitor_city = 'hobart';
              break;
          }
          break;
      }

      if (!empty($cbf_visitor_city)) {
        break;
      }
    }
  }

  return $cbf_visitor_city;
}

/*
 * Populate the metatags for an entity's Twitter Card and Facebook Open Graph.
 *
 * The Twitter Card preferences are ...
 *
 * #  Twitter card type              Source image     Condition
 * -  -----------------------------  ---------------  ------------------------
 * 1  Summary card with large image  Highlight        Image >= 280px x 150px
 *                                   Series image
 *                                   Image
 * 2  No longer available
 * 3  Summary card                   Logo             No matching image fields
 *
 * The Facebook Open Graph preferences are ...
 *
 * #  Source image  Condition
 * -  ------------  ------------------------
 * 4  Highlight     Image >= 600px x 316px
 *    Series Image
 *    Image
 * 5  Highlight     Image >= 280px wide
 *    Series Image
 *    Image
 * 6  Logo          No matching image fields
 */
function cbf_metatag_pattern_alter(&$pattern, &$types, $tag_name) {
  $entity = null;
  $entityTypes = ['node'];

  foreach ($entityTypes as $entityType) {
    if (isset($types[$entityType])) {
      $entity = $types[$entityType];
      break;
    }
  }

  if (isset($entity)) {
    $largeImages = array('field_highlight', 'field_image', 'field_series_image');
    switch ($tag_name) {
      case 'twitter:card':
      case 'twitter:image':
        /* Option 3 is the default */
        $card = 'summary';
        $src = '';
        /* Try Option 1 */
        foreach ($largeImages as $largeImage) {
          $image = field_get_items($entityType, $entity, $largeImage);
          if ($image !== false && !empty($image)) {
            if (isset($image[0]['width']) && $image[0]['width'] >= 280 &&
                isset($image[0]['height']) && $image[0]['height'] >= 150) {
              $card = 'summary_large_image';
              $src = "[$entityType:$largeImage]";
              break;
            }
          }
        }
        /* Option 2 is no longer available*/
        /* Update the tag pattern if changed from the default */
        if ($src != '') {
          switch ($tag_name) {
            case 'twitter:card':
              $pattern = $card;
              break;
            case 'twitter:image':
              $pattern = $src;
              break;
          }
        }
        break;

      case 'og:image':
        /* Option 6 is the default */
        $src = '';
        /* Try Option 4 */
        foreach ($largeImages as $largeImage) {
          $image = field_get_items($entityType, $entity, $largeImage);
          if ($image !== false && !empty($image)) {
            if (isset($image[0]['width']) && $image[0]['width'] >= 600 &&
                isset($image[0]['height']) && $image[0]['height'] >= 316) {
              $src = "[$entityType:$largeImage]";
              break;
            }
          }
        }
        /* Try Option 5 */
        if ($src == '') {
          foreach ($largeImages as $largeImage) {
            $image = field_get_items($entityType, $entity, $largeImage);
            if ($image !== false && !empty($image)) {
              if (isset($image[0]['width']) && $image[0]['width'] >= 280) {
                $src = "[$entityType:$largeImage]";
                break;
              }
            }
          }
        }
        if ($src != '') {
          $pattern = $src;
        }
        break;
    }
  }
}

/**
 * Alter metatags before being cached.
 *
 * This hook is invoked prior to the meta tags for a given page are cached.
 *
 * For SEO purposes, content that appears on both the 'general' and the
 * 'christian' site should have a canonical URL pointing to the 'general' site.
 *
 * So, if this is a Node whose Audience is not 'christian', and we are on the
 * 'christian' site, modify the canonical URL to point to the 'general' site.
 *
 * For SEO, give /library/topic the same Canonical URL as /library
 *
 * @param array $output
 *   All of the meta tags to be output for this page in their raw format. This
 *   is a heavily nested array.
 * @param string $instance
 *   An identifier for the current page's page type, typically a combination
 *   of the entity name and bundle name, e.g. "node:story".
 * @param array $options
 *   All of the options used to generate the meta tags.
 */
function cbf_metatag_metatags_view_alter(&$output, $instance, $options) {
  if (stripos($instance, 'node:') === 0) {
    $audience = cbf_field_get_items($options['entity_type'], $options['entity'], 'taxonomy_vocabulary_3', 'tid', '');
    if (!empty($audience) && $audience != '47') {
      // There is an audience and it is not 'christian'
      $currentDomainId = domain_get_domain()['domain_id'];
      $christianDomainId = domain_load_domain_id('christian');
      if ($currentDomainId == $christianDomainId) {
        // We are on the 'christian' site
        $canonical = $output['canonical']['#attached']['drupal_add_html_head'][0][0]['#value'] ?? '';
        if ($canonical) {
          $host = domain_list_by_machine_name()['general']['subdomain'] ?? '';
          if ($host) {
            $canonical = preg_replace('#//[a-z0-9]+(\.[a-z]+)+#i', '//' . $host, $canonical);
            $output['canonical']['#attached']['drupal_add_html_head'][0][0]['#value'] = $canonical;
          }
        }
      }
    }
  }
  else if ($instance == 'view:cbf2019_recent_library:page_2') {
    $canonical = $output['canonical']['#attached']['drupal_add_html_head'][0][0]['#value'] ?? '';
    if ($canonical) {
      $canonical = preg_replace('!library/topic.*$!i', 'library', $canonical);
      $output['canonical']['#attached']['drupal_add_html_head'][0][0]['#value'] = $canonical;
    }
  }
}

/*
 * A function to parse the exposed filters on the National Library view,
 * to extract the topics, and return a string containing them.
 *
 * This function is invoked by the contextual filter 'Header topics string'
 * in the page display 'Library' in the view 'National Library'.
 */
function cbf_library_view_topics_string(&$view) {
  if (!isset($view->exposed_input['field_topic_tid'])) {
    return ' ';
  }

  $result = array();

  foreach ($view->exposed_input['field_topic_tid'] as $tid) {
    $queryResult = db_query(
      'select name from {taxonomy_term_data} where tid = :tid',
      array(':tid' => $tid));
    foreach ($queryResult as $row) {
      $result[] = $row->name;
    }
  }

  return implode(' | ', $result);
}

function cbf_views_api() {
  return [ 'api' => 3 ];
}


/*
 * Implementation of hook_views_pre_render
 *   - Counts the number of rows and adds classes to the view as appropriate
 *       - views-1-row
 *       - views-2-rows
 *       - views-3-rows
 *       - views-n-rows
 */
function cbf_views_pre_render(&$view) {

  $class = $view->display_handler->get_option('css_class');
  switch (count($view->result)) {
    case 0:
      $c = '';
      break;

    case 1:
      $c = 'views-1-row';
      break;

    case 2:
    case 3:
      $c = 'views-' . count($view->result) . '-rows';
      break;

    default:
      $c = 'views-n-rows';
      break;
  }
  $view->display_handler->set_option('css_class', trim($class . ' ' . $c));
}

/*
 * Implements hook_views_post_execute.
 *
 * https://api.drupal.org/api/views/views.api.php/function/hook_views_post_execute/7.x-3.x
 *
 *  "This hook is called right after the execute process. The query has been executed,
 *   but the pre_render() phase has not yet happened for handlers.
 *
 *  "Adding output to the view can be accomplished by placing text on $view->attachment_before
 *   and $view->attachment_after. Altering the content can be achieved by editing the items of
 *   $view->result"
 */
function cbf_views_post_execute(&$view) {

  /*
   * If the results of this view need to be filtered by Ministry Centre in this
   * function, then find the Term Id from the exposed filter condition, and if
   * set, then only keep $view->result items with either an empty or a matching
   * Term Id.
   *
   * This is required because it's too tricky to do it using the $view's filter
   * criteria.
   */
  if (in_array('filter-ministry-centre-post-execute', explode(', ', $view->tag))) {
    $tid = null;
    foreach ($view->query->where as $i => $clause) {
      foreach ($clause['conditions'] as $j => $condition) {
        if (
          stripos($condition['field'], 'taxonomy_vocabulary_1_tid') !== false
          && $condition['operator'] == '='
        ) {
          $tid = $condition['value'];
        }
      }
    }
    if ($tid) {
      $alteredResults = [];
      foreach ($view->result as $result) {
        if (
          empty($result->taxonomy_term_data_field_data_taxonomy_vocabulary_1_tid)
          || $result->taxonomy_term_data_field_data_taxonomy_vocabulary_1_tid[0]['rendered']['#markup'] == $tid
        ) {
          $alteredResults[] = $result;
        }
      }
      if (count($alteredResults) != count($view->result)) {
        $view->result = $alteredResults;
      }
    }
  }

  /*
   * If a view returns no results, and the 'no results' behaviour is to return
   * the results of a second view, we want the title of this view to equal that
   * of the second.
   */
  if (
     empty($view->result) &&
    !empty($view->empty['view']->options['view_to_insert'])
  ) {
    list($view_name, $display_id) = explode(':', $view->empty['view']->options['view_to_insert']);
    $noResults = views_get_view($view_name);
    if (
      !empty($noResults) &&
      $noResults->access($display_id)
    ) {
      $noResults->set_display($display_id);
      $title = $noResults->get_title();
      $view->set_title($title);
    }
  }

  /*
   * Titles for the Bigger Questions iTunes feed need to include the Speaker
   * names.
   */
  if (
    $view->name == 'campus_podcasts'
    && $view->current_display == 'feed_3'
  ) {
    foreach ($view->result as $r => $result) {
      if (
        strpos($result->node_title, '|') === false
        && $result->nid > 3655
      ) {
        $count = count($result->field_field_speakers);
        $speakers = '';
        foreach ($result->field_field_speakers as $i => $speaker) {
          if ($i == 0) {
            $speakers .= ' | ';
          }
          else if ($i == $count - 1) {
            $speakers .= ' & ';
          }
          else {
            $speakers .= ', ';
          }
          $speakers .= $speaker['rendered']['#markup'];
        }
        $view->result[$r]->node_title .= $speakers;
      }
    }
  }

  /*
   * If the view is 'cbf2019_local_offices' and the current Domain the General
   * content site then use the corresponding Third Space address.
   */
  if ($view->name == 'cbf2019_local_offices') {
    $currentDomainId = domain_get_domain()['domain_id'];
    $generalDomainId = domain_load_domain_id('general');
    $christianDomainId = domain_load_domain_id('christian');
    switch ($currentDomainId) {
      case $generalDomainId:
        $contactEmailPattern = '/@.*$/';
        $contactEmailReplacement = '@thirdspace.org.au';
        break;
      case $christianDomainId:
        $contactEmailPattern = '/@.*$/';
        $contactEmailReplacement = '@citybibleforum.org';
        break;
      default:
        $contactEmailPattern = false;
        break;
    }
    if ($contactEmailPattern) {
      foreach ($view->result as $i => $_) {

        $e = $view->result[$i]->field_field_subtitle[0]['rendered']['#markup'];
         $f = preg_replace($contactEmailPattern, $contactEmailReplacement, $e) ?? $e;
         $view->result[$i]->field_field_subtitle[0]['rendered']['#markup'] = $f;
      }
    }
  }

  /*
   * If the view gets its Ministry Centre contextual filter from the enclosing
   * view then filter out any results that don't match the Ministry Centre
   * argument (arg[1]). A match means the result's Ministry Centre is either
   * NULL or equals the view's argument.
   *
   * By convention the Ministry Centre is args[1].
   */
  if (
    (
      $view->name == 'cbf2019_activity_brite_event_slider' ||
      (
        $view->name == 'cbf2019_staff_slider' &&
        $view->current_display == 'block_2')
    ) &&
    count($view->args) > 1 &&
    is_numeric($view->args[1])
  ) {
    foreach ($view->result as $i => $result) {
      $include = $exclude = false;
      foreach ($result->field_taxonomy_vocabulary_1 as $ministryCentre) {
        if ($ministryCentre['raw']['tid'] == $view->args[1]) {
          $include = true;
        }
        else {
          $exclude = true;
        }
      }
      if (!$include && $exclude) {
        unset($view->result[$i]);
      }
    }
  }

  if ($view->name == 'cbf2019_rated_content' && $view->current_display == 'page_5') {
    /*
     * The Header and No Results text are modified to contain the text from the
     * query parameters.
     */
    $topics = _cbf_convert_article_topics_url_query();
    $view->header['area']->options['content'] =
      "<span id=\"cbf2019-rated-content-view-header\">{$topics['title']}</span>";
    $view->empty['area']->options['content'] =
      "There are no resources matching <em>{$topics['title']}</em>";
    if (!empty($topics['tids']) && !empty($topics['search'])) {
      $view->empty['area']->options['content'] .=
        ". Try searching for <a href=\"/resources/topic?search={$topics['search']}\">'{$topics['search']}'</a> across all resources.";
    }
  }

  if ($view->name == 'cbf2019_rated_content' && $view->current_display == 'page_3') {
    /*
     * The 'nothing' field is a Global Text field that holds the text contents
     * of the view header.
     *
     * Overwrite it's value from the query parameters if these are supplied.
     */
    $query = drupal_get_query_parameters();
    $search = $query['search'] ?? '';
    $search = check_plain($search);

    if (!empty($search)) {
      $view->header['area']->options['content'] =
        preg_replace('/%1/', "'$search' + %1", $view->header['area']->options['content']);
      $view->empty['area']->options['content'] =
        preg_replace('/%1/', "%1 matching '$search'", $view->empty['area']->options['content']);
      $view->empty['area']->options['content'] .=
        ". Try searching for <a href=\"/resources/topic?search=$search\">'$search'</a> across all resources.";
    }
  }
}

/*
 * An implementation of hook_contextual_links_view_alter
 *
 * Alter a contextual links element before it is rendered.
 *
 * This hook is invoked by contextual_pre_render_links(). The renderable array
 * of #type 'contextual_links', containing the entire contextual links data
 * that is passed in by reference. Further links may be added or existing
 * links can be altered.
 */
function cbf_contextual_links_view_alter(&$element, $items) {
  /*
   * With nodes it doesn't make sense for the destination of the contextual
   * link to be the same node. Eg, 'delete' and 'clone content'. Remove the
   * destination by removing the query from the link URL.
   */
  if (isset($element['#element']['#node'])) {
    foreach (array('node-delete', 'node-clone-') as $i) {
      if (!empty($element['#links'][$i]['query'])) {
        $element['#links'][$i]['query'] = array();
      }
    }
  }
}

/*
 * An implementation of theme_entity_property()
 *
 * Some properties include HTML and the default behaviour is that the entities
 * are encoded. In these cases, decode them.
 */
function cbf_entity_property($variables) {

  $variables['label_hidden'] = true;

  return theme_entity_property($variables);
}

/*
 * This hook defines administrative paths.
 */
function cbf_admin_paths() {
  $paths = [
    /*
     * When 'entityform/NNNN/edit' is not an admin path, calls to
     * entity_load() will fail to return entities that are not visible
     * in this domain.
     */
    'entityform/*/edit' => true,
  ];
  return $paths;
}

function cbf_convert_banner_to_city_tid() {
  $query_parameters = drupal_get_query_parameters();
  if (empty($query_parameters['field_highlight_location_tid'])) {
    if (empty($query_parameters['field_networks_visibility_tid'])) {
      return null;
    }
    else {
      return _cbf_convert_banner_to_city_tid($query_parameters['field_networks_visibility_tid']);
    }
  }
  else {
    return _cbf_convert_banner_to_city_tid($query_parameters['field_highlight_location_tid']);
  }
}

function _cbf_convert_banner_to_city_tid($banner) {
  switch ($banner) {
    case 1041; // Adelaide
      return 5;
    case 1042; // Brisbane
      return 3;
    case 1073; // Canberra
      return 1068;
    case 1191; // Hobart
      return 1126;
    case 1043; // Melbourne
      return 2;
    case 1044; // Perth
      return 4;
    case 1045; // Sydney
      return 1;
    default:   // eg 'All' or an unrecognised value
      return null;
  }
}

/*
 * Common code for use when converting Article Topics supplied as a URL query
 * parameter, such as "topic=my-topic" or "topic=this-topic+that-topic" or
 * "focus=top-level-topic" or "search=words"
 */
function _cbf_convert_article_topics_url_query() {

  $result = &drupal_static(__FUNCTION__);
  if ($result) {
    return $result;
  }

  $topics = [];
  $titles = [];
  $focus = '';
  $search = '';

  /*
   * The topics are presented in the 'topic' query parameter, separated by
   * either commas or plus characters.
   *
   * The 'focus' query parameter is the URL-friendly name of a top-level
   * Article Topic (ie, alphanumeric plus hyphens).
   *
   * The 'search' query parameter is the search string entered by the user
   */
  $query = drupal_get_query_parameters();
  $queryTopic = $query['topic'] ?? '';
  $queryFocus = $query['focus'] ?? '';
  $search = $query['search'] ?? '';
  $search = check_plain($search);

  /*
   * Only load the Article Topic vocabulary if a query argument is present
   */
  if (!empty($queryTopic) || !empty($queryFocus)) {

    /*
     * Any '+' characters in $queryTopic will have already been converted to a
     * space, so do the same for commas. Ensure $queryTopic is lowercase.
     */
    $queryTopic = str_replace(',', ' ', $queryTopic);
    $queryTopic = strtolower($queryTopic);

    /*
     * Ensure $queryFocus is lowercase
     */
    $queryFocus = strtolower($queryFocus);

    /*
     * Find the $topics in $queryTopic among the Article Topics
     * Ditto for $focus in $queryFocus
     * Try to match the topics on name, and then on field_title
     * As we're doing that, build up a list of $children of topics
     */
    $vocabulary = taxonomy_vocabulary_machine_name_load('article_topic');
    $taxonomy = taxonomy_get_tree($vocabulary->vid, 0, null, true);
    $children = [];
    foreach ($taxonomy as $topic) {
      $names = [
        $topic->name,
        cbf_field_get_items('taxonomy_term', $topic, 'field_title', 'value')
      ];
      foreach ($names as $name) {
        if ($name) {
          $name = str_replace(' ', '-', $name);
          $name = strtolower($name);
          if (
               !empty($queryTopic)
            && strpos(' ' . $queryTopic . ' ', ' ' . $name . ' ') !== false
            && !isset($topics[$topic->tid])
          ) {
            $topics[$topic->tid] = $topic->tid;
            $titles[] = $topic->name;
          }
          if ($topic->parents[0] == 0) { // This is a top-level topic
            if (
              !empty($queryFocus)
              && strcmp($queryFocus, $name) == 0
              && empty($focus)
            ) {
              $focus = $name;
            }
          }
        }
      }

      foreach ($topic->parents as $parent) {
        if (isset($children[$parent])) {
          $children[$parent][$topic->tid] = $topic->tid;
        }
        else {
          $children[$parent] = [$topic->tid => $topic->tid];
        }
      }
    }

    /*
     * Add any $children of the $topics
     */
    $parents = $topics;
    do {
      $added = [];
      foreach ($parents as $parent) {
        if (isset($children[$parent])) {
          foreach ($children[$parent] as $child) {
            if (!isset($topics[$child])) {
              $added[$child] = $child;
              $topics[$child] = $child;
            }
          }
        }
      }
      $parents = $added;
    } while (!empty($parents));
  }

  /*
   * The title shouldn't be empty and should include the search string
   */
  if ($search) {
    $titles = ["'$search'", ...$titles];
  }
  if (empty($titles)) {
    $titles = ['All topics'];
  }

  $result = [
    'tids' => implode('+', $topics),
    'title' => implode(' + ', $titles),
    'focus' => $focus,
    'search' => $search,
  ];

  return $result;
}

/*
 * Convert Article Topics supplied as a URL query such as "topic=my-topic" to a
 * list of +-separated TIDs.
 */
function cbf_convert_article_topics_to_tids_with_depth() {
  $topics = _cbf_convert_article_topics_url_query();

  return $topics['tids'];
}

/*
 * Convert Article Topics supplied as a URL query such as "topic=my-topic" to a
 * title.
 */
function cbf_convert_article_topics_to_title() {
  $topics = _cbf_convert_article_topics_url_query();

  return $topics['title'];
}

/*
 * Convert Article Topics supplied as a URL query such as "focus=my-topic" to
 * a focus topic.
 */
function cbf_convert_article_topics_to_focus() {
  $topics = _cbf_convert_article_topics_url_query();

  return $topics['focus'];
}

/*
 * Implement a cache of views content which is required to be unique.
 *
 * If the argument is false then clear the cache (for use in another view).
 *
 * The return value tells whether $content has already been seen.
 */
function cbf_is_views_content_unique($content) {
  static $cache = [];

  if ($content === false) {
    $cache = [];
    return false;
  }

  foreach ($cache as $cached) {
    if ($content == $cached) {
      return false;
    }
  }

  $cache[] = $content;
  return true;
}

/*
 * Implements hook_entity_info_alter
 *
 * Alter the entity info.
 *
 * Modules may implement this hook to alter the information that defines an
 * entity. All properties that are available in hook_entity_info() can be
 * altered here.
 */
function cbf_entity_info_alter(&$entity_info) {

  /*
   * Set up the CBF entity label callback
   */
  $entity_info['entityform']['label callback'] = 'cbf_entityform_label_callback';
}

function cbf_entityform_label_callback($entity, $entity_type) {
  $title = cbf_field_get_items($entity_type, $entity, 'field_title', 'value', '');
  if (empty($title)) {
    $title = $entity->label();
  }
  return $title;
}

/*
 * Implements hook_entity_query_alter()
 *
 * "Alter or execute an EntityFieldQuery"
 */
function cbf_entity_query_alter(EntityFieldQuery $query) {
  /*
   * If the query has 'entityreference_match' metadata then EntityReference_SelectionHandler_Generic::
   * buildEntityFieldQuery($match, $match_operator) hasn't added a condition for $match, as the entity
   * has no 'label' property. For EntityForms filter on field_title.
   */
  $match = $query->metaData['entityreference_match'] ?? null;
  if (!empty($match)) {
    $entity_type = $query->entityConditions['entity_type']['value'] ?? null;
    if ($entity_type == 'entityform') {
      $operator = $query->metaData['entityreference_match_operator'] ?? null;
      if (!empty($operator)) {
        $query->fieldCondition('field_title', 'value', $match, $operator);
      }
    }
  }
}

/*
 * Used in views displays where the contextual filters rely on the path alias.
 * Proofs the filter against reworking the alias.
 *
 * Example: if /city/page/sam-chan is renamed to /speakers/sam-chan
 */
function cbf_get_last_item_in_path() {
  $path = drupal_get_path_alias();
  $pathElements = explode('/', $path);
  return end($pathElements);
}

/*
 * An implementation of hook_views_rss_feed_alter()
 */
function cbf_views_rss_feed_alter(&$rss_feed) {
  $isWanted = -1;
  $isNotWanted = -2;

  $indices = [
    'title' => $isWanted,
    'description' => $isWanted,
    'link' => $isWanted,
    'image' => $isWanted,
    'itunes:subtitle' => $isWanted,
    'itunes:summary' => $isWanted,
    'itunes:image' => $isWanted,
  ];
  foreach ($rss_feed['value'][0]['value'] as $index => $value) {
    $key = $indices[$value['key']] ?? $isNotWanted;
    if ($key === $isWanted) {
      $indices[$value['key']] = $index;
    }
  }

  $path = $rss_feed['value'][0]['value'][$indices['title']]['value'];
  $t = explode('/', $path);
  if (is_array($t) && count($t) == 2 && $t[0] == 'collection' && is_numeric($t[1])) {

    $result = entityform_load($t[1]);

    if ($result === false) {
      return;
    }

    $field_title = cbf_field_get_items('entityform', $result, 'field_title', 'safe_value', '');
    $field_subtitle = cbf_field_get_items('entityform', $result, 'field_subtitle', 'safe_value', '');
    $field_short_form = strip_tags(cbf_field_get_items('entityform', $result, 'field_short_form', 'value', ''));

    $link = $rss_feed['value'][0]['value'][$indices['link']]['value'] . $path;
    $image = $rss_feed['value'][0]['value'][$indices['image']]['value']['url'];
    $image = preg_replace('![^/]+$!i', $t[0].'-'.$t[1].'-rss-feed.jpg', $image) ?? $image;

    $rss_feed['value'][0]['value'][$indices['title']]['value'] = $field_title;
    $rss_feed['value'][0]['value'][$indices['description']]['value'] = $field_short_form;
    $rss_feed['value'][0]['value'][$indices['link']]['value'] = $link;
    $rss_feed['value'][0]['value'][$indices['image']]['value']['url'] = $image;
    $rss_feed['value'][0]['value'][$indices['image']]['value']['title'] = $field_title;
    $rss_feed['value'][0]['value'][$indices['image']]['value']['link'] = $link;
    $rss_feed['value'][0]['value'][$indices['image']]['value']['description'] = $field_short_form;
    $rss_feed['value'][0]['value'][$indices['image']]['value']['width'] = 1400;
    $rss_feed['value'][0]['value'][$indices['image']]['value']['height'] = 1400;
    $rss_feed['value'][0]['value'][$indices['itunes:subtitle']]['value'] = $field_subtitle;
    $rss_feed['value'][0]['value'][$indices['itunes:summary']]['value'] = $field_short_form;
    $rss_feed['value'][0]['value'][$indices['itunes:image']]['attributes']['href'] = $image;
  }
}

/*
 * Implements hook_cbf_facebook_pixel_event
 *
 * Adds the following Facebook Pixel events:
 *  - ViewContent - for paths on the main menus
 *  - Search - for results of node searches
 */
function cbf_cbf_facebook_pixel_event($domain, $path) {

  $code = '';

  // ViewContent - if this page is an element of the primary menu
  $trail = menu_get_active_trail();
  switch (end($trail)['menu_name'] ?? '') {
    case 'menu-cbf-2019-main-menu':
    case 'menu-cbf-2019-plus-menu':
      $code .= "fbq('track', 'ViewContent');";
      break;
  }

  // Search - if this page is the result of a Node search
  if (stripos($path, 'search/node/') === 0) {
    $code .= "fbq('track', 'Search');";
  }

  return $code;
}

/*
 * A wrapper around field_get_items() that returns either a single value or an
 * array of values.
 *
 *   0 values   Return the $default
 *   1 value    If $default is an array then return the value as an array
 *              Otherwise return the value itself
 *   2+ values  Return the values as an array
 */
function cbf_field_get_items($entity_type, $entity, $field_name, $field_value, $default = null, $langcode = null) {
  $field = field_get_items($entity_type, $entity, $field_name, $langcode);
  if ($field === false || count($field) == 0) {
    return $default;
  }
  if (count($field) == 1 && !is_array($default)) {
    return reset($field)[$field_value];
  }
  $result = [];
  foreach ($field as $fieldDelta) {
    if ($field_value) {
      $result[] = $fieldDelta[$field_value] ?? null;
    }
    else {
      $result[] = $fieldDelta;
    }
  }
  return $result;
}

/*
 * Find the $node and $activity related to the current page's
 * menu_get_object()
 */
function _cbf_find_object_and_activity_for_page() {

  $node = $activity = null;

  $node = menu_get_object('node');
  if (!empty($node) && is_object($node)) {
    if ($node->type == 'activity') {
      $activity = $node;
    }
    else {
      $activity = cbf_field_get_items('node', $node, 'field_in_activity', 'target_id', []);
      $activity = empty($activity) ? false : entity_load('node', $activity);
      $activity = empty($activity) ? false : reset($activity);
    }
  }
  else {
    $node = false;
  }

  return [
    'node' => $node,
    'activity' => $activity,
  ];
}

/*
 * Implements hook_datalayer_alter()
 *
 * "Alter the Data Layer data before it is output to the screen."
 *
 */
function cbf_datalayer_alter(array &$data_layer) {

  // Datalayer defaults
  $formTitle = $_SESSION['City Bible Forum']['Form title'] ?? '';
  unset($_SESSION['City Bible Forum']['Form title']);

  $page = _cbf_find_object_and_activity_for_page();

  // Datalayer values
  if (!empty($page['activity'])) {
    $data_layer['cbfActivity'] = $page['activity']->title;
  }
  if (!empty($formTitle) && !empty($page['node'])) {
    $data_layer['cbfForm'] = $page['node']->title;
  }
}

/*
 * Implements hook_webform_submission_insert()
 *
 * Respond to a Webform submission being inserted.
 */
function cbf_webform_submission_insert($node, $submission) {
  $_SESSION['City Bible Forum']['Form title'] = $node->title;
}
