<?php

/*
 * This hook is called at the beginning of a Drupal page request.
 */
function cbf_init() {
  if (arg(0) == 'node') {
    if (arg(1) == 'add') {
      /*
       * This JavaScript sets some defaults when adding new nodes.
       *  1. Tablefield fields default to plain text
       *  2. The File Field source is ICME to encourage reuse
       */
      $script = 'jQuery(document).ready(function(){
        jQuery(".field-type-tablefield .filter-wrapper select.filter-list option").each(function() {
          this.selected = (this.text == "Plain text");
        });
        jQuery(".filefield-source-imce").click();
      });';
      drupal_add_js($script, 'inline');
    }
    elseif (is_numeric(arg(1)) && arg(2) == 'edit') {
      /*
       * This JavaScript sets some defaults when editing nodes.
       *  1. The File Field source is ICME to encourage reuse
       */
      $script = 'jQuery(document).ready(function(){
        jQuery(".filefield-source-imce").click();
      });';
      drupal_add_js($script, 'inline');
    }
  }

  /*
   * Add the Hello Bar script for anonymous users accessing non-admin pages on either
   * the CBF or CBF+ sites. Specifically exclude CiviCRM pages where we might prefer
   * people sign up or donate!
   */
  if (
    user_is_anonymous() &&
    !path_is_admin(current_path()) &&
    stristr(domain_get_domain()['subdomain'], 'citybibleforum') !== false &&
    arg(0) != 'civicrm'
  ) {
    $script = 'https://my.hellobar.com/51a112094c6b96376334f43862007262da5c967e.js';
    drupal_add_js(
      $script,
      [
        'type' => 'external',
        'scope' => 'footer',
        'defer' => true,
      ]
    );
  }

  return array();
}

/*
 * Implements Drupal hook_form_alter().
 *
 * "Perform alterations before a form is rendered"
 */
function cbf_form_alter(&$form, &$form_state, $form_id) {
  /*
   * Limit the views_exposed_form on the block-1 display of the
   * cbf2019-national-activity-contents view. It should only list
   * What's On locations where this Activity is active.
   */
  if ($form['#id'] == 'views-exposed-form-cbf2019-national-activity-contents-block-1'
    && $form_id == 'views_exposed_form') {
    $node = menu_get_object();
    if (empty($node)) {
      $whatsOnLocations = [];
    }
    else {
      $whatsOnLocations = field_get_items('node', $node, 'field_highlight_location');
    }
    $options = [];
    foreach ($form['field_highlight_location_tid']['#options'] as $tid => $city) {
      if (is_numeric($tid)) {
        foreach ($whatsOnLocations as $i => $whatsOn) {
          if ($whatsOn['tid'] == $tid) {
            $options[$tid] = $city;
            unset($whatsOnLocations[$i]);   // Optimisation - no need to look at this again
            break;
          }
        }
      }
      else {
        $options[$tid] = $city;
      }
    }
    if (count($options) <= 2) {
      $form['#access'] = false;   // No need to show form if only options are 'All' and one city
    }
    else {
      $form['field_highlight_location_tid']['#options'] = $options;
    }
  }

  /*
   * Set the text format for CiviCRM Event entity properties
   * which are presented in an HTML editor.
   */
  if ($form['#id'] == 'civicrm-event-form') {
    $formatTextFields = array(
      'Textarea' => array(
        'fields' => array(
          'summary',
        ),
        'actions' => array(
          '#type' => 'textarea',
          '#format' => null,
        ),
      ),
      'Full HTML' => array(
        'fields' => array(
          'description',
          'event_full_text',
          'intro_text',
          'footer_text',
          'confirm_text',
          'confirm_footer_text',
        ),
        'actions' => array(
          'format' => 'full_html',
          '#format' => null,
        ),
      ),
    );
    foreach ($formatTextFields as $step) {
      foreach ($step['fields'] as $field) {
        foreach ($step['actions'] as $key => $value) {
          if ($value === null) {
            unset($form[$field][$key]);
          }
          else {
            $form[$field][$key] = $value;
          }
        }
      }
    }
  }

  /*
   * When editing a CiviCRM Event entity we need to keep the Drupal and CiviCRM
   * staff contact fields in sync. If there is a Drupal field, this takes
   * precedence.
   *
   * The CiviCRM custom field for the staff contact is displayed as the text
   * the text name of the contact, but when the form is saved, the contact
   * Id is expected.
   */
  if ($form['#id'] == 'civicrm-event-form') {
    $staffContactId = null;
    $drupalContact = null;
    $civicrmContact = null;
    $matches = null;

    /* Try getting the contact Id from the Drupal field for the staff contact */
    $drupalContact = $form['field_staff_contact']['und'][0]['contact_id']['#default_value'];
    if (preg_match('!(.+) \[cid:([0-9]+)\]!', $drupalContact, $matches) === 1) {
      $staffContactId = $matches[2];
    }

    /* Try getting the contact from CiviCRM */
    if (empty($staffContactId)) {
      $civicrmContact = _cbf_civicrm_civicrm_event_staff_contact($form_state['civicrm_event']->id);
      if (!empty($civicrmContact)) {
        $staffContactId = $civicrmContact['id'];
      }
    }

    if (!empty($staffContactId)) {
      $form['custom_62']['#default_value'] = $staffContactId;
      if (empty($drupalContact) && !empty($civicrmContact)) {
        $form['field_staff_contact']['und'][0]['contact_id']['#default_value']
          = $civicrmContact['name'] . ' [cid:' . $staffContactId . ']';
      }
    }
  }

  /*
   * When editing a CiviCRM Event entity we need to keep the Drupal and CiviCRM
   * ministry centre fields in sync. If there is a Drupal field, this takes
   * precedence.
   */
  if ($form['#id'] == 'civicrm-event-form') {
    $drupalId = null;

    /* Try getting the ministry centre from the Drupal field for the staff contact */
    if (!empty($form['taxonomy_vocabulary_1']['und']['#default_value'][0])) {
      $drupalId = $form['taxonomy_vocabulary_1']['und']['#default_value'][0];
    }

    /* Try getting the ministry centre from CiviCRM */
    if (empty($drupalId)) {
      list($civicrmId, $civicrmCentre) = _cbf_civicrm_civicrm_event_ministry_centre($form_state['civicrm_event']->id);

      if (!empty($civicrmId)) {
        $form['taxonomy_vocabulary_1']['und']['#default_value'][0] = array_flip($form['taxonomy_vocabulary_1']['und']['#options'])[$civicrmCentre];
      }
    }
  }

  /*
   * When editing a CiviCRM Event entity we need to keep the Drupal and CiviCRM
   * event dates in sync. If there is a Drupal field, this takes precedence.
   */
  if ($form['#id'] == 'civicrm-event-form') {
    $drupalDate = null;

    /* Try getting the date from the Drupal date field */
    if (!empty($form['field_event_date']['und'][0]['#default_value'])) {
      $drupalDate = $form['field_event_date']['und'][0]['#default_value'];
    }

    /* Try getting the dates from CiviCRM */
    if (empty($drupalDate)) {
      if (!empty($form['taxonomy_vocabulary_1']['und']['#default_value'])) {
        $ministryCentre =
          $form['taxonomy_vocabulary_1']['und']['#options'][
            $form['taxonomy_vocabulary_1']['und']['#default_value'][0]
          ];
      }
      else {
        $ministryCentre = _cbf_civicrm_civicrm_contact_ministry_centre($staffContactId);
        if ($ministryCentre === false) {
          $ministryCentre = 'Sydney';
        }
      }

      $form['field_event_date']['und'][0]['#default_value'] = [];
      $form['field_event_date']['und'][0]['#default_value']['value']
      = str_replace(' ', 'T', $form['start_date']['#default_value']);
      $form['field_event_date']['und'][0]['#default_value']['value2']
        = str_replace(' ', 'T', $form['end_date']['#default_value']);
      $form['field_event_date']['und'][0]['#default_value']['timezone']
        = $form['field_event_date']['und'][0]['timezone']['#default_value']
        = 'Australia/' . $ministryCentre;
    }
  }

  /*
   * Add a callback to ensure when the form is submitted that CiviCRM variables are
   * overwritten by their Drupal equivalent.
   */
  if ($form['#id'] == 'civicrm-event-form') {
    $form['actions']['submit']['#submit'] = array_merge(
      array('cbf__civicrm_entity_form_submit'),
      $form['actions']['submit']['#submit']
    );
  }

  /*
   * The payment_processor field on the civicrm-event-form doesn't support
   * multiselect, but we want people to be able to choose to pay via credit
   * card or PayPal.
   *
   * Until this is resolved, prevent users accessing this field. They would
   * need to use the CiviCRM admin interface to set payment processors.
   */
  if ($form['#id'] == 'civicrm-event-form') {
    $form['payment_processor']['#access'] = false;
  }

  /*
   * The field_domain on the civicrm-event-form is calculated when the form
   * is saved. To avoid the user having to enter a value that is immediately
   * overridden, prevent the #default_value being empty.
   */
  if ($form['#id'] == 'civicrm-event-form') {
    if (empty($form['field_domain']['und']['domain_id']['#default_value'])) {
      $form['field_domain']['und']['domain_id']['#default_value'] = array(1 => 1);
    }
  }

  /*
   * Grab the mailing list default from the arguments
   */
  if (strpos($form['#id'], 'webform-client-form-') === 0) {
    if (
      isset($form['submitted']['mailing_list']['civicrm_1_contact_1_other_group']['#attributes']['class'])
      && in_array(
        'default-via-parameter',
        $form['submitted']['mailing_list']['civicrm_1_contact_1_other_group']['#attributes']['class']
      )
    ) {
      $form['submitted']['mailing_list']['civicrm_1_contact_1_other_group']['#size'] = 10;
      $form['submitted']['mailing_list']['civicrm_1_contact_1_other_group']['#options'] =
        array(
          'National' => array(
            2677 => '40 Rockets 2019 by email',
            2678 => '40 Rockets 2019 by SMS (East coast)',
            2679 => '40 Rockets 2019 by SMS (West coast)',
          ),
          'Sydney' => array(
            1 => 'Newsletter',
            1756 => 'The Edge',
            1658 => 'Bible Shots',
            1671 => 'Tho Luu Foundation',
          ),
          'Melbourne' => array(
            1813 => 'Melbourne Christians - Life@Work Prayer Network',
          ),
        );
      $params = drupal_get_query_parameters();
      if (filter_var($params['gid'], FILTER_VALIDATE_INT, array('options' => array('min_range' => 1)))) {
        $form['submitted']['mailing_list']['civicrm_1_contact_1_other_group']['#default_value'] = array($params['gid']);
      }
    }
  }

  /*
   * If the form has a field_event_date element then validate it
   */
  if (isset($form['field_event_date'])) {
    $form['#validate'][] = 'cbf_field_event_date_validate';
  }
}

/*
 * Callback for Entity form submission.
 *
 * Overwrite CiviCRM variables with their Drupal equivalents
 *  - Staff contact (overwrite custom_62)
 *  - Ministry centre (overwrite custom_25)
 *  - Event date (set the CiviEvent to start on the first date of a repeating
 *    event and to finish on the last date of a repeating event)
 *  - Number of sessions (count of dates overwrites custom_47)
 *
 * Prevent Drupal values overwriting their CiviCRM equivalents
 *  - Payment processor (Drupal form doesn't support multiselect)
 */
function cbf__civicrm_entity_form_submit(&$form, &$form_state) {
  if ($form['#id'] == 'civicrm-event-form') {
    $form_state['values']['custom_62'] = $form_state['values']['field_staff_contact']['und'][0]['contact_id'];
    if (!empty($form_state['values']['taxonomy_vocabulary_1']['und'][0]['tid'])) {
      $form_state['values']['custom_25'] = _cbf_civicrm_civicrm_event_ministry_centre_id(
        $form['taxonomy_vocabulary_1']['und']['#options'][
          $form_state['values']['taxonomy_vocabulary_1']['und'][0]['tid']
        ]
      );
    }
    else {
      $form_state['values']['custom_25'] = '';
    }

    for ($i = 0; ; $i++) {
      if (!isset($form_state['values']['field_event_date']['und'][$i])) {
        break;
      }
      $last = $form_state['values']['field_event_date']['und'][$i];
      if (!isset($first)) {
        $first = $last;
      }
    }

    $date = new DateObject($first['value'], $first['timezone']);
    $form_state['values']['start_date'] = $date->format('Y-m-d H:i');

    $date = new DateObject($last['value2'], $last['timezone']);
    $form_state['values']['end_date'] = $date->format('Y-m-d H:i');

    $form_state['values']['custom_47'] = $i;

    /*
     * The payment_processor field on the civicrm-event-form doesn't support
     * multiselect, but we want people to be able to choose to pay via credit
     * card or PayPal.
     *
     * Until this is resolved, prevent users changing this field. To do this we
     * send a signal to cbf_civicrm_civicrm_pre() that input from this field on
     * this form should be ignored. We do this by setting the payment_processor
     * to be one that is never used. It's name is 'Hack for CiviCRM Event
     * entities' and its number is 15.
     */
    $dummyPaymentProcessor = '15';
    $form_state['values']['payment_processor'] = $dummyPaymentProcessor;
  }
}

/*
 * This hook is called to alter Drupal comment forms.
 *
 * This change prevents anonymous users accessing the 'homepage' field.
 * Spammers were using this field to get backlinks to their content on
 * this website.
 */
function cbf_form_comment_form_alter(&$form, &$form_state, $form_id) {
  if (user_is_anonymous()) {
    if (isset($form['author']['homepage']['#access'])) {
      $form['author']['homepage']['#access'] = false;
    }
  }
}

/*
 * This hook is called before a comment is saved
 * 
 * Spam comments are being submitted with a certain subject line. This hook prevents
 * those comments being published in the rare case Mollom doesn't stop it.
 */
function cbf_comment_presave($comment) {
  if (user_is_anonymous()) {
    $subjectPatterns = array(
      '^Add new comment \\| ',
    );
    $bodyPatterns = array();
    $patterns = array(
      'viagra',
      '\\bcialis\\b',
      '<(br|p)\\/?>',
    );

    $subject = $comment->subject;
    $body = $comment->comment_body[LANGUAGE_NONE][0]['value'];

    foreach (array_merge($subjectPatterns, $patterns) as $pattern) {
      if (preg_match("/$pattern/i", $subject) == 1) {
        $comment->status = 0;
      }
    }

    foreach (array_merge($bodyPatterns, $patterns) as $pattern) {
      if (preg_match("/$pattern/i", $body) == 1) {
        $comment->status = 0;
      }
    }
  }
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Sort Order.
 * The value is set to the timestamp of the Field Episode Date or the Field Event Date.
 * The Event date takes preference, though no entity should have both being non-empty.
 * The timestamp used is the start time.
 * If the event date is repeating then apply this logic to the first date in the future.
 * If no events are in the future, use the date of the last one in the past.
 */
function computed_field_field_sort_order_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $current_time = strtotime('now');
  $timestamp = 0;

  // Calculate the sort order from the (non-repeating) Episode Date
  $field_episode_date = field_get_items($entity_type, $entity, 'field_episode_date');
  if (!empty($field_episode_date)) {
    $episode = reset($field_episode_date);
    if (!empty($episode['value'])) {
      $start_time = new DateObject($episode['value'], $episode['timezone']);
      $timestamp = strtotime($start_time->format('Y-m-d H:i:s O'));
    }
  }

  // Calculate the sort order from the (repeating) Event Date
  $field_event_date = field_get_items($entity_type, $entity, 'field_event_date');
  if (!empty($field_event_date)) {
    foreach ($field_event_date as $event_occurrence) {
      $start_time = new DateObject($event_occurrence['value'], $event_occurrence['timezone']);
      $timestamp = strtotime($start_time->format('Y-m-d H:i:s O'));

      $end_time = new DateObject($event_occurrence['value2'], $event_occurrence['timezone']);
      $endstamp = strtotime($end_time->format('Y-m-d H:i:s O'));

      if ($endstamp > $current_time) {
        break;
      }
    }
  }

  $entity_field[0]['value'] = $timestamp;
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Sort Order.
 * It returns a string of the form '2011-10-22 22:41:25 +1100'.
 */
function computed_field_field_sort_order_display($field, $entity_field_item) {
  $start_time = new DateObject($entity_field_item['value'], 'UTC');
  return $start_time->format('Y-m-d H:i:s O');
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Next Action.
 * The value is set to the timestamp of the Field Episode Date or the Field Event Date.
 * The Event date takes preference, though no entity should have both being non-empty.
 * The timestamp used is the start time for episodes and the end time for events.
 * If the event date is repeating then apply this logic to the first date in the future.
 * If the timestamp is in the past then next action is zero (there is no next action).
 */
function computed_field_field_next_action_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $current_time = strtotime('now');
  $timestamp = 0;

  // Calculate the next action from the (non-repeating) Episode Date
  $field_episode_date = field_get_items($entity_type, $entity, 'field_episode_date');
  if (!empty($field_episode_date)) {
    $episode = reset($field_episode_date);
    if (!empty($episode['value'])) {
      $start_time = new DateObject($episode['value'], $episode['timezone']);
      $timestamp = strtotime($start_time->format('Y-m-d H:i:s O'));
    }
  }

  // Calculate the next action from the (repeating) Event Date
  $field_event_date = field_get_items($entity_type, $entity, 'field_event_date');
  if (!empty($field_event_date)) {
    foreach ($field_event_date as $event_occurrence) {
      $end_time = new DateObject($event_occurrence['value2'], $event_occurrence['timezone']);
      $timestamp = strtotime($end_time->format('Y-m-d H:i:s O'));

      if ($timestamp > $current_time) {
        break;
      }
    }
  }

  // If the timestamp is in the past, then set the next action to zero (ie, no action)
  if ($timestamp <= $current_time) {
    $timestamp = 0;
  }

  $entity_field[0]['value'] = $timestamp;
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Next Action.
 * It returns a string of the form '2011-10-22 22:41:25 +1100'.
 */
function computed_field_field_next_action_display($field, $entity_field_item) {
  $end_time = new DateObject($entity_field_item['value'], 'UTC');
  return $end_time->format('Y-m-d H:i:s O');
}

/*
 * Calculate date text for an entity that contains either an Episode Date field or an
 * Event Date field. The Event Date takes precedence (though no anticipated content will
 * contain both)
 *
 * If the entity contains an Episode Date, the text is empty for future dates. Otherwise
 * it is the date.
 * 
 * If all occurrences of the event are in the past, this field is the empty string.
 * Else, show the first future occurrence, along with every other occurrence in the
 *  7 days after that occurrence. 
 * If the first future occurrence is in the next 7 days, show just the weekday, else
 *  show the weekday and date.
 * If there are previous repeats of this event, prefix the date with 'Next on '.
 * If there are no previous repeats, and there are subsequent repeats that are not listed,
 * prefix the date with 'Starts on '.
 * Show the start time, unless it is midnight.
 */
function _computed_field_date_text_compute($entity_type, $entity) {
  $current_time = strtotime('now');
  $next_week    = strtotime('now +1 week');
  $startstamp   = 0;
  $endstamp     = 0;
  $upperlimit   = 0;
  $previous     = 0;
  $subsequent   = 0;
  $date_future  = 'D j M';
  $date_past    = 'j M Y';
  $time_format  = 'g.ia';
  $midnight     = '12am';
  $date_text    = false;
  $time_text    = false;
  $nationalTimeText = false;
  $first_text   = false;
  $last_text    = false;

  // Calculate the date text from the (non-repeating) Episode Date
  $field_episode_date = field_get_items($entity_type, $entity, 'field_episode_date');
  if (!empty($field_episode_date)) {
    $episode = $field_episode_date[0];
    if (!empty($episode['value'])) {
      $start_time = new DateObject($episode['value'], $episode['timezone']);
      $startstamp = strtotime($start_time->format('Y-m-d H:i:s O'));

      if ($startstamp <= $current_time) {
        $first_text = $start_time->format($date_past);
        $last_text = $first_text;
      }
    }
  }

  // Calculate the date text from the (perhaps-repeating) Event Date
  $field_event_date = field_get_items($entity_type, $entity, 'field_event_date');
  if (!empty($field_event_date)) {
    foreach ($field_event_date as $event_occurrence) {
      $start_time = new DateObject($event_occurrence['value'], $event_occurrence['timezone']);
      $startstamp = strtotime($start_time->format('Y-m-d H:i:s O'));

      $end_time = new DateObject($event_occurrence['value2'], $event_occurrence['timezone']);
      $endstamp = strtotime($end_time->format('Y-m-d H:i:s O'));

      if ($time_text === false) {
        $time_text = str_replace('.00', '', $start_time->format($time_format));
        if ($time_text != $midnight) {
          $time_text .= '-' . str_replace('.00', '', $end_time->format($time_format));

          $ministryCentre = field_get_items($entity_type, $entity, 'taxonomy_vocabulary_1');
          if (empty($ministryCentre)) {
            $nationalTime = [];
            $query = new EntityFieldQuery();
            $query
            ->entityCondition('entity_type', 'taxonomy_term')
            ->entityCondition('bundle', 'vocabulary_1');
            $result = $query->execute();
            foreach ($result as $entityType => $entities) {
              $terms = taxonomy_term_load_multiple(array_keys($entities));
              foreach ($terms as $term) {
                $tz = 'Australia/' . $term->name;
                $time = new DateObject($startstamp, $tz);
                $from = str_replace('.00', '', $time->format($time_format));
                $time = new DateObject($endstamp, $tz);
                $to = str_replace('.00', '', $time->format($time_format));
                $tzOffset = (int) $time->format('O');
                $tzAbbreviation = $time->format('T');
                if (empty($nationalTime[$tzOffset])) {
                  $nationalTime[$tzOffset] = [
                    'tz' => $tzAbbreviation,
                    'time' => $from . '-' . $to,
                    'state' => $term->description, 
                  ];
                }
                else {
                  $nationalTime[$tzOffset]['state'] .= ', ' . $term->description;
                }
              }
            }

            ksort($nationalTime);
            $nationalTime = array_reverse($nationalTime, true);

            $nationalTimeText = '';
            foreach ($nationalTime as $tzOffset => $tzTime) {
              if (strpos($tzTime['state'], ', ') === false) {
                $city = $tzTime['state'];
              }
              else {
                $city = '&nbsp;';
              }
              $nationalTimeText .=
                '<div class="tz-city">' . $city . '</div>' .
                '<div class="tz-time">' . $tzTime['time'] . '</div>';
            }
          }
        }
      }

      if ($upperlimit == 0 && $endstamp > $current_time) {
        $upperlimit = $startstamp + ($next_week - $current_time);
      }

      if ($endstamp <= $current_time) {
        $previous++;
        if ($first_text === false) {
          $first_text = $start_time->format($date_past);
        }
        $last_text = $end_time->format($date_past);
      }
      else if ($startstamp >= $upperlimit) {
        $subsequent++;
      }
      else {
        $start_date_text = $start_time->format($date_future);
        $end_date_text = $end_time->format($date_future);

        if ($start_date_text == $end_date_text) {
          $this_date_text = $start_date_text;
        }
        else {
          $this_date_text = $start_date_text . ' to ' . $end_date_text;
          $time_text = $midnight;
        }

        if ($date_text === false) {
          $date_text = $this_date_text;
        }
        else {
          $date_text .= ', ' . $this_date_text;
        }
      }
    }
  }

  if ($date_text === false) {
    if ($first_text <> $last_text) {
      $date_text = 'Finished on ' . $last_text;
    }
    else {
      $date_text = $last_text;
    }
  }
  else {
    if ($previous > 0) {
      $date_text = 'Next on ' . $date_text;
    }
    else if ($subsequent > 0) {
      $date_text = 'Starts on ' . $date_text;
    }
  }

  $result = [];
  if ($date_text === false) {
    $result['field_date_text'] =
    $result['field_national_date_text'] = '';
  }
  else if ($time_text === false || $time_text == $midnight) {
    $result['field_date_text'] =
    $result['field_national_date_text'] = $date_text;
  }
  else if ($nationalTimeText === false) {
    $result['field_date_text'] =
    $result['field_national_date_text'] = $date_text . ', ' . $time_text;
  }
  else {
    $result['field_date_text'] = $date_text;
    $result['field_national_date_text'] =
      '<div class="cbf-date">' . $date_text . '</div>' .
      '<div class="cbf-time">' . $nationalTimeText . '</div>';
  }

  return $result;
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Date Text.
 */
function computed_field_field_date_text_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $text = _computed_field_date_text_compute($entity_type, $entity);
  $entity_field[0]['value'] = $text['field_date_text'];
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Date Text.
 */
function computed_field_field_date_text_display($field, $entity_field_item) {
  return $entity_field_item['value'];
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Date Text.
 */
function computed_field_field_national_date_text_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $text = _computed_field_date_text_compute($entity_type, $entity);
  $entity_field[0]['value'] = $text['field_national_date_text'];
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Date Text.
 */
function computed_field_field_national_date_text_display($field, $entity_field_item) {
  return $entity_field_item['value'];
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Is Audio.
 */
function computed_field_field_is_audio_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $field_content = field_get_items($entity_type, $entity, 'field_content');
  if (!empty($field_content)) {
    $entity_field[0]['value'] = 1;
  }
  else {
    $entity_field[0]['value'] = 0;
  }
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Is Audio.
 */
function computed_field_field_is_audio_display($field, $entity_field_item, $entity_lang, $langcode) {
  if ($entity_field_item['value'] != 0) {
    return 'Yes';
  }
  else {
    return 'No';
  }
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Is Video.
 */
function computed_field_field_is_video_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $field_video = field_get_items($entity_type, $entity, 'field_video');
  if (!empty($field_video)) {
    $entity_field[0]['value'] = 1;
  }
  else {
    $entity_field[0]['value'] = 0;
  }
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Is Video.
 */
function computed_field_field_is_video_display($field, $entity_field_item, $entity_lang, $langcode) {
  if ($entity_field_item['value'] != 0) {
    return 'Yes';
  }
  else {
    return 'No';
  }
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Is Text.
 */
function computed_field_field_is_text_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $field_attachment = field_get_items($entity_type, $entity, 'field_attachment');
  if (!empty($field_attachment)) {
    $entity_field[0]['value'] = 1;
  }
  else {
    $entity_field[0]['value'] = 0;
  }
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Resource Type.
 */
function computed_field_field_resource_type_display($field, $entity_field_item, $entity_lang, $langcode) {
  if (stripos($entity_field_item['value'], 'o') !== false) {
    return '<i class="fal fa-fw fa-book"></i>';
  }
  if (stripos($entity_field_item['value'], 'v') !== false) {
    return '<i class="fal fa-fw fa-video"></i>';
  }
  if (stripos($entity_field_item['value'], 'a') !== false) {
    return '<i class="fal fa-fw fa-microphone"></i>';
  }
  if (stripos($entity_field_item['value'], 'd') !== false) {
    return '<i class="fal fa-fw fa-file-pdf"></i>';
  }
  if (stripos($entity_field_item['value'], 't') !== false) {
    return '<i class="fal fa-fw fa-file-alt"></i>';
  }
  return '';
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Resource Type.
*/
function computed_field_field_resource_type_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $field_order_url = field_get_items($entity_type, $entity, 'field_order_url');
  $field_video = field_get_items($entity_type, $entity, 'field_video');
  $field_content = field_get_items($entity_type, $entity, 'field_content');
  $field_attachment = field_get_items($entity_type, $entity, 'field_attachment');

  $entity_field[0]['value'] = '';
  if (!empty($field_order_url)) {
    $entity_field[0]['value'] .= 'o';
  }
  if (!empty($field_video)) {
    $entity_field[0]['value'] .= 'v';
  }
  if (!empty($field_content)) {
    $entity_field[0]['value'] .= 'a';
  }
  if (!empty($field_attachment)) {
    $entity_field[0]['value'] .= 'd';
  }
  if ($entity_type == 'node' && $entity->type == 'blog') {
    $entity_field[0]['value'] .= 't';
  }
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Is Text.
*/
function computed_field_field_is_text_display($field, $entity_field_item, $entity_lang, $langcode) {
  if ($entity_field_item['value'] != 0) {
    return 'Yes';
  }
  else {
    return 'No';
  }
}

/*
 * This function is called by CCK Computed Field to compute the value of field Add to Calendar.
*/
function computed_field_field_add_to_calendar_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $field_next_action = field_get_items($entity_type, $entity, 'field_next_action');
  if ($field_next_action !== false && empty($field_next_action[0]['value'])) {
    $entity_field[0]['value'] = null; // The entity is an event and it has passed
    return;
  }
  $field_civievent = field_get_items($entity_type, $entity, 'field_civievent');
  if ($field_civievent !== false && !empty($field_civievent[0]['target_id'])) {
    $entity_field[0]['value'] = null; // There is a CiviEvent
    return;
  }
  $field_publish_calendar = field_get_items($entity_type, $entity, 'field_publish_calendar');
  if ($field_publish_calendar !== false && empty($field_publish_calendar[0]['value'])) {
    $entity_field[0]['value'] = null; // The 'Publish calendar' flag has been unticked
    return;
  }
  $content_type = $entity->type;
  $entity_nid = $entity->nid;
  $field_in_activity = field_get_items($entity_type, $entity, 'field_in_activity');
  if ($field_in_activity !== false && !empty($field_in_activity)) {
    $entity_activity = $field_in_activity[0]['target_id'];
    $activity = node_load($entity_activity);
    $field_publish_calendar = field_get_items('node', $activity, 'field_publish_calendar');
    if ($field_publish_calendar === false || empty($field_publish_calendar[0]['value'])) {
      $entity_activity = 0; // The activity's 'Publish calendar' flag has not been ticked
    }
  }
  else {
    $entity_activity = 0;
  }
  $field_event_date = field_get_items($entity_type, $entity, 'field_event_date');
  if ($field_event_date != false) {
    $event_count = count($field_event_date); // a possibly-repeating event
  }
  else {
    $event_count = 2; // the other cases will have multiple events (at least 2)
  }
  $taxonomy_vocabulary_1 = field_get_items($entity_type, $entity, 'taxonomy_vocabulary_1');
  if ($taxonomy_vocabulary_1 !== false && !empty($taxonomy_vocabulary_1)) {
    $term = taxonomy_term_load($taxonomy_vocabulary_1[0]['tid']);
    $city = $term->name;
  }
  else {
    $city = '';
  }
  if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {
    $host = $_SERVER['HTTP_X_HOST'];
  }
  else {
    $host = $_SERVER['SERVER_NAME'];
  }
  $schemes = array();
  $results = array();
  $types = array();
  $nids = array();
  $title = '';
  $description = '';
  $startDate = '';
  $endDate = '';
  if ($content_type == 'event') {
    if ($event_count == 1) {
      $schemes[] = 'single';
      $types['single'] = $content_type;
      $nids['single'] = $entity_nid;
      $title = $entity->title;
      $body = field_get_items($entity_type, $entity, 'body');
      if ($body !== false && !empty($body)) {
        $description = truncate_utf8($body[0]['value'], 600, TRUE, TRUE);
      }
      $startDate = '';
      $endDate = '';
    }
    else {
      $schemes[] = 'multiple';
      $types['multiple'] = $content_type;
      $nids['multiple'] = $entity_nid;
    }
    if (!empty($entity_activity)) {
      $schemes[] = 'subscribe';
      $types['subscribe'] = 'activity';
      $nids['subscribe'] = $entity_activity;
    }
  }
  elseif ($content_type == 'activity') {
    $schemes[] = 'subscribe';
    $types['subscribe'] = $content_type;
    $nids['subscribe'] = $entity_nid;
  }
  if (!empty($city)) {
    $schemes[] = 'city';
    $types['city'] = strtolower($city);
    $nids['city'] = 0;
  }
  $clients = array(
    'Apple' => array('single' => 'ics', 'multiple' => 'ics', 'subscribe' => 'webcal', 'city' => 'webcal'),
    'Outlook' => array('single' => 'ics', 'multiple' => 'ics', 'subscribe' => 'webcal', 'city' => 'webcal'),
    'Google Calendar' => array('single' => 'google', 'multiple' => '', 'subscribe' => 'google webcal', 'city' => 'google webcal'),
    'Other' => array('single' => 'ics', 'multiple' => 'ics', 'subscribe' => 'ics', 'city' => 'ics'),
  );
  foreach ($schemes as $scheme) {
    $results[$scheme] = '';
    foreach ($clients as $client => $methods) {
      if ($scheme == 'city') {
        $relative_url = "/ical/city/$types[$scheme]/calendar.ics";
      }
      else {
        $relative_url = "/ical/$types[$scheme]/$nids[$scheme]/calendar.ics";
      }
      switch ($methods[$scheme]) {
        case 'ics':
          $target = $relative_url;
          break;
        case 'webcal':
          $target = "webcal://$host$relative_url";
          break;
        case 'google':
          if (empty($title) || empty($startDate) || empty($endDate)) {
            $target = '';
          }
          else {
            $target = url(
              'http://www.google.com/calendar/event',
              array(
                'query' => array(
                  'action' => 'TEMPLATE',
                  'text' => $title,
                  'dates' => $startDate . '/' . $endDate,
                  'sprop' => 'website:' . $host,
//                  'location' => $info['location'],
                  'details' => $description,
                  'website' => url($info['url'], array('absolute' => TRUE)),
              )));
          }
          break;
        case 'google webcal':
          $target = url(
            'https://www.google.com/calendar/render',
            array(
              'query' => array('cid' => "webcal://$host$relative_url")));
          break;
        default:
          $target = '';
          break;
      }
      if (!empty($target)) {
        $results[$scheme] .= '<li><a href="' . $target . '" target="_blank" rel="noopener noreferrer">' . $client . '</a></li>';
      }
    }
  }
  if (count($results) == 0) {
    $entity_field[0]['value'] = null;
    return;
  }
  $schemeLabel = array(
    'single' => 'This event only',
    'multiple' => 'This event only',
    'subscribe' => 'This and future events like it',
    'city' => "This and future events for $city",
  );
  $result = '
    <ul class="nav">
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#">Add to calendar</a>
        <ul class="dropdown-menu">';
  if (count($results) == 1) {
    foreach ($results as $scheme => $target) {
      $result .= $target;
    }
  }
  else {
    foreach ($results as $scheme => $target) {
      $result .= '
          <li class="dropdown dropdown-submenu">
            <a class="dropdown-toggle" data-toggle="dropdown" href="#">';
      $result .= $schemeLabel[$scheme];
      $result .= '</a>
            <ul class="dropdown-menu">';
      $result .= $target;
      $result .= '
            </ul>
          </li>';
    }
  }
  $result .= '
        </ul>
      </li>
    </ul>';
  $result .= (count($results) == 1) ? '' : '
    <script type="text/javascript">
      (function($){
        $(document).ready(function(){
          $(\'ul.dropdown-menu [data-toggle=dropdown]\').on(\'click\', function(event) {
            event.preventDefault();
            event.stopPropagation();
            $(this).parent().siblings().removeClass(\'open\');
            $(this).parent().toggleClass(\'open\');
          });
        });
      })(jQuery);
    </script>';
  $entity_field[0]['value'] = $result;
}

/*
 * This function is called by CCK Computed Field to generate the display text of field Add to Calendar.
*/
function computed_field_field_add_to_calendar_display($field, $entity_field_item, $entity_lang, $langcode) {
  if (empty($entity_field_item['value'])) {
    return '';
  }
  return $entity_field_item['value'];
}

/*
 * This function is called by CCK Computed Field to compute the value of Field Path Alias.
*/
function computed_field_field_source_entity_alias_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $field_source_entity_type = field_get_items($entity_type, $entity, 'field_source_entity_type');
  $field_source_entity_id = field_get_items($entity_type, $entity, 'field_source_entity_id');
  if (!empty($field_source_entity_type) && !empty($field_source_entity_id)) {
    $path = str_replace('_', '-', $field_source_entity_type[0]['value']);
    $path .= "/{$field_source_entity_id[0]['value']}";
    $entity_field[0]['value'] = drupal_get_path_alias($path);
  }
  else {
    $entity_field[0]['value'] = '';
  }
}

/*
 * This function is called by CCK Computed Field to generate the display text of Field Path Alias.
*/
function computed_field_field_source_entity_alias_display($field, $entity_field_item, $entity_lang, $langcode) {
  if (empty($entity_field_item['value'])) {
    return '';
  }
  return $entity_field_item['value'];
}

/*
 * Validate field_event_date elements on forms.
 *  - an event can't last longer than 3 days. This prevents staff misusing
 *    Events and CiviCRM Events when they should be using a News Story.
 */
function cbf_field_event_date_validate($form, &$form_state) {
  if (isset($form_state['values']['field_event_date'])) {
    $duration = 0;
    foreach (reset($form_state['values']['field_event_date']) as $event_occurrence) {
      if (is_array($event_occurrence)) {
        $start_time = new DateObject($event_occurrence['value'], $event_occurrence['timezone']);
        $startstamp = strtotime($start_time->format('Y-m-d H:i:s O'));

        $end_time = new DateObject($event_occurrence['value2'], $event_occurrence['timezone']);
        $endstamp = strtotime($end_time->format('Y-m-d H:i:s O'));
        $duration += $endstamp - $startstamp;
      }
    }
    if ($duration > 3 * 24 * 60 * 60) {
      form_set_error(
        'field_event_date',
        'The overall duration of this event is greater than 3 daya. ' .
        'This doesn\'t seem like an event. ' .
        'Try a forward dated News Story instead.');
    }
  }
}

/*
 * Implement the rules that assign entities to domains.
 *
 * Rules are stored in the domain information ...
 *
 *     alias = NNNN.activity.rule
 *
 *         NNNN is the node Id for the Activity that corresponds to this domain.
 *         This rule matches if the node's nid or its Activity is NNNN.
 *
 *     alias = christian.audience.rule |
 *             all.audience.rule
 *
 *         Always matches.
 *
 *     alias = general.audience.rule
 *
 *         Matches content for a General audience.
 *
 * The rules have the following effects on nodes...
 *
 *     domain_site   false (content is not available in all affiliates)
 *     domains       contains an entry for each domain that matches a rule
 *     domain_source DOMAIN_SOURCE_USE_ACTIVE (don't change domain to a cardinal
 *                   domain) EXCEPT when the node appears in only one domain
 *
 * The rules have the following effects on CiviCRM Events...
 *
 *     field_domain  false (content is not available in all affiliates)
 */
function cbf_entity_presave($entity, $type) {
  switch ($type) {
    case 'node':
      $url0 = 'node';
      $allDomainBundles = [
        'contact_webform' => true,
        'webform' => true,
      ];
      $skipDomainBundles = [ ];
      $allDomainIds = [
        61 => 'Privacy policy',
      ];
      $entityId = $entity->nid;
      $entityBundle = $entity->type;
      break;
    case 'civicrm_event':
      $url0 = 'civicrm-event';
      $allDomainBundles = [ ];
      $skipDomainBundles = [ ];
      $allDomainIds = [ ];
      $entityId = $entity->id;
      $entityBundle = $type;
      break;
    case 'entityform':
      $url0 = 'entityform';
      $allDomainBundles = [
        'office' => true,
        'ministry_team' => true,
        'staff' => true,
        'regular_venue' => true,
        'title_header' => true,
        'home_page_slider' => true,
      ];
      $skipDomainBundles = [
        'dateable' => true,
        'highlightable' => true,
        'mappable' => true,
      ];
      $allDomainIds = [ ];
      $entityId = $entity->entityform_id;
      $entityBundle = $entity->type;
      break;
    default:
      return;
  }

  /*
   * If saving an entity after editing it, clear the views data cache so the
   * staff member editing the node can see the refreshed version of the views
   * blocks on the page.
   */
  if (arg(0) == $url0 && arg(2) == 'edit') {
    cache_clear_all('*', 'cache_views_data', true);
  }

  $followDomainRules = empty($skipDomainBundles[$entityBundle]);

  if ($followDomainRules) {
    $domains = domain_list_by_machine_name();

    $matches = [ ];

    $field_in_activity = field_get_items($type, $entity, 'field_in_activity');
    if ($field_in_activity === false || empty($field_in_activity[0]['target_id'])) {
      $entityActivity = 0;
    }
    else {
      $entityActivity = $field_in_activity[0]['target_id'];
    }

    $audienceTerm = field_get_items($type, $entity, 'taxonomy_vocabulary_3');
    if ($audienceTerm === false || empty($audienceTerm[0]['tid'])) {
      $entityAudience = '';
    }
    else {
      switch ($audienceTerm[0]['tid']) {
        case '47':
          $entityAudience = 'christian';
          break;
        case '48':
          $entityAudience = 'general';
          break;
        default:
          $entityAudience = '';
          break;
      }
    }

    $field_third_space_category = field_get_items($type, $entity, 'field_third_space_category');
    if ($field_third_space_category === false || empty($field_third_space_category[0]['tid'])) {
      $entityHasThirdSpaceCategory = false;
    }
    else {
      $entityHasThirdSpaceCategory = true;
    }

    $field_third_space_exclusive = field_get_items($type, $entity, 'field_third_space_exclusive');
    if ($field_third_space_exclusive === false || empty($field_third_space_exclusive[0]['value'])) {
      $entityIsThirdSpaceExclusive = false;
    }
    else {
      $entityIsThirdSpaceExclusive = true;
    }

    foreach ($domains as $domain) {
      $match = false;
      if (isset($allDomainBundles[$entityBundle])) {
        $match = true;
      }
      else if (isset($allDomainIds[$entityId])) {
        $match = true;
      }
      else {
        foreach ($domain['aliases'] as $alias) {
          $ruleDomain = stristr($alias['pattern'], '.domain.rule', true);
          if ($ruleDomain == 'thirdspace') {
            if ($entityHasThirdSpaceCategory == true && $entityAudience == 'general') {
              if ($entityIsThirdSpaceExclusive) {
                $matches = [ [ 'domain_id' => $domain['domain_id'] ] ];
                break 2;
              }
              $match = true;
              break;
            }
          }

          $ruleActivity = stristr($alias['pattern'], '.activity.rule', true);
          if ($ruleActivity !== false) {
            $ruleActivity = (int) $ruleActivity;
            if ($entityActivity == $ruleActivity || ($type == 'node' && $entityId == $ruleActivity)) {
              $match = true;
              break;
            }
          }

          $ruleAudience = stristr($alias['pattern'], '.audience.rule', true);
          if ($ruleAudience !== false) {
            if (
              $ruleAudience == 'all' ||
              $ruleAudience == 'christian' ||
              strcasecmp($ruleAudience, $entityAudience) == 0
            ) {
              $match = true;
              break;
            }
          }
        }
      }

      if ($match) {
        $matches[] = [ 'domain_id' => $domain['domain_id'] ];
      }
    }

    switch ($type) {
      case 'node':
        $entity->domain_site = false;
        $entity->domains = [ ];
        foreach ($matches as $domain) {
          $entity->domains[$domain['domain_id']] = $domain['domain_id'];
        }
        if (count($entity->domains) == 1) {
          $entity->domain_source = reset($entity->domains);
        }
        else {
          $entity->domain_source = DOMAIN_SOURCE_USE_ACTIVE;
        }
        break;

      case 'civicrm_event':
        $entity->field_domain[field_language($type, $entity, 'field_domain')] = $matches;
        break;

      case 'entityform':
        $entity->domain_entityform[field_language($type, $entity, 'domain_entityform')] = $matches;
        break;
    }
  }
}

/*
 * CKEditor introduces some unpleasant artifacts into HTML text fields. This
 * function handles them ...
 *
 *   - Empty paragraphs are removed
 *   - Non-breaking spaces are replaced with plain spaces
 *   - Ensure target="_blank" attributes have a rel="noopener noreferrer"
 *     attribute https://medium.com/@jitbit/target-blank-the-most-underestimated-vulnerability-ever-96e328301f4c#.dzwczm21q
 *
 * The order of these actions is important as the patterns have overlapping content.
 */
function cbf_field_attach_presave($entity_type, $entity) {
  if ($entity_type == 'node') {
    $html_fields = array('body', 'field_short_form', 'field_sidebar_content');
    $attributes = array('summary','value');
    $replacements = array(
      '!<p>(\r\n\t)*&nbsp;</p>!i' => '',
      '!&nbsp;!i'                 => ' ',
      '!target="_blank" rel="noopener noreferrer"!i'           => 'target="_blank"',
      '!target="_blank"!i'                                     => 'rel="noopener noreferrer" target="_blank"',
      '!rel="noopener noreferrer" rel="noopener noreferrer"!i' => 'rel="noopener noreferrer"',
    );
    $from = array_keys($replacements);
    $to = array_values($replacements);
    foreach ($html_fields as $html_field) {
      if (isset($entity->$html_field)) {
        $field = & $entity->$html_field;
        $languages = array_keys($field);
        foreach ($languages as $language) {
          $instances = count($field[$language]);
          for ($instance = 0; $instance < $instances; $instance++) {
            foreach ($attributes as $attribute) {
              if (isset($field[$language][$instance][$attribute])) {
                $field[$language][$instance][$attribute]
                  = preg_replace($from, $to, $field[$language][$instance][$attribute]);
              }
            }
          }
        }
      }
    }
  }
}

/*
 * This function is called by Drupal cron.
 *
 * Re-save entities that have a field_next_action which is set to a time between
 * the previous invocation of cron and this one. This enacts time-sensitive
 * calculations of computed field values.
 *
 * Prevent nodes that were posted to Twitter from being automatically re-posted if
 * they are edited.
 *
 * The time that cron was run is updated for next time.
 */
function cbf_cron() {
  $current_time = strtotime('now');
  $last_run     = variable_get('cbf_cron_last_run', 0);

  /*
   * Initialize CiviCRM. This is a precaution now that CiviCRM and Drupal are
   * becoming more tightly coupled.
   */
  civicrm_initialize();

  /* Set operator and values for filtering field_next_action */
  if ($last_run == 0) {
    $operator = '>';
    $values = array($last_run);
  }
  else {
    $operator = 'BETWEEN';
    $values = array($last_run, $current_time);
  }

  /* Update entities with actions due */
  $query = new EntityFieldQuery();
  $result = $query->fieldCondition('field_next_action', 'value', $values, $operator)
    ->execute();
  foreach ($result as $entityType => $entities) {
    $entities = entity_load($entityType, array_keys($entities));
    foreach ($entities as $entity) {
      switch ($entityType) {
        case 'node':
          node_save($entity);
          break;
        case 'civicrm_event':
          $entity->custom_62 = $entity->custom_62_id;
          entity_save($entityType, $entity);
          break;
      }
    }
  }

  /*
   * Find nodes that were Tweeted using Post to Twitter. Set their status so
   * they are not tweeted again if any calls are made to node_save().
   */
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
    ->fieldCondition('field_post_to_twitter', 'status', 0, '<>')
    ->execute();
  foreach ($result as $entityType => $entities) {
    $nodes = entity_load('node', array_keys($entities));
    foreach ($nodes as $node) {
      // Prevent a post being made again to Twitter
      $langcode = field_language('node', $node, 'field_post_to_twitter');
      if (isset($node->field_post_to_twitter[$langcode][0])) {
        $node->field_post_to_twitter[$langcode][0]['status'] = 0;
      }
      node_save($node);
    }
  }

  /*
   * This is a short-term action.
   *
   * Find every EntityForm of types Ministry Centre and Regular Venue
   * and re-save them.
   *  - these entities have no interface for searching
   *  - the Mappable EntityForm is under development
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'entityform')
    ->entityCondition('bundle', [ 'ministry_team', 'regular_venue' ], 'in')
    ->execute();
  foreach ($result as $entityType => $entities) {
    $entities = entity_load($entityType, array_keys($entities));
    foreach ($entities as $entity) {
      entity_save($entityType, $entity);
    }
  }
   */

  variable_set('cbf_cron_last_run', $current_time);
}

/*
 * When a comment is made in reply to a comment, and email is sent
 * to the author of the original comment. If there is no original
 * comment, the comment is being made directly on the article, but
 * Drupal still attempts to send an email. The "To" header will in
 * this case be an unresolved token and will fail to be delivered.
 * Don't send emails in this case.
 *
 * The Contact module sends emails using the To: address supplied
 * by the visitor to a citybibleforum.org address. When this is
 * redirected to a gmail.com address Gmail rightly complains
 * (Unauthenticated email from yahoo.com is not accepted due to
 * domain's 550-5.7.1 DMARC policy)
 *
 * Change the message headers so the email is sent From the Sender
 * address (doulos@citybibleforum.org), but the original address
 * is in the Reply-To header.
 */
function cbf_mail_alter(&$message) {
  if (strpos($message['to'], '[') !== false) {
    $message['send'] = false;
  }
  else {
    $message['headers']['Reply-To'] = $message['headers']['From'];
    $message['headers']['From'] = $message['headers']['Sender'];
  }
}

/*
 * Derive the city name from the Drupal arguments or the URL
 */
function cbf_city_string() {
  /*
   * The city name is initially unknown, but only needs to be calculated
   * once per request
   */
  static $cbf_city = null;

  if ( !isset($cbf_city) ) {
    /*
     * There is no $city unless specified in the Drupal args or URL
     */
    $city = false;

    if (arg(0) == 'city' && arg(1) != '') {
      $city = arg(1);
    } else {
      $uri = explode('/', $_SERVER['REQUEST_URI']);
      if($uri[1] == 'city' && isset($uri[2]) ){
        $city = $uri[2];
      }
    }

    switch ($city) {
      // The cities
      case 'sydney':
      case 'canberra':
      case 'melbourne':
      case 'brisbane':
      case 'perth':
      case 'adelaide':
      case 'hobart':
        $cbf_city = $city;
        break;

      // Deprecated: the areas in Sydney
      case 'sydney-cbd':
      case 'sydney-cbd-north':
      case 'sydney-cbd-south':
      case 'sydney-legal':
      case 'sydneys-north-shore':
      case 'north-sydney':
      case 'st-leonards':
      case 'chatswood':
      case 'macquarie-park':
      case 'parramatta':
        $cbf_city = 'sydney';
        break;

      // Anything else is not a city
      default:
        $cbf_city = false;
        break;
    }
  }

  return $cbf_city;
}

/*
 * The visitor city name is initially unknown, but only needs to be calculated
 * once per request
 */
function cbf_visitor_city_string() {
  static $cbf_visitor_city = null;

  if (!isset($cbf_visitor_city)) {
    $cbf_visitor_city = false;

    foreach (['ip_geoloc', 'geoip'] as $locator) {
      $country = null;
      $state = null;

      switch ($locator) {
        case 'ip_geoloc':
          if (function_exists('ip_geoloc_get_visitor_location')) {
            $result = ip_geoloc_get_visitor_location();
            $country = isset($result['country'])
              ? $result['country']
              : '';
            $state = isset($result['administrative_area_level_1'])
              ? $result['administrative_area_level_1']
              : '';
          }
          break;

        case 'geoip':
          if (function_exists('geoip_country_name')) {
            $country = geoip_country_name();
            $state = geoip_region_name();
          }
          break;
      }

      switch ($country) {
        case 'Australia':
          switch ($state) {
            case 'New South Wales':
              $cbf_visitor_city = 'sydney';
              break;
            case 'Victoria':
              $cbf_visitor_city = 'melbourne';
              break;
            case 'Queensland':
              $cbf_visitor_city = 'brisbane';
              break;
            case 'South Australia':
              $cbf_visitor_city = 'adelaide';
              break;
            case 'Western Australia':
              $cbf_visitor_city = 'perth';
              break;
            case 'Australian Capital Territory':
              $cbf_visitor_city = 'canberra';
              break;
            case 'Tasmania':
              $cbf_visitor_city = 'hobart';
              break;
          }
          break;
      }

      if (!empty($cbf_visitor_city)) {
        break;
      }
    }
  }

  return $cbf_visitor_city;
}

/*
 * Populate the metatags for a node's Twitter Card and Facebook Open Graph.
 *
 * The Twitter Card preferences are ...
 *
 * #  Twitter card type              Source image     Condition
 * -  -----------------------------  ---------------  ------------------------
 * 1  Summary card with large image  Highlight        Image >= 280px x 150px
 *                                   Series image
 *                                   Image
 * 2  Summary card                   Thumbnail image  Image >= 120px x 120px
 * 3  Summary card                   Logo             No matching image fields
 *
 * The Facebook Open Graph preferences are ...
 *
 * #  Source image  Condition
 * -  ------------  ------------------------
 * 4  Highlight     Image >= 600px x 316px
 *    Series Image
 *    Image
 * 5  Highlight     Image >= 280px wide
 *    Series Image
 *    Image
 * 6  Logo          No matching image fields
 */
function cbf_metatag_pattern_alter(&$pattern, &$types, $tag_name) {
  if (isset($types['node'])) {
    $node = $types['node'];
    $largeImages = array('field_highlight', 'field_image', 'field_series_image');
    switch ($tag_name) {
      case 'twitter:card':
      case 'twitter:image':
        /* Option 3 is the default */
        $card = 'summary';
        $src = '';
        /* Try Option 1 */
        foreach ($largeImages as $largeImage) {
          $image = field_get_items('node', $node, $largeImage);
          if ($image !== false && !empty($image)) {
            if (isset($image[0]['width']) && $image[0]['width'] >= 280 &&
                isset($image[0]['height']) && $image[0]['height'] >= 150) {
              $card = 'summary_large_image';
              $src = "[node:$largeImage]";
              break;
            }
          }
        }
        /* Try Option 2 */
        if ($src == '') {
          $image = field_get_items('node', $node, 'field_thumbnail_image');
          if ($image !== false && !empty($image)) {
            if (isset($image[0]['width']) && $image[0]['width'] >= 120 &&
                isset($image[0]['height']) && $image[0]['height'] >= 120) {
              $src = "[node:field_thumbnail_image]";
            }
          }
        }
        /* Update the tag pattern if changed from the default */
        if ($src != '') {
          switch ($tag_name) {
            case 'twitter:card':
              $pattern = $card;
              break;
            case 'twitter:image':
              $pattern = $src;
              break;
          }
        }
        break;

      case 'og:image':
        /* Option 6 is the default */
        $src = '';
        /* Try Option 4 */
        foreach ($largeImages as $largeImage) {
          $image = field_get_items('node', $node, $largeImage);
          if ($image !== false && !empty($image)) {
            if (isset($image[0]['width']) && $image[0]['width'] >= 600 &&
                isset($image[0]['height']) && $image[0]['height'] >= 316) {
              $src = "[node:$largeImage]";
              break;
            }
          }
        }
        /* Try Option 5 */
        if ($src == '') {
          foreach ($largeImages as $largeImage) {
            $image = field_get_items('node', $node, $largeImage);
            if ($image !== false && !empty($image)) {
              if (isset($image[0]['width']) && $image[0]['width'] >= 280) {
                $src = "[node:$largeImage]";
                break;
              }
            }
          }
        }
        if ($src != '') {
          $pattern = $src;
        }
        break;
    }
  }
}

/**
 * Alter metatags before being cached.
 *
 * This hook is invoked prior to the meta tags for a given page are cached.
 *
 * For SEO purposes, content that appears on both the citybibleforum.org and the
 * plus.citybibleforum.org site should have a canonical URL pointing to citybibleforum.org.
 * So, if this is a Node or a CiviCRM Event, whose Audience is General, remove the 'plus.'
 * from the canonical URL.
 *
 * @param array $output
 *   All of the meta tags to be output for this page in their raw format. This
 *   is a heavily nested array.
 * @param string $instance
 *   An identifier for the current page's page type, typically a combination
 *   of the entity name and bundle name, e.g. "node:story".
 * @param array $options
 *   All of the options used to generate the meta tags.
 */
function cbf_metatag_metatags_view_alter(&$output, $instance, $options) {
  if (stripos($instance, 'node:') === 0 || stripos($instance, 'civicrm_event:') === 0) {
    $audienceTerm = field_get_items($options['entity_type'], $options['entity'], 'taxonomy_vocabulary_3');
    if (!empty($audienceTerm[0]['tid']) && $audienceTerm[0]['tid'] == '48') {
      if (isset($output['canonical']['#attached']['drupal_add_html_head'][0][0]['#value'])) {
        $canonical = $output['canonical']['#attached']['drupal_add_html_head'][0][0]['#value'];
        $canonical = str_ireplace('//plus.', '//', $canonical);
        $output['canonical']['#attached']['drupal_add_html_head'][0][0]['#value'] = $canonical;
      }
    }
  }
}

/*
 * A function to parse the exposed filters on the National Library view,
 * to extract the topics, and return a string containing them.
 *
 * This function is invoked by the contextual filter 'Header topics string'
 * in the page display 'Library' in the view 'National Library'.
 */
function cbf_library_view_topics_string(&$view) {
  if ( ! isset($view->exposed_input['field_topic_tid']) ) {
    return ' ';
  }

  $result = array();

  foreach ($view->exposed_input['field_topic_tid'] as $tid) {
    $queryResult = db_query(
      'select name from {taxonomy_term_data} where tid = :tid',
      array(':tid' => $tid));
    foreach ($queryResult as $row) {
      $result[] = $row->name;
    }
  }

  return implode(' | ', $result);
}

function cbf_views_api() {
  return [ 'api' => 3 ];
}


/*
 * Implementation of hook_views_pre_render
 *   - Centres the GMap in GMap views
 *   - Formats the Description in the RSS feed of the prayer_points view
 *   - Counts the number of rows and adds classes to the view as appropriate
 *       - views-1-row
 *       - views-2-rows
 *       - views-3-rows
 *       - views-n-rows
 *   - Fixes the Title and Header content when cbf2019_third_space_category
 *     returns no results. Replace '[name]' with the name of the
 *     third_space_category term, whose $tid is the first contextual filter.
 */
function cbf_views_pre_render(&$view) {
  $watch = array('city_to_address');
  $displays = array('block_address');

  if ( in_array($view->name, $watch) ) {

    // Modifies the GMap Macro to ensure that the map gets properly centered.
    if ( in_array($view->current_display, $displays)
       && isset($view->result[0]->gmap_lat)
       && isset($view->result[0]->gmap_lon) ) {

      $macro = $view->display[$view->current_display]->handler->view->style_plugin->options['macro'];
      if ( !strstr('|center=', $macro) ) {
        $latlong = "{$view->result[0]->gmap_lat},{$view->result[0]->gmap_lon}";

        $macro  = str_replace(']', ' |center=' . $latlong . ']', $macro);
        $view->display[$view->current_display]->handler->view->style_plugin->options['macro'] = $macro;
      }
    }
  }

  $watch = array('reaching_city_civicrm_event_gmap');
  $displays = array('block_address');

  if ( in_array($view->name, $watch) ) {

    // Modifies the GMap Macro to ensure that the map gets properly centered.
    if ( in_array($view->current_display, $displays)
       && isset($view->result[0]->civicrm_address_geo_code_1)
       && isset($view->result[0]->civicrm_address_geo_code_2) ) {

      $macro = $view->display[$view->current_display]->handler->view->style_plugin->options['macro'];
      if ( !strstr('|center=', $macro) ) {
        $latlong = "{$view->result[0]->civicrm_address_geo_code_1},{$view->result[0]->civicrm_address_geo_code_2}";

        $macro  = str_replace(']', ' |center=' . $latlong . ']', $macro);
        $view->display[$view->current_display]->handler->view->style_plugin->options['macro'] = $macro;
      }
    }
  }

  $watch = array('prayer_points');
  $displays = array('feed');

  if (in_array($view->name, $watch)) {
    // Sets the Description in the RSS feeds.
    if (in_array($view->current_display, $displays)) {
      $lookup = array(
        'event' => array(
          'title' => 'An event',
          'preposition' => ' in ',
        ),
        'story' => array(
          'title' => 'News',
          'preposition' => ' for ',
        ),
        'blog' => array(
          'title' => 'A blog article',
          'preposition' => ' for ',
        ),
        'episode' => array(
          'title' => 'A new item in the library',
          'preposition' => ' for ',
        ),
      );
      foreach ($view->result as $i => $result) {
        if (isset($lookup[$result->node_type])) {
          $title = $lookup[$result->node_type]['title'];
          $city = $result->field_taxonomy_vocabulary_1[0]['rendered']['#markup'];
          $activity = $result->field_field_in_activity[0]['rendered']['#markup'];
          $datetext = $result->field_field_date_text[0]['rendered']['#markup'];
          $prayer = $result->field_field_prayer_point[0]['rendered']['#markup'];
          if (!empty($city)) {
            $title .= $lookup[$result->node_type]['preposition'] . $city;
          }
          if (!empty($activity)) {
            if (!empty($city)) {
              $activity = str_replace(' in ' . $city, '', $activity);
            }
            $title .= ' | ' . $activity;
          }
          $description = "<p><strong>$title </strong></p>";
          if (!empty($datetext)) {
            $description .= "<p><em>$datetext </em></p>";
          }
          $description .= "<p>$prayer</p>";
          $result->field_field_prayer_point[0]['rendered']['#markup'] = $description;
        }
      }
    }
  }

  $class = $view->display_handler->get_option('css_class');
  switch (count($view->result)) {
    case 0:
      $c = '';
      break;

    case 1:
      $c = 'views-1-row';
      break;

    case 2:
    case 3:
      $c = 'views-' . count($view->result) . '-rows';
      break;

    default:
      $c = 'views-n-rows';
      break;
  }
  $view->display_handler->set_option('css_class', trim($class . ' ' . $c));

  if (
    $view->name == 'cbf2019_third_space_category'
    && $view->current_display == 'page_1'
    && empty($view->result)
  ) {
    $title = 'Category';
    if (!empty($view->args[0])) {
      $category = taxonomy_term_load($view->args[0]);
      if ($category !== false) {
        $title = $category->name;
      }
    }
    $view->set_title($title);
    $view->display_handler->display->handler->handlers['header']['area']->options['content'] = $title;
  }
}

/*
 * Implements hook_views_post_execute.
 *
 * https://api.drupal.org/api/views/views.api.php/function/hook_views_post_execute/7.x-3.x
 *
 *  "This hook is called right after the execute process. The query has been executed,
 *   but the pre_render() phase has not yet happened for handlers.
 *
 *  "Adding output to the view can be accomplished by placing text on $view->attachment_before
 *   and $view->attachment_after. Altering the content can be achieved by editing the items of
 *   $view->result"
 */
function cbf_views_post_execute(&$view) {
  /*
   * If the results of this view need to be filtered to only include content
   * local to the visitor, then remove items that don't match.
   */
  if (in_array('local', explode(', ', $view->tag))) {
    $city = cbf_visitor_city_string();
    if (!empty($city)) {
      $alteredResults = [];
      foreach ($view->result as $result) {
        if (
          empty($result->field_taxonomy_vocabulary_1)
          || stristr($result->field_taxonomy_vocabulary_1[0]['rendered']['#markup'], $city) !== false
        ) {
          $alteredResults[] = $result;
        }
      }
      if (count($alteredResults) != count($view->result)) {
        $view->result = $alteredResults;
      }
    }
  }

  /*
   * This function prevents block displays being crowded out by Events of a single Activity
   * (eg Bible Shots runs 3 events each week). These block displays are indicated by either
   *  1. The view is tagged with 'merge-events'
   *  2. The display is marked with a CSS class 'cbf-merge-events' (useful if merging is not
   *     appropriate for all displays)
   *
   * The display is set to not limit the number of items
   *  1. By default this is limited by this function to 5
   *  2. If the display has the CSS class 'show-N-items' then this function limits the number
   *     to N, where N is an integer
   *
   * To prevent this crowding out, we check if there are multiple Events sharing the same
   * name and Activity. If that's the case, we 'summarise' those Events: we keep the first
   * and the rest are removed from the results. The Date Text of that first Event is altered
   * to include a link to a page of events for the Event's Activity.
   */
  if (
    (
      preg_match(
        '/(^| )merge-events(,|$)/i',
        $view->tag) == 1
      ||
      preg_match(
        '/(^| )cbf-merge-events($| )/i',
        $view->display_handler->get_option('css_class')) == 1
    ) &&
    $view->display_handler->plugin_name == 'block'
  ) {
    /*
     * $eventsByActivity is an array of arrays. It maps from Activity Id to Event name to
     * index of the first element of $view->result that has that Activity Id and name.
     *
     * $summarised is an array that maps from the Event that will be summarised to the
     * Event that summarises it. The keys and values are indexes in $view->result.
     */
    $eventsByActivity = array();
    $summarised = array();
    foreach ($view->result as $r => $result) {
      /*
       * Do not summarise Events that aren't part of an Activity
       */
      if (!isset($result->field_field_in_activity[0]['raw']['target_id'])) {
        continue;
      }
      $activity = $result->field_field_in_activity[0]['raw']['target_id'];

      /*
       * Get the title
       */
      if (isset($result->node_title)) {
        $name = $result->node_title;
      } elseif (isset($result->civicrm_event_title)) {
        $name = $result->civicrm_event_title;
      } elseif (isset($result->field_field_title)) {
        $name = $result->field_field_title[0]['rendered']['#markup'];
      } else {
        continue;
      }

      /*
       * Find the event which can summarise this one
       */
      $summaryEvent = false;
      if (!isset($eventsByActivity[$activity])) {
        $eventsByActivity[$activity] = [];
      }
      foreach ($eventsByActivity[$activity] as $n => $i) {
        if ($n == $name) {
          $summaryEvent = $i;
          break;
        }
      }
      if ($summaryEvent !== false) {
        $summarised[$r] = $summaryEvent;
      }
      else {
        $eventsByActivity[$activity][$name] = $r;
      }
    }

    /*
     * If any events are summarised, remove them from the results.
     * Also stash the node alias of the event's Activity.
     */
    if (!empty($summarised)) {
      $alteredResults = [];
      foreach ($view->result as $r => $result) {
        if (!isset($summarised[$r])) {
          if (in_array($r, $summarised)) {
            $result->__cbf_merge_events = drupal_get_path_alias("node/" . $result->field_field_in_activity[0]['raw']['target_id']);
          }
          $alteredResults[] = $result;
        }
      }
      $view->result = $alteredResults;
    }

    /*
     * Since we may have summarised multiple events into one, we can't
     * rely on the view to limit the number of events displayed.
     */
    $maximumDisplayed = 5;
    $matches = [];
    if (
      preg_match(
        '/(^| )show-([0-9]+)-items($| )/i',
        $view->display_handler->get_option('css_class'),
        $matches
      ) == 1) {
      $maximumDisplayed = intval($matches[2]);
    }
    if (count($view->result) > $maximumDisplayed) {
      $alteredResults = [];
      $i = 0;
      foreach ($view->result as $r => $result) {
        if ($i++ == $maximumDisplayed) {
          break;
        }
        $alteredResults[] = $result;
      }
      $view->result = $alteredResults;
    }
  }

  /*
   * If a view returns no results, and the 'no results' behaviour is to return
   * the results of a second view, we want the title of this view to equal that
   * of the second.
   */
  if (
     empty($view->result) &&
    !empty($view->empty['view']->options['view_to_insert'])
  ) {
    list($view_name, $display_id) = explode(':', $view->empty['view']->options['view_to_insert']);
    $noResults = views_get_view($view_name);
    if (
      !empty($noResults) &&
      $noResults->access($display_id)
    ) {
      $noResults->set_display($display_id);
      $title = $noResults->get_title();
      $view->set_title($title);
    }
  }

  /*
   * If a field_field_source_entity_type is (say) 'civicrm_event' then any
   * URL built from it needs to contain 'civicrm-event'.
   */
  foreach ($view->result as $r => $result) {
    if (isset($result->field_field_source_entity_type)) {
      $result->field_field_source_entity_type[0]['rendered']['#markup']
        = str_replace('_', '-', $result->field_field_source_entity_type[0]['rendered']['#markup']);
    }
  }

  /*
   * Titles for the Bigger Questions iTunes feed need to include the Speaker
   * names.
   */
  if (
    $view->name == 'campus_podcasts'
    && $view->current_display == 'feed_3'
  ) {
    foreach ($view->result as $r => $result) {
      if (
        strpos($result->node_title, '|') === false
        && $result->nid > 3655
      ) {
        $count = count($result->field_field_speakers);
        $speakers = '';
        foreach ($result->field_field_speakers as $i => $speaker) {
          if ($i == 0) {
            $speakers .= ' | ';
          }
          else if ($i == $count - 1) {
            $speakers .= ' & ';
          }
          else {
            $speakers .= ', ';
          }
          $speakers .= $speaker['rendered']['#markup'];
        }
        $view->result[$r]->node_title .= $speakers;
      }
    }
  }

  /*
   * If the view is 'cbf2019_local_office' and the current Domain is
   * Third Space, then overwrite the email address with the Third Space
   * public email address.
   */
  if ($view->name == 'cbf2019_local_office') {
    if (stristr(domain_get_domain()['subdomain'], 'thirdspace') !== false) {
      foreach ($view->result as $i => $_) {
        $view->result[$i]->civicrm_contact_field_data_field_organisation_contact__civic_11
          = 'info@thirdspace.org.au';
      }
    }
  }
}

/*
 * An implementation of hook_contextual_links_view_alter
 *
 * Alter a contextual links element before it is rendered.
 *
 * This hook is invoked by contextual_pre_render_links(). The renderable array
 * of #type 'contextual_links', containing the entire contextual links data
 * that is passed in by reference. Further links may be added or existing
 * links can be altered.
 */
function cbf_contextual_links_view_alter(&$element, $items) {
  /*
   * With nodes it doesn't make sense for the destination of the contextual
   * link to be the same node. Eg, 'delete' and 'clone content'. Remove the
   * destination by removing the query from the link URL.
   */
  if (isset($element['#element']['#node'])) {
    foreach (array('node-delete', 'node-clone-') as $i) {
      if (!empty($element['#links'][$i]['query'])) {
        $element['#links'][$i]['query'] = array();
      }
    }
  }
}

/*
 * An implementation of theme_entity_property()
 *
 * Some properties include HTML and the default behaviour is that the entities
 * are encoded. In these cases, decode them.
 */
function cbf_entity_property($variables) {
  switch ($variables['elements']['#entity_type']) {
    case 'civicrm_event':
      switch ($variables['elements']['#property_name']) {
        case 'description':
          $variables['content'] = decode_entities($variables['content']);
          break;
      }
      break;
  }
  $variables['label_hidden'] = true;

  return theme_entity_property($variables);
}

/*
 * If the $output string is being displayed on a page associated with a
 * particular $city, then remove strings of the form ' in $city'.
 *
 * Purpose:
 *    To avoid blocks having repeating references to ' in $city' when
 *    the page context tells us we are ' in $city'.
 *
 * Examples:
 *  - On the page /city/sydney remove the string ' in Sydney' from
 *    the 'node'/'title' of Activities listed in views.
 *  - On the page /city/activity/public-forum don't change the titles
 *    of sub-activities, which are ' in Sydney', ' in Perth' etc.
 *
 * Potential issues:
 *  - May need to restrict logic to blocks.
 *  - $output is HTML so may contain ' in $city' as part of the markup.
 *    This is unlikely given the current conventions for URLs, CSS class
 *    names etc.
 */
function cbf_trim_in_city_string($output) {
  $city = cbf_city_string();
  if ($city !== false) {
    $output = str_replace(' in ' . ucwords($city), '', $output);
  }
  return $output;
}

function cbf_preprocess_html(&$variables) {
  // Is this page associated with a city? Add a CSS class accordingly.
  $city = cbf_city_string();
  if ($city !== false) {
    $variables['classes_array'][] = 'city-' . $city;
  }
}

/*
 * Returns HTML for a breadcrumb trail
 */
function cbf_breadcrumb($variables, $structure) {
  $breadcrumb = array();
  $city = cbf_city_string();
  if (!empty($city)) {
    $prefix = "/city/$city";
  }
  else {
    $prefix = '/city';
  }

  foreach ($structure as $context => $components) {
    switch ($context) {
      case 'front';
        if (drupal_is_front_page()) {
          break 2;
        }
        break;

      case 'node';
        $node = menu_get_object();
        if (!empty($node)) {
          $type = $node->type;
          break 2;
        }
        break;

      case 'default';
        break 2;
    }
  }

  foreach ($components as $component => $default) {
    $new = null;
    switch ($component) {
      case 'home';
        $new = array($component, 'Home', '/');
        break;

      case 'city';
        if (!empty($city)) {
          $new = array($component, ucwords($city), $prefix);
        }
        break;

      case 'type';
        if (!empty($type)) {
          switch ($type) {
            case 'event':
              $new = array($component, 'events', "$prefix/events");
              break;
            case 'story':
              $new = array($component, 'news', "$prefix/news");
              break;
            case 'episode':
              $new = array($component, 'library', '/library');
              break;
            case 'blog':
              $new = array($component, 'blog', '/articles');
              break;
            case 'activity':
              $new = array($component, 'activities', "$prefix/activities");
              break;
          }
        }
        break;
    }

    if (!empty($new)) {
      $breadcrumb[] = $new;
    }
    elseif (!empty($default)) {
      $breadcrumb[] = array($component, $default, null);
    }
  }

  $output = '';
  if (!empty($breadcrumb)) {
    $output = '<div class="breadcrumb">';
    foreach ($breadcrumb as $crumb) {
      $output .= '<span class="crumb ' . $crumb[0] . '">';
      if (!empty($crumb[2])) {
        $output .= '<a href="' . $crumb[2] . '">' . $crumb[1] . '</a>';
      }
      else {
        $output .= $crumb[1];
      }
      $output .= '</span>';
    }
    $output .= '</div>';
  }

  return $output;
}

/**
 * Implements hook_webform_validation_validators()
 */
function cbf_webform_validation_validators() {
  return array(
    'existing_contact_id' => array(
      'name' => 'Existing Contact Id',
      'description' => "Validate the Contact already exists",
      'component_types' => array(
        'civicrm_contact',
      ),
    )
  );
}

/**
 * Implements hook_webform_validation_validate()
 *
 * Validates that Webform CiviCRM components of type 'civicrm_contact' already exist.
 * If an existing contact is chosen the value captured is a string containing a
 * positive integer. If the component is empty the value captured is empty. Otherwise
 * the value captured is a hyphen followed by the content typed by the user.
 */
function cbf_webform_validation_validate($validator_name, $items, $components, $rule) {
  if ($items) {
    switch ($validator_name) {
      case 'existing_contact_id':
        $errors = array();
        $filterOptions = array(
          'options' => array(
            'min_range' => 1,
          ),
        );
        foreach ($items as $key => $value) {
          if (filter_var($value, FILTER_VALIDATE_INT, $filterOptions) === false) {
            $errors[$key] = t('%item is not a valid contact', array('%item' => $components[$key]['name']));
          }
        }
        return $errors;
        break;
    }
  }
}

/**
 * Modify an iCal event's raw data. If the event is derived from a viewable
 * EntityForm which has a field_field_source_entity_alias then use that field
 * for the iCal event's URL.
 *
 * This hook is invoked after Date iCal has gathered all the data it will use
 * to build an event object.
 *
 * @param array $event
 *   A reference to an associative array containing the event's raw data.
 * @param object $view
 *   The view object that is being executed to render the iCal feed.
 * @param array $context
 *   Depending on whether this event is being constructed using the Fields or
 *   Entity plugins, this context array will have different keys and values.
 *
 *   Entity Plugin:
 *   - 'entity_type': The type of entity being rendered (e.g. 'node').
 *   - 'entity': The fully loaded entity being rendered.
 *   - 'language': The language code that indicates which translation of field
 *     data should be used.
 *
 *   Fields Plugin:
 *   - 'row': The full Views row object being converted to an event.
 *   - 'row_index': The index into the query results for this view.
 *   - 'language': The language code that indicates which translation of field
 *     data should be used.
 *   - 'options': The Fields plugin options.
 */
function cbf_date_ical_export_raw_event_alter(&$event, $view, $context) {
  global $base_url;

  if (!empty($context['row'])) {
    $row = $context['row'];
    if (!empty($row->field_field_source_entity_alias[0]['raw']['value'])) {
      $event['url'] = $base_url . '/' . $row->field_field_source_entity_alias[0]['raw']['value'];
    }
  }
}

function cbf_entity_insert($entity, $type) {
  cbf_entity_viewable($entity, $type, 'insert');
}

function cbf_entity_update($entity, $type) {
  cbf_entity_viewable($entity, $type, 'update');
}

function cbf_entity_delete($entity, $type) {
  cbf_entity_viewable($entity, $type, 'delete');
}

function cbf_entity_viewable($entity, $type, $operation) {
  $entityTypes = [
    'node' => [
      'id' => 'nid',
      'type' => 'type',
      'status' => 'status',
      'bundles' => [
        'activity' => [
          'highlightable',
        ],
        'blog' => [
          'highlightable',
        ],
        'episode' => [
          'highlightable',
        ],
        'event' => [
          'dateable',
          'highlightable',
        ],
        'page' => [
          'highlightable',
        ],
        'story' => [
          'dateable',
          'highlightable',
        ],
      ],
    ],
    'civicrm_event' => [
      'id' => 'id',
      'status' => [
        'is_public',
        'is_active',
      ],
      'viewables' => [
        'dateable',
        'highlightable',
        'mappable',
      ],
    ],
    'entityform' => [
      'id' => 'entityform_id',
      'type' => 'type',
      'bundles' => [
        'regular_venue' => [
          'mappable',
        ],
        'ministry_team' => [
          'mappable',
        ],
      ],
    ],
  ];

  /*
   * Look up entity $type to determine what viewable entities are supported
   * Some entity $type's have bundles
   */
  $viewables = [ ];
  if (isset($entityTypes[$type])) {
    if (
      isset($entityTypes[$type]['bundles']) &&
      isset($entityTypes[$type]['bundles'][$entity->{$entityTypes[$type]['type']}])
    ) {
      $viewables = $entityTypes[$type]['bundles'][$entity->{$entityTypes[$type]['type']}];
    }
    elseif (isset($entityTypes[$type]['viewables'])) {
      $viewables = $entityTypes[$type]['viewables'];
    }

    /*
     * The $sourceEntityId is the Id of the source $entity.
     * Internally it is used with source entity $type as a 'unique' key to look
     * up the viewable entity that corresponds to the source entity.
     */
    $sourceEntityId = $entity->{$entityTypes[$type]['id']};

    /*
     * Check the status of the entity. The fields of the viewable entity will
     * only be retrieved if($status) succeeds.
     */
    if (isset($entityTypes[$type]['status'])) {
      if (is_array($entityTypes[$type]['status'])) {
        $status = true;
        foreach ($entityTypes[$type]['status'] as $statusFieldName) {
          $status &= !empty($entity->{$statusFieldName});
        }
      }
      else {
        $status = !empty($entity->{$entityTypes[$type]['status']});
      }
    }
    else {
      $status = true;
    }
  }

  /*
   * Process each viewable entity that may be associated with the source $entity
   */
  foreach ($viewables as $viewable) {
    /*
     * Look for the 'unique' viewable entity that corresponds to the source entity
     * Warn if it is not unique
     */
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'entityform')
      ->entityCondition('bundle', $viewable)
      ->fieldCondition('field_source_entity_type', 'value', $type, '=')
      ->fieldCondition('field_source_entity_id', 'value', $sourceEntityId, '=')
      // Run the query as user 1.
      ->addMetaData('account', user_load(1));

    $entityForm = null;
    $result = $query->execute();
    foreach ($result as $entityType => $entities) {
      foreach ($entities as $id => $_) {
        $ent = entity_load_single($entityType, $id);
        if ($ent === false) {
          watchdog(
            'CBF',
            "Source entity $type/$sourceEntityId has multiple $viewable entities - couldn't load entityform/$id but deleting it",
            null,
            WATCHDOG_ERROR
          );
          entity_delete('entityform', $id);
        }
        elseif ($entityForm === null) {
          $entityForm = $ent;
        }
        else {
          watchdog(
            'CBF',
            "Source entity $type/$sourceEntityId has multiple $viewable entities - deleting entityform/$id",
            null,
            WATCHDOG_ERROR
          );
          entity_delete('entityform', $id);
        }
      }
    }

    /*
     * Get the fields from the source $entity
     */
    if ($status && $operation != 'delete') {
      $viewableFunction = "cbf_entity_$viewable";
      $viewableEntity = $viewableFunction($entity, $type, $entityForm);
    }
    else {
      $viewableEntity = [ ];
    }

    if (!empty($viewableEntity)) {
      /*
       * This entity has fields that need to be reproduced in a viewable entity
       */

      /*
       * If the viewable entity wasn't found, create it
       */
      if (empty($entityForm)) {
        global $user;

        $entityForm = entity_create(
          'entityform',
          [
            'type' => $viewable,
            'created' => time(),
            'changed' => time(),
            'language' => LANGUAGE_NONE,
            'uid' => $user->uid,
          ]
        );
      }

      /*
       * Set the fields
       */
      try {
        $wrapper = entity_metadata_wrapper('entityform', $entityForm);
        $wrapper->field_source_entity_type = $type;
        $wrapper->field_source_entity_id = $sourceEntityId;
        foreach ($viewableEntity as $name => $value) {
          $wrapper->$name = $value;
        }

        $wrapper->save();
      }
      catch (EntityMetadataWrapperException $e) {
        watchdog(
          'CBF',
          "Source entity $type/$sourceEntityId caused exception: " . $e->getMessage(),
          null,
          WATCHDOG_ERROR
        );
      }
    }
    else {
      /*
       * This entity has no content that needs to be reproduced in a viewable entity
       * Delete the viewable entity
       */
      if (!empty($entityForm)) {
        entity_delete('entityform', $entityForm->entityform_id);
      }
    }
  }
}

/*
 * cbf_entity_viewable_fields() gets the named $fields from the source $entity
 * and the defaults for the named $activityDefaults fields from the Activity
 * of the $entity.
 */
function cbf_entity_viewable_fields($entity, $type, $currentForm, $fields, $activityDefaults) {
  /*
   * Metadata for the fields in the source $entity. Each of the $fields in
   * the viewable entity is matched against one of these $fromFields in
   * the source $entity. The metadata is ...
   *  - field    - the name of the field in the source $entity
   *  - value    - controls how the field value is obtained (see below)
   *  - required - if the retrieved field value is null, and 'required' is
   *               true, then return a failure (empty result array) so the
   *               viewable entity will not be created
   *  - default  - if the retrieved field value is null, and 'required' is
   *               false, then use the default value
   */
  $fromFields = [
    'field_title' => [
      'field' => 'field_title',
      'value' => 'value',
      'default' => empty($entity->title) ? null : $entity->title,
    ],
    'field_subtitle' => [
      'field' => 'field_subtitle',
      'value' => 'value',
      'default' => '',
    ],
    'field_summary' => [
      'field' => 'field_summary',
      'value' => 'value',
      'default' => '',
    ],
    'taxonomy_vocabulary_1' => [
      'field' => 'taxonomy_vocabulary_1',
      'value' => 'tid',
      'default' => null,
    ],
    'taxonomy_vocabulary_3' => [
      'field' => 'taxonomy_vocabulary_3',
      'value' => 'tid',
      'required' => true,
    ],
    'field_activity_category' => [
      'field' => 'field_activity_category',
      'value' => 'tid',
      'default' => null,
    ],
    'field_marker' => [
      'field' => 'field_marker',
      'value' => 'tid',
      'default' => null,
    ],
    'field_map_region' => [
      'field' => 'field_map_region',
      'value' => 'tid',
      'default' => null,
    ],
    'field_in_activity' => [
      'field' => 'field_in_activity',
      'value' => 'target_id',
      'default' => null,
    ],
    'field_event_date' => [
      'field' => 'field_event_date',
      'value' => 'array',
      'default' => null,
    ],
    'field_episode_date' => [
      'field' => 'field_episode_date',
      'value' => 'get timestamp',
      'default' => null,
    ],
    'field_highlight_dates' => [
      'field' => 'field_highlight_dates',
      'value' => 'array',
      'default' => null,
    ],
    'field_thumbnail_image' => [
      'field' => 'field_thumbnail_image',
      'value' => 'reset array',
      'default' => null,
    ],
    'field_highlight' => [
      'field' => 'field_highlight',
      'value' => 'reset array',
      'default' => null,
    ],
    'field_highlight_location' => [
      'field' => 'field_highlight_location',
      'value' => 'array',
      'default' => null,
    ],
    'field_map_location' => [
      'field' => 'field_map_location',
      'value' => 'reset array',
      'default' => null,
    ],
    'field_order_url' => [
      'field' => 'field_order_url',
      'value' => 'reset array',
      'default' => null,
    ],
    'domain_entityform' => [
      'field' => 'field_domain',
      'value' => 'array',
      'default' => null,
    ],
    'field_source_entity_bundle' => [
      'field' => 'field_source_entity_bundle',
      'value' => 'value',
      'default' => null,
    ],
  ];

  /*
   * If there are $activityDefaults then load the 'defaults' in the $fromFields
   * with the values from the 'field_in_activity' and set those fields as not
   * 'required' as there is a default available from the Activity.
   */
  if (!empty($activityDefaults)) {
    $activity = field_get_items($type, $entity, 'field_in_activity');
    $activity = empty($activity) ? false : entity_load('node', reset($activity));
    $activity = empty($activity) ? false : reset($activity);
    if (!empty($activity)) {
      foreach ($activityDefaults as $to) {
        $from = $fromFields[$to];
        $field = field_get_items('node', $activity, $from['field']);
        if (!empty($field)) {
          unset($fromFields[$to]['required']);
          switch ($from['value']) {
            /*
             * The 'value' metadata controls how the $field value is extracted ...
             *  - 'array'         - all values in the field
             *  - 'reset array'   - the first element in the value array
             *  - 'get timestamp' - treat the first element as a date array
             *  - otherwise the 'value' is interpreted as the name of an element
             *    in the first element of the value array
             */
            case 'array':
              $fromFields[$to]['default'] = $field;
              break;

            case 'reset array':
              $fromFields[$to]['default'] = reset($field);
              break;

            case 'get timestamp':
              $field = reset($field);
              $time = new DateObject($field['value'], $field['timezone']);
              $fromFields[$to]['default'] = strtotime($time->format('Y-m-d H:i:s O'));
              break;

            default:
              $fromFields[$to]['default'] = reset($field)[$from['value']];
              break;
          }
        }
      }
    }
  }

  /*
   * The default for field_source_entity_bundle comes from the $entity's type
   */
  switch ($type) {
    case 'node':
    case 'entityform':
      $fromFields['field_source_entity_bundle']['default'] = $entity->type;
      break;

    case 'civicrm_event':
      $fromFields['field_source_entity_bundle']['default'] = $type;
      break;
  }

  /*
   * The Ministry Team EntityForms have most of their data in CiviCRM,
   * so get the field defaults from there.
   */
  if (
    $type == 'entityform'
    && $entity->type == 'ministry_team'
  ) {
    $defaults = [ ];
    $team = field_get_items($type, $entity, 'field_ministry_team');
    $team = empty($team) ? false : reset($team)['contact_id'];
    $team = cbf_civicrm_ministry_team_viewable_fields($team);
    $teamFieldMap = [
      'nickname' => 'field_title',
      'meeting day/time' => 'field_summary',
      'address' => 'field_map_location',
    ];
    foreach ($teamFieldMap as $from => $to) {
      if (in_array($to, $fields) && !empty($team[$from])) {
        $defaults[$to] = $team[$from];
      }
    }

    if (in_array('field_order_url', $fields) && !empty($team['staff contact'])) {
      $defaults['field_order_url'] = [
       'url' => '/staff-contact?cid1='. $team['staff contact']['id'],
       'title' => $team['staff contact']['display_name'],
       'attributes' => [],
      ];
    }

    if (in_array('taxonomy_vocabulary_1', $fields)) {
      $query = new EntityFieldQuery();
      $query
        ->entityCondition('entity_type', 'taxonomy_term')
        ->entityCondition('bundle', 'vocabulary_1')
        ->fieldCondition('field_civicrm_tag', 'target_id', $team['tags'], 'in') ;
      $terms = $query->execute();
      foreach ($terms as $entityType => $entities) {
        foreach($entities as $tid => $_) {
          $defaults['taxonomy_vocabulary_1'] = $tid;
          break 2;
        }
      }
    }

    if (in_array('taxonomy_vocabulary_3', $fields)) {
      /*
       * Hardcoded assumption this is an EPT so Audience is Christian
       */
      $defaults['taxonomy_vocabulary_3'] = 47;
    }

    if (in_array('field_in_activity', $fields)) {
      /*
       * Hardcoded assumption this is an EPT so Activity is Prayer Teams
       */
      $defaults['field_in_activity'] = 1222;
    }

    if (in_array('field_map_region', $fields)) {
      $query = new EntityFieldQuery();
      $query
        ->entityCondition('entity_type', 'taxonomy_term')
        ->entityCondition('bundle', 'region')
        ->fieldCondition('field_civicrm_tag', 'target_id', $team['tags'], 'in') ;
      $terms = $query->execute();
      $defaults['field_map_region'] = [];
      foreach ($terms as $entityType => $entities) {
        foreach($entities as $tid => $_) {
          $defaults['field_map_region'][] = $tid;
        }
      }
    }

    foreach ($defaults as $to => $default) {
      unset($fromFields[$to]['required']);
      $fromFields[$to]['default'] = $default;
    }
  }

  $result = [ ];

  foreach ($fields as $to) {
    $from = $fromFields[$to];
    $field = field_get_items($type, $entity, $from['field']);

    /*
     * If the $field in $entity is empty, either fail if the field is required,
     * or use the default value.
     */
    if (empty($field)) {
      if (!empty($from['required'])) {
        return [ ];
      }
      $result[$to] = $from['default'];
    }
    else switch ($from['value']) {
      /*
       * The 'value' metadata controls how the $field value is extracted ...
       *  - 'array'         - all values in the field
       *  - 'reset array'   - the first element in the value array
       *  - 'get timestamp' - treat the first element as a date array
       *  - otherwise the 'value' is interpreted as the name of an element
       *    in the first element of the value array
       */
      case 'array':
        $result[$to] = $field;
        break;

      case 'reset array':
        $result[$to] = reset($field);
        break;

      case 'get timestamp':
        $field = reset($field);
        $time = new DateObject($field['value'], $field['timezone']);
        $result[$to] = strtotime($time->format('Y-m-d H:i:s O'));
        break;

      default:
        $result[$to] = reset($field)[$from['value']];
        break;
    }
  }

  /*
   * Special case - the thumbnail image is sourced from the available images in
   * the following order of preference ...
   *  - field_thumbnail_image
   *  - field_series_image
   *  - field_image
   *  - field_highlight
   */
  if (in_array('field_thumbnail_image', $fields) && empty($result['field_thumbnail_image'])) {
    $field = field_get_items($type, $entity, 'field_series_image');
    if (!empty($field)) {
      $result['field_thumbnail_image'] = reset($field);
    }
    else {
      $field = field_get_items($type, $entity, 'field_image');
      if (!empty($field)) {
        $result['field_thumbnail_image'] = reset($field);
      }
      else {
        $field = field_get_items($type, $entity, 'field_highlight');
        if (!empty($field)) {
          $result['field_thumbnail_image'] = reset($field);
        }
      }
    }
  }

  /*
   * Special case - if the source $entity is a civicrm_event its subtitle will
   * be found in the 'summary' attribute.
   * A field_subtitle is limited to 128 characters in length.
   */
  if (in_array('field_subtitle', $fields) && !empty($entity->summary)) {
    $result['field_subtitle'] = substr($entity->summary, 0, 128);
  }

  /*
   * Special case - if the source $entity is a node the 'domains' attribute
   * holds the domain values
   */
  if (in_array('domain_entityform', $fields) && !empty($entity->domains)) {
    $result['domain_entityform'] = [ ];
    foreach ($entity->domains as $domain) {
      $result['domain_entityform'][] = [ 'domain_id' => $domain ];
    }
  }

  /*
   * Special case - if the source $entity is an EntityForm the 'domain_entityform'
   * attribute holds the domain values
   */
  if (in_array('domain_entityform', $fields) && !empty($entity->domain_entityform)) {
    $result['domain_entityform'] = reset($entity->domain_entityform);
  }

  /*
   * Special case - if the source $entity is a civicrm_event its location needs
   * to be retrieved
   */
  if ($type == 'civicrm_event' && in_array('field_map_location', $fields)) {
    // We cannot map it if its next action is zero.
    $field_next_action = field_get_items($type, $entity, 'field_next_action');
    if ($field_next_action !== false && empty($field_next_action[0]['value'])) {
      return [ ];
    }

    // Get the location from CiviCRM
    $result['field_map_location'] = cbf_civicrm_civicrm_event_get_location_data($entity->id);

    // If the $currentForm already has a location recycle the Location ID
    if (!empty($result['field_map_location']) && isset($currentForm)) {
      $location = field_get_items('entityform', $currentForm, 'field_map_location');
      if (isset($location[0]['lid'])) {
        $result['field_map_location']['lid'] = $location[0]['lid'];
      }
    }
  }

  /*
   * Special case - if creating a mappable from a regular_venue, field_title is empty.
   * The title isn't needed because the regular_venue is associated with an activity.
   */
  if (
    $type == 'entityform'
    && $entity->type == 'regular_venue'
    && in_array('field_map_location', $fields)
    && in_array('field_title', $fields)
  ) {
    $result['field_title'] = '';
  }

  /*
   * Special case - if the source $entity is a civicrm_event then its 
   * field_order_url should be ignored (it is a non-CiviCRM registration link)
   */
  if ($type == 'civicrm_event' && in_array('field_order_url', $fields)) {
    $result['field_order_url'] = null;
  }

  return $result;
}

/*
 * cbf_entity_dateable() gets the needed $fields from the source $entity
 */
function cbf_entity_dateable($entity, $type, $currentForm) {
  return cbf_entity_viewable_fields(
    $entity,
    $type,
    $currentForm,
    [
      "field_title",
      "field_subtitle",
      "taxonomy_vocabulary_1",
      "taxonomy_vocabulary_3",
      "field_in_activity",
      "field_event_date",
      "field_episode_date",
      "field_thumbnail_image",
      "field_highlight_location",
      "domain_entityform",
    ],
    [ ]
  );
}

/*
 * cbf_entity_highlightable() gets the needed $fields from the source $entity
 */
function cbf_entity_highlightable($entity, $type, $currentForm) {
  return cbf_entity_viewable_fields(
    $entity,
    $type,
    $currentForm,
    [
      "field_title",
      "field_subtitle",
      "taxonomy_vocabulary_1",
      "taxonomy_vocabulary_3",
      "field_in_activity",
      "field_highlight",
      "field_highlight_location",
      "field_activity_category",
      "field_highlight_dates",
      "domain_entityform",
    ],
    [ ]
  );
}

/*
 * cbf_entity_highlightable() gets the needed $fields from the source $entity
 */
function cbf_entity_mappable($entity, $type, $currentForm) {
  return cbf_entity_viewable_fields(
    $entity,
    $type,
    $currentForm,
    [
      "field_source_entity_bundle",
      "field_title",
      "field_summary",
      "field_map_location",
      "taxonomy_vocabulary_1",
      "taxonomy_vocabulary_3",
      "field_in_activity",
      "field_marker",
      "field_map_region",
      "field_order_url",
      "domain_entityform",
    ],
    [
      "taxonomy_vocabulary_1",
      "taxonomy_vocabulary_3",
    ]
  );
}

/*
 * This hook defines administrative paths.
 */
function cbf_admin_paths() {
  $paths = [
    /*
     * When 'civicrm-event/NNNN/edit' is not an admin path, the call to
     * entity_load() in cbf_entity_viewable() fails to return entities
     * which are not visible in this domain.
     */
    'civicrm-event/*/edit' => true,
  ];
  return $paths;
}

function cbf_convert_banner_to_city_tid() {
  $query_parameters = drupal_get_query_parameters();
  if (empty($query_parameters['field_highlight_location_tid'])) {
    return null;
  }
  switch ($query_parameters['field_highlight_location_tid']) {
    case 1041; // Adelaide
      return 5;
    case 1042; // Brisbane
      return 3;
    case 1073; // Canberra
      return 1068;
    case 1191; // Hobart
      return 1126;
    case 1043; // Melbourne
      return 2;
    case 1044; // Perth
      return 4;
    case 1045; // Sydney
      return 1;
    default:   // eg 'All' or an unrecognised value
      return null;
  }
}

/*
 * Implement a cache of fields displayed in a view that are required
 * to be unique.
 *
 * If the argument is false then clear the cache (for use in another view).
 *
 * The return value tells whether $field has already been seen.
 */
function cbf_is_views_field_cached($field) {
  static $cache = [];

  if ($field === false) {
    $cache = [];
    return false;
  }

  foreach ($cache as $cached) {
    if ($field == $cached) {
      return false;
    }
  }

  $cache[] = $field;
  return true;
}

/*
 * Implements hook_entity_info_alter
 *
 * Alter the entity info.
 *
 * Modules may implement this hook to alter the information that defines an
 * entity. All properties that are available in hook_entity_info() can be
 * altered here.
 */
function cbf_entity_info_alter(&$entity_info) {

  /*
   * Set up the CBF entity label callback
   */
  $entity_info['entityform']['label callback'] = 'cbf_entityform_label_callback';
}

function cbf_entityform_label_callback($entity, $entity_type) {
  $title = field_get_items($entity_type, $entity, 'field_title');
  if (empty($title) || !is_array($title)) {
    $title = $entity->label();
  }
  else {
    $title = $title[0]['value'];
  }
  return $title;
}
